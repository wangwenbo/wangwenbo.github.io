<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> PHP 内核学习 -- 变量的作用域和生命周期 · Web PHP</title><meta name="description" content="A Blog Powered By Hexo"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/favicon.png"><link rel="stylesheet" href="/css/jekyll.css"><!--[if lt IE 9]>
<script src="js/html5shiv.min.js"></script>
<script src="js/respond.min.js"></script>
<![endif]--></head><body><header class="row-flex-row limit-width vh-center"><a href="/" class="logo"><img src="/favicon.png"></a><nav><ul class="nav-list"><li class="nav-list-item"><a href="/" class="nav-link">主页</a></li><li class="nav-list-item"><a href="/archives/" class="nav-link active">   博客</a></li><li class="nav-list-item"><a href="/atom.xml" class="nav-link">rss</a></li><li class="nav-list-item"><a href="https://github.com/xxxxx" target="_blank" class="nav-link">   github</a></li></ul></nav></header><div class="container limit-width"><section class="row-flex-row"><div class="post"><article class="post-block"><h2 class="post-title"><a href="/2015/08/08/varlifttime/" class="post-title-link">PHP 内核学习 -- 变量的作用域和生命周期</a></h2><div class="post-meta"><ul class="post-tag-list"><li class="post-tag-item"><a href="/tags/PHP内核-变量-作用域-生命周期/" class="post-tag-link">PHP内核 变量 作用域 生命周期</a></li></ul><div class="post-time">Tuesday, February 23rd 2016</div></div><div class="post-content"><h3 id="作用域_生命周期"><strong>作用域</strong> <strong>生命周期</strong></h3><p>变量的作用域本质是一块代码区域，在这个区域内可以访问某个具体的变量，超出这个区域后，变量就无法被访问到。</p>
<h4 id="全局变量和局部变量">全局变量和局部变量</h4><p>全局变量是在整个程序中任何地方随意调用的变量， 在PHP中，除了声明在函数体内的普通变量均为全局变量，在函数体内则可以通过global语句来声明。 相对于全局变量，局部变量的作用域是程序中的部分代码（如函数中），而不是程序的全部。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scope</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="variable">$liftcycle</span> = <span class="string">"wang"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量的生命周期和作用域有一定的联系，如函数中的局部变量$filecycle，它的生命开始于函数scope的执行，结束于函数执行完毕。</p>
<p>PHP变量的作用域是如何实现 ？全局变量和局部变量的的作用域实现有什么区别？</p>
<p>zend引擎有一个_zend_executor_globals结构，全局变量就保存在symbol_table这个全局符号表中；active_symbol_table中保存局部变量，这些局部变量可能是来自用户自定的函数或者对象的属性等；而且每个独立的函数运行时都有自己的active_symbol_table来保证作用域互相独立。</p>
<p>下面来看一下，_zend_execute_data (zend/zend_complie.h)的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">		</span><br><span class="line">   <span class="keyword">typedef</span> <span class="keyword">struct</span> _zend_execute_data &#123;    </span><br><span class="line">	<span class="keyword">struct</span> _zend_op *opline;</span><br><span class="line">	zend_function_state function_state;</span><br><span class="line">	zend_op_array *op_array;</span><br><span class="line">	zval *object;</span><br><span class="line">	HashTable *symbol_table;</span><br><span class="line">	<span class="keyword">struct</span> _zend_execute_data *prev_execute_data;</span><br><span class="line">	zval *old_error_reporting;</span><br><span class="line">	zend_bool nested;</span><br><span class="line">	zval **original_return_value;</span><br><span class="line">	zend_class_entry *current_scope;</span><br><span class="line">	zend_class_entry *current_called_scope;</span><br><span class="line">	zval *current_this;</span><br><span class="line">	<span class="keyword">struct</span> _zend_op *fast_ret; <span class="comment">/* used by FAST_CALL/FAST_RET (finally keyword) */</span></span><br><span class="line">	zval *delayed_exception;</span><br><span class="line">	call_slot *call_slots;</span><br><span class="line">	call_slot *call;</span><br><span class="line">&#125; zend_execute_data;</span><br></pre></td></tr></table></figure>
<p>函数中的局部变量就存储在_zend_execute_data的symbol_table中，在执行当前函数的op_array时， 全局zend_executor_globals中的<em>active_symbol_table会指向当前_zend_execute_data中的</em>symbol_table。 因为每个函数调用开始时都会重新初始化EG(active_symbol_table)为NULL， 在这个函数的所有opcode的执行过程中这个全局变量会一直存在，并且所有的局部变量修改都是在它上面操作完成的，如前面的赋值操作等。 而此时，其他函数中的symbol_table会存放在栈中，将当前函数执行完并返回时，程序会将之前保存的zend_execute_data恢复， 从而其他函数中的变量也就不会被找到，局部变量的作用域就是以这种方式来实现的。 相关操作在 Zend/zend_vm_execute.h 文件中定义的execute函数中一目了然，如下所示代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">zend_vm_enter:</span><br><span class="line"><span class="comment">/* Initialize execute_data */</span></span><br><span class="line">execute_data = (zend_execute_data *)zend_vm_stack_alloc(</span><br><span class="line">    <span class="keyword">sizeof</span>(zend_execute_data) +</span><br><span class="line">    <span class="keyword">sizeof</span>(zval**) * op_array-&gt;last_var *(EG(active_symbol_table) ? <span class="number">1</span> : <span class="number">2</span>) +</span><br><span class="line">    <span class="keyword">sizeof</span>(temp_variable) * op_array-&gt;T TSRMLS_CC);</span><br><span class="line"> </span><br><span class="line">EX(symbol_table) = EG(active_symbol_table);</span><br><span class="line">EX(prev_execute_data) = EG(current_execute_data);</span><br><span class="line">EG(current_execute_data) = execute_data;</span><br></pre></td></tr></table></figure>
<p>EX宏的作用是获取结构体zend_execute_data的字段值。它的实现是:#define EX(element) execute_data-&gt;element</p>
<h4 id="全局宏">全局宏</h4><ul>
<li>EG(Executor Globals)：zend引擎内部用来追踪当前请求的处理状态，这些信息包括系统符号表，函数和类表，常量和资源类型。</li>
<li>CG(Core Globals)：zend引擎在脚本执行和各种深入内核的执行时使用。自定义的扩展很少会使用到它。</li>
<li>PG(PHP Globals)：php的配置 如PG(register_globals),PG(safe_mode)和PG(memory_limit)</li>
<li>FG(FILE Globals)：大多数的文件I/或者和流处理相关的全局变量都被塞进了这个宏里。</li>
</ul>
</div></article><div class="pagination"><a href="/2015/08/09/php7-1/" class="pagination-prev">PREV</a><a href="/2015/08/08/variableAnalysie/" class="pagination-next">NEXT</a></div></div><aside class="sidebar"><h3>分类标签</h3><ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP-strstr-stristr-substr/">PHP strstr,stristr,substr</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP7-ZVAL/">PHP7 ZVAL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP内核-变量/">PHP内核 变量</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PHP内核-变量-作用域-生命周期/">PHP内核 变量 作用域 生命周期</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/array-change-key-case-array-chunk/">array_change_key_case,array_chunk</a></li></ul><h3>最新文章</h3><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/02/13/http-cache/">http 缓存</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/11/TSRM/">TSRM(线程安全)</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/03/网络函数-curl/">PHP内核学习--curl</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/12/22/协程和mysql异步/">生成器和mysql异步</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/27/array-change-key-case-array-chunk/">PHP内核学习 --- 数组函数（键值大小写转换和切分）</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/22/ngigx-pfm/">nginx和php的pfm</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/11/15/pcntl-thread/">pcntl_thread</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/10/26/php7-2/">php7_2</a></li></ul></aside></section></div><div class="extra"></div><footer class="footer"><div class="row-flex-row limit-width vh-center"><div class="copyright"><P>© 2016 <a href="/">阳关冰上</P></div><div class="power"><p><a href="http://pinggod.com/">Sean Sun</a>, 
<a href="https://hexo.io">Hexo</a>, 
<a href="https://github.com/">GitHub</a>, 
<a href="https://jekyllrb.com/">Jekyll</a></p></div></div></footer><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script><script>var _hmt = _hmt || [];(function() {var hm = document.createElement("script");hm.src = "//hm.baidu.com/hm.js?a36e15d9e2adec9a21fcdd9f686b1ed2";var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(hm, s);})();</script><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script></body></html>