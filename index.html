<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Web PHP</title><meta name="description"><meta name="generator" content="Web PHP"><meta name="author" content="阳关冰上"><meta name="keywords" content="sjaak van den berg, svdb, bitcoin, crypto, payment, integration, bitcoins, wordpress, betaling, webshop, front end, design, ontwerp, developer"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="160x160" href="/images/favicon-160x160.png"><link rel="icon" type="image/png" sizes="192x192" href="/images/favicon-192x192.png"><meta name="msapplication-TileColor" content="#121315"><meta name="msapplication-TileImage" content="/images/mstile-144x144.png"><link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="atom.xml"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><a href="/"><img src="/images/svdb.png" alt="Web PHP" title="Web PHP"></a><h1><a href="/" alt="Web PHP" title="Web PHP" itemprop="headline">Web PHP</a></h1><p itemprop="description"></p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/" alt="Home" title="Home" itemprop="url">Home</a></li><li itemprop="name"><a href="/articles" alt="Articles" title="Articles" itemprop="url">Articles</a></li><li itemprop="name"><a href="/about" alt="About" title="About" itemprop="url">About</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><h4 class="page-title">Recent Articles</h4><a href="/2016/03/06/about-nginx-module/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">初识nginx模块</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2016-03-06T15:14:36.000Z"> Sunday, March 6th 2016 at 23:14</time>, 3 min read</span><p itemprop="text" class="post-excerpt">nginx的配置结构nginx的核心是配置也就是nginx.conf的文件，nginx的配置大致可以分为如下几类：events，http，server，location等几类配置块，而且http中可以嵌套server，location；除此之外，具体的配置内容会涉及内存、磁盘分配，mime类型，虚拟主机和请求分发等内容，就不再详细列举啦，可以阅读一下《Nginx模块开发与架构解析》的第二章内容。实例：
1 &amp;#10;#user  nob</p></article></a><a href="/2016/02/28/about-redis/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">初识redis</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2016-02-28T00:17:40.000Z"> Sunday, February 28th 2016 at 8:17</time>, 2 min read</span><p itemprop="text" class="post-excerpt">事务与WATCH每次上线新功能都会经过开发完成，测试通过和运维发布这样一个过程，中间任何一个步骤出错这次发布就算失败，它们其实是一件事情：“成功发布上线”。
redis的事务大概也就是上面的这个意思，一些redis命令组合在一起一次执行，它们是一体的。redis的事务以multi这个特殊命令开始，以exec结束。
redis事务的原理：设置一个标识告诉redis不要立即执行命令而是将它们存入一个队列，在特定时刻依次全部执行。
第一步设置</p></article></a><a href="/2016/02/13/http-cache/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">http 缓存</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2016-02-13T07:36:40.000Z"> Saturday, February 13th 2016 at 15:36</time>, 1 min read</span><p itemprop="text" class="post-excerpt">HTTP协议缓存的目标是去除许多情况下对于发送请求的需求和去除许多情况下发送完整请求的需求。以不发送请求或减少请求传输的数据量来优化整个HTTP架构，此目标的实现可以产生如下好处：

减少网络传输的冗余信息量
缓解网络瓶颈的问题
降低对原始服务器的请求量
减少了传送距离，降低了因为距离而产生的时延

缓存基本处理过程包括七个步骤。
1.接收 – 缓存从网络中读取抵达的请求报文2.解析 – 缓存对报文进行解析，提取出URL和各种首部3.查</p></article></a><a href="/2016/02/11/TSRM/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">TSRM(线程安全)</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2016-02-11T09:39:12.000Z"> Thursday, February 11th 2016 at 17:39</time>, 2 min read</span><p itemprop="text" class="post-excerpt">TRSM的宏在查看源码的时经常会看到一个函数的参数中有这样一个宏TSRMLS_CC,而TSRMLS_CC表示启用线程安全。单线程中不存在线程安全的问题，但在多线程中这却是个问题，一个扩展启动后可能会被多个独立的请求同时调用。先看一下启用线程安全的宏：
12345#define TSRMLS_D	void ***tsrm_ls#define TSRMLS_DC	, TSRMLS_D#define TSRMLS_C	tsrm_ls#defi</p></article></a><a href="/2016/01/03/网络函数-curl/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">PHP内核学习--curl</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2016-01-03T13:28:58.000Z"> Sunday, January 3rd 2016 at 21:28</time>, 2 min read</span><p itemprop="text" class="post-excerpt">curlcurl函数使我们经常用到的网络函数之一，通过这篇文章了解curl的内部原理和php的生命周期（cli）。
12345678910&amp;lt;?php$cn = curl_init();curl_setopt($cn,CURLOPT_URL,&quot;www.baidu.com&quot;);$res = curl_exec($cn);$info n= curl_getinfo($cn);print_r($res);print_r(&quot;========</p></article></a><a href="/2015/12/22/协程和mysql异步/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">生成器和mysql异步</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2015-12-21T23:26:45.000Z"> Tuesday, December 22nd 2015 at 7:26</time>, 2 min read</span><p itemprop="text" class="post-excerpt">yield 和 Generator生成器第一个问题：什么是生成器Generator？首先我们可以认为它是一个函数。紧接着第二个问题，这个函数和其它的函数有什么不同吗？不同点在于这个函数是可中断的，返回值是依次返回的，一般函数是一次返回。第三个问题：函数返回值依次返回有什么优点或者用途？ 我们应该都遇到过一次读取一个大文件，内存不够用的情况，函数返回值的依次返回，就不需要一次申请占用很多的内存空间，而且数据可以更快地得到处理而不要等数据全</p></article></a><a href="/2015/11/27/array-change-key-case-array-chunk/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">PHP内核学习 --- 数组函数（键值大小写转换和切分）</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2015-11-26T23:27:16.000Z"> Friday, November 27th 2015 at 7:27</time>, 2 min read</span><p itemprop="text" class="post-excerpt">1.PHP 数组元素键值大小写转换123456789101112131415161718192021222324252627282930	PHP_FUNCTION(array_change_key_case)&amp;#123;	array_init_size(return_value, zend_hash_num_elements(Z_ARRVAL_P(array))); //初始化返回值	zend_hash_internal_pointer</p></article></a><a href="/2015/11/22/ngigx-pfm/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">nginx和php的pfm</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2015-11-22T02:06:29.000Z"> Sunday, November 22nd 2015 at 10:06</time>, 1 min read</span><p itemprop="text" class="post-excerpt">nginx与pfmnginx与php的结合，就是静态网页由nginx来解析，而动态内容则交给php来处理。这里采用的nginx的FastCGI模块和PHP的php-fpm来共同工作。
1.nginx的nginx.conf在nginx的配置文件nginx.conf中，开启和修改一下配置项：
123456789101112# pass the PHP scritpts to FastCGI server listening on 127.0</p></article></a><a href="/2015/11/15/pcntl-thread/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">pcntl_thread</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2015-11-15T12:07:10.000Z"> Sunday, November 15th 2015 at 20:07</time>, 3 min read</span><p itemprop="text" class="post-excerpt">Uninx进程间通信(ipc)方式：消息队列、信号量和共享内存。在具体编码之前，php的编译时需要 –enable-pcntl –enable-sysvmsg
1.消息队列1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class m</p></article></a><a href="/2015/10/26/php7-2/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">php7_2</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2015-10-25T22:27:08.000Z"> Monday, October 26th 2015 at 6:27</time>, 3 min read</span><p itemprop="text" class="post-excerpt">【原文链接】（http://nikic.github.io/2015/06/19/Internal-value-representation-in-PHP-7-part-2.html ）本文的最开始部分，首先讨论变量值在PHP 5 和PHP 7内部实现上的明显变化。最主要的不同就是zvals不在会被独立分配和存储自身的引用计数。例如整数、浮点数这样的基本数据类型的值直接存储在其对应的zval中，而一些复杂的数据类型在zval存储指向另一</p></article></a><a href="/2015/10/25/有关缓存/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">有关缓存</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2015-10-25T07:37:46.000Z"> Sunday, October 25th 2015 at 15:37</time>, 1 min read</span><p itemprop="text" class="post-excerpt">在我们的web系统中，尤其是一些高并发的web系统，为了缩短响应时间来到达良好的用户体验，缓存都会无处不在。从DNS缓存、CDN、浏览器本地缓存、浏览器与http协议缓存、mysql的缓存、apache和nginx实现的缓存、语言层面的缓存如PHP的opcode缓存和redis等。
DNS缓存我们通过浏览器去访问网站时，要经过域名解析(DNS),这是为了更快地响应我们可以减少DNS的解析次数，主流的浏览器都支持DNS预取(DNS Pre</p></article></a><a href="/2015/10/16/js-原型-实例-原型链/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">js(原型-实例-原型链)</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2015-10-16T14:41:22.000Z"> Friday, October 16th 2015 at 22:41</time>, 1 min read</span><p itemprop="text" class="post-excerpt">javascript的原型对象在js中每一个函数都一个原型属性(prototype),它是一个指向另一个对象指针，这个对象可以让同一个函数的所有实例共享属性和方法，这个对象就是原型对象。
1234567891011function student&amp;#123;	&amp;#125;student.prototype.name =&quot;jack&quot;;student.prototype.class =&quot;高1(2)班&quot;;var stu1 = new stud</p></article></a><a href="/2015/10/16/数组函数-3/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">PHP内核学习 -- 数组函数 （获取首尾元素）</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2015-10-16T14:40:11.000Z"> Friday, October 16th 2015 at 22:40</time>, 3 min read</span><p itemprop="text" class="post-excerpt">PHP 获取数组头尾元素array_pop 和array_shift的函數原型如下,位置src/ext/standard/array.c
1234567PHP_FUNCTION(array_pop)&amp;#123;	_phpi_pop(INTERNAL_FUNCTION_PARAM_PASSTHRU,1);&amp;#125;PHP_FUNCTION(array_shift)&amp;#123;	_phpi_php(INTERNAL_FUNCTION_PA</p></article></a><a href="/2015/10/06/数组函数-2/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">PHP内核学习 --- 数组函数（合并和替换）</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2015-10-06T15:09:59.000Z"> Tuesday, October 6th 2015 at 23:09</time>, 4 min read</span><p itemprop="text" class="post-excerpt">PHP 数组合并和替换函数array_merge,array_merge_recursice,array_replace,array_replace_recursice的源代码如下：
1234567891011121314151617181920PHP_FUNCTION(array_merge)&amp;#123;php_array_merge_or_replace_wrapper(INTERNAL_FUNCTION_PARAM_PASSTHR</p></article></a><a href="/2015/10/06/数组函数-1/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">PHP内核学习 --- 数组函数 （值排序和键排序）</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2015-10-06T07:34:23.000Z"> Tuesday, October 6th 2015 at 15:34</time>, 2 min read</span><p itemprop="text" class="post-excerpt">PHP 数组排序PHP中数组arsort的源代码：src/ext/standard/array.c
12345678910111213141516PHP_FUNCTION(arsort)&amp;#123;	zval *array;	long sort_type = PHP_SORT_REGULAR;		if(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,&quot;a|l&quot;,$array,&amp;amp;so</p></article></a><a href="/2015/10/06/字符串函数-1/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">PHP内核学习 --- 字符串函数 strstr,stristr,strpos,substr</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2015-10-06T03:26:15.000Z"> Tuesday, October 6th 2015 at 11:26</time>, 2 min read</span><p itemprop="text" class="post-excerpt">PHP 字符串函数（strstr,stristr,strpos,substr）1. strstr,stristr,strpos,strstr - 查找字符串的首次出现，stristr功能一样但区分大小写；
12string str(string $haystack,mixed $needle,bool $before_needle = false)
还有就是如果想仅仅确定needle是否存在于haystack中，更好地选择是strpos</p></article></a><a href="/2015/08/25/ext-struct/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">PHP 内核学习 --- 扩展结构</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2015-08-24T22:43:57.000Z"> Tuesday, August 25th 2015 at 6:43</time>, 2 min read</span><p itemprop="text" class="post-excerpt">PHP的扩展结构通过php下源码目录下的ext_skel 工具创建一个自己的扩展 “./configure –extname=wwbext”, 下面来了解一下一个扩展的框架结构：
一个扩展通常有6部分组成： 1.引入头文件 2.声明导出函数 3.声明Zend函数块 4.声明Zend模块 5.实现get_module()函数 6.实现导出函数
1.头文件在php扩展中，必须要引入一个php.h的头文件（main目录下）。它包含扩展所需要的</p></article></a><a href="/2015/08/11/hashtable/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">PHP内核学习 -- new hashtable in php 7</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2015-08-10T22:21:38.000Z"> Tuesday, August 11th 2015 at 6:21</time>, 2 min read</span><p itemprop="text" class="post-excerpt">PHP7 HashTable【原文链接】（http://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html ）本文将概述hashtable在php7的实现，和为什么新的hashtable会更加高效。
本质上讲，PHP的数组就是一个有序的词典，一个有序的键/值对列表，而这种key/value的映射关系是通过hashtable来实现的。
hashtable的概念</p></article></a><a href="/2015/08/09/php7-1/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">php7_1</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2015-08-09T13:03:49.000Z"> Sunday, August 9th 2015 at 21:03</time>, 8 min read</span><p itemprop="text" class="post-excerpt">PHP7 变量的内核实现 -Part 1【原文链接】（http://nikic.github.io/2015/05/05/Internal-value-representation-in-PHP-7-part-1.html ）我的上一篇文章描述了在PHP7中hashtable实现的改进。接下来我们来看一下PHP中变量新的实现形式。因为这部分内容涉及较多的内容，所以它被分成两部分：第一部分来描述PHP5和PHP7在zval（Zend va</p></article></a><a href="/2015/08/08/varlifttime/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">PHP 内核学习 -- 变量的作用域和生命周期</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2015-08-08T08:44:32.000Z"> Saturday, August 8th 2015 at 16:44</time>, 1 min read</span><p itemprop="text" class="post-excerpt">作用域 生命周期变量的作用域本质是一块代码区域，在这个区域内可以访问某个具体的变量，超出这个区域后，变量就无法被访问到。
全局变量和局部变量全局变量是在整个程序中任何地方随意调用的变量， 在PHP中，除了声明在函数体内的普通变量均为全局变量，在函数体内则可以通过global语句来声明。 相对于全局变量，局部变量的作用域是程序中的部分代码（如函数中），而不是程序的全部。
1234function scope()&amp;#123;	$liftcy</p></article></a><a href="/2015/08/08/variableAnalysie/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">PHP 内核学习 -- 变量的结构和类型</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2015-08-07T22:36:05.000Z"> Saturday, August 8th 2015 at 6:36</time>, 1 min read</span><p itemprop="text" class="post-excerpt">弱变量  ZVALPHP是解释性语言，同时也是拥有弱变量类型的语言.
1.变量的存储结构PHP的变量存储结构ZVAL(Zend/zend.h)如下：
12345678   struct _zval_struct&amp;#123;	/*变量信息*/	zvalue_value value; /*存储变量的值*/	zend_uint refcount__gc; /*引用次数*/	zend_uchar type     /*变量的类型*/	zend_</p></article></a><a href="/2015/08/03/hello-world/" class="article"><article itemscope itemprop="blogPost" itemtype="https://schema.org/BlogPosting" class="item"><h2 itemprop="headline">Hello World</h2><span class="post-meta">Published on<time itemprop="datePublished" datetime="2015-08-03T15:13:03.000Z"> Monday, August 3rd 2015 at 23:13</time>, 1 min read</span><p itemprop="text" class="post-excerpt">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.
Quick StartCreate a new p</p></article></a><footer itemscope itemtype="https://schema.org/WPFooter"><section class="pubkey">13DB CAA1 2633 81A7</section><section class="copyright"><a href="http://opensource.org/licenses/MIT">MIT License</a>&middot; Published with<a href="https://hexo.io/">Hexo</a></section></footer></main></body></html>