<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://www.flydream.org/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">John Doe</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/PHP内核-变量/" style="font-size: 10px;">PHP内核 变量</a> <a href="/tags/PHP内核-变量-作用域-生命周期/" style="font-size: 10px;">PHP内核 变量 作用域 生命周期</a> <a href="/tags/php7-hashtable/" style="font-size: 10px;">php7 hashtable</a> <a href="/tags/php扩展结构/" style="font-size: 10px;">php扩展结构</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">John Doe</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="null" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">John Doe</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-ext-struct" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/25/ext-struct/" class="article-date">
  	<time datetime="2015-08-24T22:43:57.000Z" itemprop="datePublished">2015-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/25/ext-struct/">PHP 内核学习 --- 扩展结构</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="PHP的扩展结构">PHP的扩展结构</h3><p>通过php下源码目录下的ext_skel 工具创建一个自己的扩展 “./configure –extname=wwbext”, 下面来了解一下一个扩展的框架结构：</p>
<p>一个扩展通常有6部分组成：<br> 1.引入头文件<br> 2.声明导出函数<br> 3.声明Zend函数块<br> 4.声明Zend模块<br> 5.实现get_module()函数<br> 6.实现导出函数</p>
<h4 id="1-头文件">1.头文件</h4><p>在php扩展中，必须要引入一个php.h的头文件（main目录下）。它包含扩展所需要的宏和API定义。</p>
<h4 id="2-导出函数声明">2.导出函数声明</h4><p>通过声明和实现导出函数，php脚本才能访问到我们所编写的扩展中的函数和类。<br>导出函数的声明形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zif_wwbext</span><span class="params">(</span><br><span class="line">	<span class="keyword">int</span> ht,</span><br><span class="line">	zval *return_value,</span><br><span class="line">	zval *this_ptr,</span><br><span class="line">	<span class="keyword">int</span> return_value_used,</span><br><span class="line">	zend_executor_globals *executor_globals</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中导出函数5个参数的作用：<br>ht：保存扩展函数参数的个数，通过ZEND_NUM_ARGS()宏访问<br>return_value:保存扩展函数的返回值<br>this_ptr:获得扩展函数所属的对象<br>return_value_used:标识函数的返回值是否为脚本所使用，1：是 ，0：否<br>executor_globals：指向Zend引擎的全局设置,通过TSRMLS_FETCH()引用这个值</p>
<h4 id="3-Zend函数块">3.Zend函数块</h4><p>虽然声明的导出函数，但是Zend引擎不会自动引入导出函数，这个时候我们需要zend_function_entry结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _zend_function_entry&#123;</span><br><span class="line">	<span class="keyword">char</span> *fname;</span><br><span class="line">	<span class="keyword">void</span> (*handler) (INTERNAL_FUNCTION_PARAMETERS);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> * func_arg_types;</span><br><span class="line">&#125;zend_function_entry;</span><br></pre></td></tr></table></figure>
<p>成员变量的含义：<br>fname:PHP脚本里调用的函数名<br>handler：C函数句柄，在这里就是导出函数的句柄<br>func_arg_types:一个参数是否强制按引用方式传递，一般为NULL<br>Zend引擎通过zend_function_entry结构数组把导出函数引入内部</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> zend_function_entry wwbext_functions[]=&#123;</span><br><span class="line">	PHP_FE(confirm_wwbext_complied,<span class="literal">NULL</span>)</span><br><span class="line">	PHP_FE_END</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>导入大致过程：循环zend_function_entry数组，依次将函数载入内核函数表</p>
<h4 id="4-声明Zend模块">4.声明Zend模块</h4><p>PHP的扩展信息都保存在zend_module_entry结构中，这个结构包含zend引擎需要知道的模块信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tpyedef <span class="keyword">struct</span> _zend_module_entry zend_module_entry;</span><br><span class="line"><span class="keyword">struct</span> _zend_module_entry&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> size;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> zend_api;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> zend_api;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> zts;</span><br><span class="line">	<span class="keyword">char</span> *name;</span><br><span class="line">	zend_function_entry *functions;</span><br><span class="line">	<span class="keyword">int</span> (*module_startup_func)(INT_FUNC_ARGS);</span><br><span class="line">	<span class="keyword">int</span> (*module_shutdown_func) (SHUTDOWM_FUNC_ARGS);</span><br><span class="line">	<span class="keyword">int</span> (*request_startup_func) (INT_FUNC_ARGS);</span><br><span class="line">	<span class="keyword">int</span> (*request_shutdown_func) (SHUTDOWN_FUNC_AGGS);</span><br><span class="line">	<span class="keyword">void</span> (*info_func) (ZEND_MODULE_INFO_FUNC_ARGS);</span><br><span class="line">	<span class="keyword">char</span> *version;</span><br><span class="line">	.............</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前四个成员通过STANDARD_MOUDLE_HEADER宏来填充；name:模块名； functions:第三部分的Zend的函数块指针；module_startup_func:模块初始化函数，可以通过宏ZEND_MINIT来启动；module_end_func:模块结束函数，对应的宏ZEND_MSHUTDOWN;request_startup_func:请求启动函数，宏ZEND_RMINIT；request_end_func:请求关闭函数，对应的宏ZEND_RSHUTDOWN，最后的versiion代表版本信息。<br>具体到我们的新扩展wwbext，结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">zend_moudle_entry wwbext_module_entry = &#123;</span><br><span class="line">	STANDARD_MOUDLE_HEADER,</span><br><span class="line">	<span class="string">"wwbext"</span>,</span><br><span class="line">	wwbext_functions,</span><br><span class="line">	PHP_MINIT(wwbext),</span><br><span class="line">	PHP_MSHUTDOWN(wwbext),</span><br><span class="line">	PHP_RINIT(wwext),</span><br><span class="line">	PHP_RSHUTDOWN(wwbext)</span><br><span class="line">	PHP_WWBEXT_VERSION,</span><br><span class="line">	STANDARD_MOUDLE_PROPERTIES</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-get_module()函数">5.get_module()函数</h4><p>当wwbext这个扩展被动态加载时回去调用get_module函数，实现过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> COMPILE_DL_WWBEXT</span></span><br><span class="line">ZEND_GET_MODULE(wwbext)</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>ZEND_GET_MODULE宏的张开如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> ZEND_GET_MOUDLE(name) \</span><br><span class="line">	ZEND_DLEXPORT zend_module_entry *get_module(void)&#123;\</span><br><span class="line">		return &amp;name##_module_entry;\</span><br><span class="line">	&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过get_module函数的zend模块指针就是第四部分的模块指针，所以PHP内核和扩展是通过get_module来通信的。</p>
<h4 id="6-导出函数">6.导出函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PHP_FUNCTION(confirm_wwbext_compiledd)&#123;</span><br><span class="line">	<span class="keyword">char</span> *arg = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">size_t</span> arg_len,len;</span><br><span class="line">	zend_string *<span class="built_in">string</span>;</span><br><span class="line">	<span class="keyword">if</span>(zend_parse_parameters(ZEND_NUM_ARGS(),<span class="string">"s"</span>,$arg,$arg_len) == FAILURE)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	strg = strpprintf(<span class="number">0</span>, <span class="string">"Congratulations! You have successfully modified ext/%.78s/config.m4. Module %.78s is now compiled into PHP."</span>, <span class="string">"wwbext"</span>, arg);</span><br><span class="line">RETURN_STR(strg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此扩展的最后一步实现导函数，通过总结发现PHP内核和扩展通信是通过get_moduleh获取模块，而模块又是通过导出函数获取扩展内的自定义函数放入zend_function_entry数组，来完成我们的扩展函数可以在脚本中调用。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php扩展结构/">php扩展结构</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-hashtable" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/11/hashtable/" class="article-date">
  	<time datetime="2015-08-10T22:21:38.000Z" itemprop="datePublished">2015-08-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/11/hashtable/">PHP内核学习 -- new hashtable in php 7</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="PHP7_HashTable"><strong>PHP7</strong> <strong>HashTable</strong></h3><p>本文将概述hashtable在php7的实现，和为什么新的hashtable会更加高效。</p>
<p>本质上讲，PHP的数组就是一个有序的词典，一个有序的键/值对列表，而这种key/value的映射关系是通过hashtable来实现的。</p>
<p>hashtable的概念是简单地来讲：字符串键值通过哈希函数得到一个数字，而这个数字是一个常规数组的下标。但是两个不同的键值可能经过哈希函数后得到两个相同的值，所以hashtable的实现还要解决哈希冲突。</p>
<p>哈希冲突的基本解决办法有两种：一种是开放地址，另一种是链式法；PHP中使用了第二种，下面直接描述PHP中的hashtable是如何实现的，新一代PHP引擎的hashtable有什么不同，为什么更高效？</p>
<h4 id="hashtable在PHP中5的实现">hashtable在PHP中5的实现</h4><p>下图是php5中hashtable实现的简述：<br><img src="http://chuantu.biz/t2/11/1439250546x-1566638931.png" alt="Hashtable png"></p>
<p>如上图，a,b,c这些键值所对应的值存在“bucket”结构中，每一个bucket都是独立分配空间的，而buckets组成互相之间独立的链表来解决哈希冲突。<br>另外除此之外，还有一个链表来保存元素的顺序（如：数组中的元素顺序是它的插入顺序），数组键值“a”,“b”，“c”，它对应的链表就应该是下面这个样子：<br><img src="http://chuantu.biz/t2/11/1439332151x-954497701.png" alt="Hashtable2 png"><br>这中hashtable实现在内存使用和执行低效的原因有以下几个原因：</p>
<ol>
<li>bucket 要独立分配。每次分配都要额外占用内存。同时独立分配就意味着bucket的地址相对分散，影响缓存效率。</li>
<li>zvals 也要单独分配而且 每一个bucket要保存同一个zval的指针。<h4 id="zval在PHP7中的实现">zval在PHP7中的实现</h4>在介绍新的hahstable之前，先来看一下新的zval结构：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">struct</span> _zval_struct &#123;    </span><br><span class="line">	zend_value value;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			ZEND_ENDIAN_LOHI_4(</span><br><span class="line">				zend_uchar type,</span><br><span class="line">				zend_uchar type_flags,</span><br><span class="line">				zend_uchar const_flags,</span><br><span class="line">				zend_uchar reserved)</span><br><span class="line">			&#125; v;</span><br><span class="line">		<span class="keyword">uint32_t</span> type_info;</span><br><span class="line">	&#125; u1;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">uint32_t</span> var_flags;</span><br><span class="line">		<span class="keyword">uint32_t</span> next;       <span class="comment">/* hash collision chain */</span></span><br><span class="line">		<span class="keyword">uint32_t</span> cache_slot; <span class="comment">/* literal cache slot */</span></span><br><span class="line">		<span class="keyword">uint32_t</span> lineno;     <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line">	&#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个zval结构有三部分组成，第一部分zend_value 负责存储实际的变量值；第二部分的type_info 代表变量的类型，从而决定第一部分的实际存储的值；第三部分不得经常使用到。在特殊的上下文下 存储一些特别的信息，比如：抽象语法树用它来存储行号，VM constants 用它来存储缓存索引，以及hashtable中存储哈希碰撞是之下链表的下一个元素。</p>
<p>新旧zval之间的明显区别就是新的zval实现中不再有引用字段。原因就是zvals不再独立申请分配。而是嵌入到了存储它的结构中，比如hashtable。</p>
<p>虽然    zval自身不再包含引用字段，但是像string，array，object和resouce等类型的值依然在使用引用字段。这样做的优势：<br>   1.Zvals storing simple values (like booleans, integers or floats) no longer require any allocations. So this saves the allocation header overhead and improves performance by avoiding unnecessary allocs and frees and improving cache locality.</p>
<p>   2.Zvals storing simple values don’t need to store a refcount and GC root buffer.   </p>
<p>   3.We avoid double refcounting. E.g. previously objects both used the zval refcount and an additional object refcount, which was    necessary to support by-object passing semantics.</p>
<p>   4.As all complex values now embed a refcount, they can be shared independently of the zval mechanism. In particular it is now also possible to share strings. This is important to the hashtable implementation, as it no longer needs to copy non-interned string keys.</p>
<h4 id="hashtable_in_PHP7">hashtable in PHP7</h4><p>php中的哈希边有两部组成：HashTable和Bucket</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _Bucket&#123;</span><br><span class="line">	zend_ulong h;</span><br><span class="line">	zend_string *key;</span><br><span class="line">	zval  val;</span><br><span class="line">&#125; Bucket;</span><br></pre></td></tr></table></figure>
<p>Buckets是哈希表中重要的组成。在Buckets包含hash h，键值key和zval的值。同时zval嵌入到Bucket中，就和Bucket一起分配资源减少单独操作的开销。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _HashTable&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> nTableSize;  <span class="comment">//哈希表大小</span></span><br><span class="line">	<span class="keyword">uint32_t</span> nTableMask;</span><br><span class="line">	<span class="keyword">uint32_t</span> nNumUsed;</span><br><span class="line">	<span class="keyword">uint32_t</span> nNumOfElements;</span><br><span class="line">	zend_long nNextFreeElement;</span><br><span class="line">	Bucket    *arData;	</span><br><span class="line">	<span class="keyword">uint32_t</span>  *arHash;</span><br><span class="line">	<span class="keyword">dtor_func_t</span> pDestructor;</span><br><span class="line">	<span class="keyword">uint32_t</span> nInternalPointer;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span>&#123;</span><br><span class="line">			ZEND_ENDIAN_LOHI_3(</span><br><span class="line">				zend_uchar flags,</span><br><span class="line">				zend_uchar nApplyCount,</span><br><span class="line">				<span class="keyword">uint16_t</span> reserve)</span><br><span class="line">		&#125; v;</span><br><span class="line">		<span class="keyword">uint32_t</span> flags;</span><br><span class="line">	&#125; u;</span><br><span class="line">&#125; HashTable;</span><br></pre></td></tr></table></figure>
<p>arData数组中直接存储Bucket内容，而不是每个Bucket的指针，这样减少了独立分配每个Bucket和释放的开销。</p>
<h4 id="HashTbale中的元素顺序">HashTbale中的元素顺序</h4><p>数组arData的元素顺序是由写入顺序决定的，与key之无关。nNumUsed代表arData中已经分配的大小，nNumOfElements代表arData中实际元素的多少。两个字段看似代表的是同一个意思，那为什么还要设置两个变量？</p>
<pre><code>&lt;?php
    <span class="variable">$array</span> = [<span class="string">'foo'</span>=&gt;<span class="number">0</span>,<span class="string">'bar'</span>=&gt;<span class="number">1</span>,<span class="number">0</span>=&gt;<span class="number">2</span>,<span class="string">'xyz'</span>=&gt;<span class="number">3</span>,<span class="number">2</span>=&gt;<span class="number">4</span>];
    unset(<span class="variable">$array</span>[<span class="number">0</span>]);
    unset(<span class="variable">$array</span>[<span class="string">'xyz'</span>]);
?&gt;
</code></pre><p>此时的arData：nTableSize = 8 ；nNumOfElements = 3 ；nNumUsed = 5<br>[0]: key=”foo”, val=int(0)<br>[1]: key=”bar”, val=int(1)<br>“<a href="val=UNDEF">2</a>: val=UNDEF“<br>“<a href="val=UNDEF">3</a>: val=UNDEF“<br>[4]: h=2, val=int(4)<br>[5]: NOT INITIALIZED<br>[6]: NOT INITIALIZED<br>[7]: NOT INITIALIZED</p>
<p>那我们上面的数组遍历时，我们却到不到 下标为2和3的值，数组的遍历过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; ht-&gt;nUumhashbiaoUsed;++i)&#123;</span><br><span class="line">	Bucket *b = &amp;ht-&gt;arData[i];</span><br><span class="line">	<span class="keyword">if</span>(Z_ISUNDEF(b-&gt;val)) <span class="keyword">continue</span>;</span><br><span class="line">	<span class="comment">//处理Bucket</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php7-hashtable/">php7 hashtable</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-php7-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/09/php7-1/" class="article-date">
  	<time datetime="2015-08-09T13:03:49.000Z" itemprop="datePublished">2015-08-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/09/php7-1/">php7_1</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        
      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-varlifttime" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/08/varlifttime/" class="article-date">
  	<time datetime="2015-08-08T08:44:32.000Z" itemprop="datePublished">2015-08-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/08/varlifttime/">PHP 内核学习 -- 变量的作用域和生命周期</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="作用域_生命周期"><strong>作用域</strong> <strong>生命周期</strong></h3><p>变量的作用域本质是一块代码区域，在这个区域内可以访问某个具体的变量，超出这个区域后，变量就无法被访问到。</p>
<h4 id="全局变量和局部变量">全局变量和局部变量</h4><p>全局变量是在整个程序中任何地方随意调用的变量， 在PHP中，除了声明在函数体内的普通变量均为全局变量，在函数体内则可以通过global语句来声明。 相对于全局变量，局部变量的作用域是程序中的部分代码（如函数中），而不是程序的全部。</p>
<pre><code><span class="php"><span class="preprocessor">&lt;?php</span>
    <span class="function"><span class="keyword">function</span> <span class="title">scope</span><span class="params">()</span></span>{
        <span class="variable">$liftcycle</span> = <span class="string">"wang"</span>;
    }
<span class="preprocessor">?&gt;</span></span>
</code></pre><p>变量的生命周期和作用域有一定的联系，如函数中的局部变量$filecycle，它的生命开始func scope的执行，结束于函数执行完毕。</p>
<p>PHP变量的作用域是如何实现 ？全局变量和局部变量的的作用域实现有什么区别？</p>
<p>zend引擎有一个_zend_executor_globals结构，全局变量就保存在symbol_table这个全局符号表中；active_symbol_table中保存局部变量，这些局部变量可能是来自函数或者对象的属性等；而且每个独立的函数运行时都有自己的active_symbol_table,保证作用域独立。</p>
<p>下面来看一下，_zend_execute_data (zend/zend_complie.h)的结构：</p>
<pre><code><span class="comment"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">typedef</span> <span class="keyword">struct</span> _zend_execute_data &#123;    </span><br><span class="line">	<span class="keyword">struct</span> _zend_op *opline;</span><br><span class="line">	zend_function_state function_state;</span><br><span class="line">	zend_op_array *op_array;</span><br><span class="line">	zval *object;</span><br><span class="line">	HashTable *symbol_table;</span><br><span class="line">	<span class="keyword">struct</span> _zend_execute_data *prev_execute_data;</span><br><span class="line">	zval *old_error_reporting;</span><br><span class="line">	zend_bool nested;</span><br><span class="line">	zval **original_return_value;</span><br><span class="line">	zend_class_entry *current_scope;</span><br><span class="line">	zend_class_entry *current_called_scope;</span><br><span class="line">	zval *current_this;</span><br><span class="line">	<span class="keyword">struct</span> _zend_op *fast_ret; <span class="comment">/* used by FAST_CALL/FAST_RET (finally keyword) */</span></span><br><span class="line">	zval *delayed_exception;</span><br><span class="line">	call_slot *call_slots;</span><br><span class="line">	call_slot *call;</span><br><span class="line">&#125; zend_execute_data;</span><br></pre></td></tr></table></figure></span>
</code></pre><p>函数中的局部变量就存储在_zend_execute_data的symbol_table中，在执行当前函数的op_array时， 全局zend_executor_globals中的<em>active_symbol_table会指向当前_zend_execute_data中的</em>symbol_table。 因为每个函数调用开始时都会重新初始化EG(active_symbol_table)为NULL， 在这个函数的所有opcode的执行过程中这个全局变量会一直存在，并且所有的局部变量修改都是在它上面操作完成的，如前面的赋值操作等。 而此时，其他函数中的symbol_table会存放在栈中，将当前函数执行完并返回时，程序会将之前保存的zend_execute_data恢复， 从而其他函数中的变量也就不会被找到，局部变量的作用域就是以这种方式来实现的。 相关操作在 Zend/zend_vm_execute.h 文件中定义的execute函数中一目了然，如下所示代码：</p>
<pre><code><span class="comment"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zend_vm_enter:</span><br><span class="line"><span class="comment">/* Initialize execute_data */</span></span><br><span class="line">execute_data = (zend_execute_data *)zend_vm_stack_alloc(</span><br><span class="line">    <span class="keyword">sizeof</span>(zend_execute_data) +</span><br><span class="line">    <span class="keyword">sizeof</span>(zval**) * op_array-&gt;last_var *(EG(active_symbol_table) ? <span class="number">1</span> : <span class="number">2</span>) +</span><br><span class="line">    <span class="keyword">sizeof</span>(temp_variable) * op_array-&gt;T TSRMLS_CC);</span><br><span class="line"> </span><br><span class="line">EX(symbol_table) = EG(active_symbol_table);</span><br><span class="line">EX(prev_execute_data) = EG(current_execute_data);</span><br><span class="line">EG(current_execute_data) = execute_data;</span><br></pre></td></tr></table></figure></span>
</code></pre><p>EX宏的作用是获取结构体zend_execute_data的字段值。它的实现是:#define EX(element) execute_data-&gt;element</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PHP内核-变量-作用域-生命周期/">PHP内核 变量 作用域 生命周期</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-variableAnalysie" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/08/variableAnalysie/" class="article-date">
  	<time datetime="2015-08-07T22:36:05.000Z" itemprop="datePublished">2015-08-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/08/variableAnalysie/">PHP 内核学习 -- 变量的结构和类型</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="弱变量_ZVAL_HashTable"><strong>弱变量</strong>  <strong>ZVAL</strong>  <strong>HashTable</strong></h3><p>PHP是解释性语言，同时也是拥有弱变量类型的语言.</p>
<h4 id="1-变量的存储结构">1.变量的存储结构</h4><p>PHP的变量存储结构ZVAL(Zend/zend.h)如下：</p>
<pre><code>struct _zval_struct{
    /<span class="keyword">*</span>变量信息<span class="keyword">*</span>/
    zvalue_value value; /<span class="keyword">*</span>存储变量的值<span class="keyword">*</span>/
    zend_uint refcount__gc; /<span class="keyword">*</span>引用次数<span class="keyword">*</span>/
    zend_uchar type     /<span class="keyword">*</span>变量的类型<span class="keyword">*</span>/
    zend_uchar is_ref__gc;  /<span class="keyword">*</span>是否引用<span class="keyword">*</span>/
}zval;
</code></pre><p>其中zval中type的作用就是用来标示不同的类型，它的值可以为：IS_LONG,IS_DOUBLE,IS_STRING,IS_BOOL，IS_ARRAY,IS_OBJECT，IS_RESOURCE,IS_NULL    。</p>
<h4 id="2-变量的值">2.变量的值</h4><p>之前提到的zval中的成员变量value（zvalue_value)就是变量值实际存储的地方，zvalue_value 的结果如下：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">union</span> _zvalue_value{
    <span class="keyword">long</span> lval;
    <span class="keyword">double</span> dval;
    <span class="keyword">struct</span>{
        <span class="keyword">char</span> *val;
        <span class="keyword">int</span> len;
    } str;         <span class="comment">/*字符串*/</span>
    HashTable *ht;    <span class="comment">/*数组*/</span>
    zend_object_value obj;  <span class="comment">/*对象*/</span>
    zend_ast *ast;    <span class="comment">/*抽象语法树*/</span>
}zvalue_value;
</code></pre><p>由于一个变量只能是一种类型,所以变量实际存储的结构zvalue_value,采用联合体的结构，这样可以避免浪费大量内存。<br>zvalue_value 中各个成员负责存储不同的变量，整型和布尔值在存储在zvalue_value.lval；dval存储浮点数； str存储字符串；ht 负责存储数组； obj和ast分别存储对象和语法树。</p>
<h4 id="-array（数组）">.array（数组）</h4><p>数组在PHP是一种很强大的变量，因为PHP为数组提供了丰富的内置函数，同时还可以存储其它类型的变量。PHP数组的强大依赖于哈希表，一种高效的键值对存储结构。在PHP中，处处可见哈希表的存在，从变量的作用域到函数表(active_table)和对象等。</p>
<h4 id="Object（对象）">Object（对象）</h4><pre><code>typedef struct <span class="number">_</span>zend<span class="number">_</span><span class="keyword">object</span><span class="number">_</span><span class="keyword">value</span>{
    zend<span class="number">_</span><span class="keyword">object</span><span class="number">_</span>handle handle;  <span class="comment">//对象在对象池中的索引</span>
    zend<span class="number">_</span><span class="keyword">object</span><span class="number">_</span>handlers *handlers;
}
</code></pre><p>EG宏，一个全局结构体用于保存在运行时的数据。 PHP的对象只有在运行时才会被创建，其中就包括了用来保存所有被创建的对象的对象池EG(objects_store)，而handle域就是当前对象在对象池中所在的索引，handlers字段则是将对象进行操作时的处理函数保存起来。 这个结构体及对象相关的类的结构_zend_class_entry。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PHP内核-变量/">PHP内核 变量</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/03/hello-world/" class="article-date">
  	<time datetime="2015-08-03T15:13:03.000Z" itemprop="datePublished">2015-08-03</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/03/hello-world/">Hello World</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 John Doe
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>