<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Web PHP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Web PHP">
<meta property="og:url" content="http://www.flydream.org/index.html">
<meta property="og:site_name" content="Web PHP">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Web PHP">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Web PHP" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="null" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">阳关冰上</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="/#" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
					        
								<a class="rss" target="_blank" href="/#" title="rss">rss</a>
					        
								<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/PHP-strstr-stristr-substr/" style="font-size: 10px;">PHP strstr,stristr,substr</a> <a href="/tags/PHP7-ZVAL/" style="font-size: 10px;">PHP7 ZVAL</a> <a href="/tags/PHP内核-变量/" style="font-size: 10px;">PHP内核 变量</a> <a href="/tags/PHP内核-变量-作用域-生命周期/" style="font-size: 10px;">PHP内核 变量 作用域 生命周期</a> <a href="/tags/array-merge-array-merge-recursice-array-replace-recursice-array-replace/" style="font-size: 10px;">array_merge,array_merge_recursice,array_replace_recursice,array_replace</a> <a href="/tags/array-pop-array-shift/" style="font-size: 10px;">array_pop,array_shift</a> <a href="/tags/php7-hashtable/" style="font-size: 10px;">php7 hashtable</a> <a href="/tags/php7-string-array-object/" style="font-size: 10px;">php7 string array object</a> <a href="/tags/php扩展结构/" style="font-size: 10px;">php扩展结构</a> <a href="/tags/web-cache/" style="font-size: 10px;">web cache</a> <a href="/tags/原型-原型链-继承/" style="font-size: 10px;">原型 原型链 继承</a> <a href="/tags/数组值value-arsort-asort-数组key排序-krsort-ksort/" style="font-size: 10px;">数组值value:arsort asort;数组key排序:krsort ksort</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">奥巴马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">卡卡的美丽传说</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">本泽马的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">吉格斯的博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">习大大大不同</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">托蒂的博客</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">阳关冰上</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="null" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">阳关冰上</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="/#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="/#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="/#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="/#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-php7-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/26/php7-2/" class="article-date">
  	<time datetime="2015-10-25T22:27:08.000Z" itemprop="datePublished">2015-10-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/26/php7-2/">php7_2</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>【原文链接】（<a href="http://nikic.github.io/2015/06/19/Internal-value-representation-in-PHP-7-part-2.html）" target="_blank" rel="external">http://nikic.github.io/2015/06/19/Internal-value-representation-in-PHP-7-part-2.html）</a><br>本文的最开始部分，首先讨论变量值在PHP 5 和PHP 7内部实现上的明显变化。最主要的不同就是zvals不在会被独立分配和存储自身的引用计数。例如整数、浮点数这样的基本数据类型的值直接存储在其对应的zval中，而一些复杂的数据类型在zval存储指向另一个结构体的指针。</p>
<p>对于刚才提到的复杂数据类型，它们有一个共同的header，即zend_refcounted:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _zend_refcounted&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> refcount;</span><br><span class="line">	<span class="keyword">union</span>&#123;</span><br><span class="line">		<span class="keyword">struct</span>&#123;</span><br><span class="line">			ZEND_ENDIAN_LOHI_3(</span><br><span class="line">				zend_uchar type,</span><br><span class="line">				zend_uchar flags,</span><br><span class="line">				<span class="keyword">uint16_t</span>   gc_info)</span><br><span class="line">		&#125;v;</span><br><span class="line">		<span class="keyword">uint32_t</span> typeinfo;</span><br><span class="line">	&#125; u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>zend_refcounted中的成员变量有引用次数的refcount，变量类型的type、用于GC的gc_info和类型指定flags。</p>
<p>接下来要具体要谈及每一种复杂类型变量实现并且和它们在PHP 5中的实现方式作比较。其中引用类型，我们刚才已经介绍过。本文也不会提及resources类型，因为关于这部分不是很有趣。</p>
<h4 id="Strings">Strings</h4><p>PHP 7中通过zend_string来表现字符串，zend_string的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _zend_string&#123;</span><br><span class="line">	zend_refcouned gc;</span><br><span class="line">	zend_ulong     h;     <span class="comment">/* hash value */</span></span><br><span class="line">	<span class="keyword">size_t</span>         len;</span><br><span class="line">	<span class="keyword">char</span>           val[<span class="number">1</span>].</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了引用计数这个在前一段落提到的成员变量之外，zend_string还包含一个hash值h和一个表示字符串长度的len以及字符串值val（这里申明的是一个元素大小的字符数组，是不是觉得奇怪）。缓存hash值h是为了避免在hashtable中多次查找时重复计算。</p>
<p>假如你对“dirty C hacks”并不熟悉，那么成员变量val就会显得很奇怪。val是一个只有一个字符大小的数组，但是却用来存储一个完整地string类型值（大多数情况下，这个值都不值在一个字符）。其实这是运用了“struct hack”的技术：申明一个只含有一个元素的数组，当在创建一个zend_string时我们用它的val成员变量来存储一个更长的字符串。</p>
<p>这种新的string类型和常规的C strings相比是有一些优势的：首先，字符串长度直接嵌入其中。这就意味着字符串的长度不需要到处传递。其次，因为包含了zend_refcounted,所以可以在不使用zvals的情况下实现字符串的多处共享。尤其对共享hashtable键值尤其重要。</p>
<p>但是新的string类型也有缺点：虽然通过zend_string(str-&gt;val)可以轻易地取得c字符串，但是反之则不行，我们只能复制一份新值到新分配的zend_string中。当我们遍历处理字符串时就会造成不便（常量字符串由C源码生成）。</p>
<p>字符串的flags类型（它们存储在GC flags域中）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_STR_PERSISTENT  (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) <span class="comment">/* allocated using malloc */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_STR_INTERNED    (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) <span class="comment">/* interned string */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_STR_PERMANENT   (<span class="number">1</span>&lt;&lt;<span class="number">2</span>) <span class="comment">/* interned string surving request boundary */</span></span></span><br></pre></td></tr></table></figure>
<p>Persistent strings是通过操作系统分配内存而不是通过zend的内存管理器(ZMM)，也因为这样它的生命周期长于一次请求。<br>这之前的PHP 5中，我们要使用persistent string需要先将它复制到ZMM，现在通过指定flag就可以在zvals直接使用。</p>
<p>Interned strings在一次请求结束之前都不会被销毁，也就因为这样所以它不需要引用计数。这种类型的字符串是不可以重复，所以每次创建一个新的之前engine都会先检查其内容是否已存在。在PHP源码中出现的字符串(string literals,变量和函数名等)通常都是内部字符串。Permanent strings在一次请求开始之前就被创建的interned strings。当一般interned strings在一次请求结束后都被销毁后，permanent strings依然存在。</p>
<p>假如opache是interned strings，它就会被存储在共享内存(SHM)中，可以在PHP的工作进程间共享。这种情形下，permanent strings的概念也就无所谓啦，因为它们永远不会被销毁。</p>
<h4 id="Arrays">Arrays</h4><p>因为在之前的文章已经提过新数组的实现，所以这里我就不在详细阐述它。也不再具体的去介绍最近的变化，因为基本原理还是一样的。</p>
<p>这里我仅仅说一个和新数组有关的概念，即Immutable arrays，这个概念在之前的hashtable文章中并没有涉及到。这样的数组相当于内部字符串，所以它们没有引用计数而且生命周期直到一次请求结束或者更长。</p>
<p>考虑到内存管理，immutable arrays只有当opcache开启时才可使用。来看一下它到底有什么不同，思考一下面的代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span> &lt; <span class="number">1000000</span>;++<span class="variable">$i</span>)&#123;</span><br><span class="line">	<span class="variable">$array</span>[]=[<span class="string">'foo'</span>];</span><br><span class="line">&#125;</span><br><span class="line">var_dump(memory_get_usage());</span><br></pre></td></tr></table></figure>
<p>开启opcache时内存占用32M，但是没有opcache内存占用390M，这是因为$array的每个元素都要从新复制一份。这里没有使用引用计数而是重新复制的原因是literal VM operands 通过这样来避免共享内存发生。我希望未来我们可以在不用opcache的情况下更好地处理这种情况。</p>
<h4 id="Objects_in_PHP_5">Objects in PHP 5</h4><p>在思考PHP 7的对象实现之前，我们先来了解一下它在PHP 5中是如何工作的以及它的一些低效的地方：zval自身被用来去存储zend_object_value:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _zend_object_value&#123;</span><br><span class="line">	zend_object_handle handle;</span><br><span class="line">	<span class="keyword">const</span> zend_object_handlers *handlers;</span><br><span class="line">&#125;zend_object_value;</span><br></pre></td></tr></table></figure>
<p>handle是对象的唯一标示，通过它来查找对象的数据。handles是一个VTable指针，它指向了对象中实现的方法。一般情况下，php中对象它们的handler table没有什么区别，但是php 扩展创建的对象它们对应handler table会有不同。这个不同类似于重载操作符。</p>
<p>handle是“object store”的数组索引，object store作为一个元素保存在数组中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _zend_object_store_bucket&#123;</span><br><span class="line">	zend_bool_destructor_called;    <span class="comment">//销毁时调用</span></span><br><span class="line">	zend_bool valid;                <span class="comment">//是否在被使用</span></span><br><span class="line">	zend_uchar apply_count;         <span class="comment">//对象被访问的次数</span></span><br><span class="line">	<span class="keyword">union</span> _store_bucket &#123;</span><br><span class="line">		<span class="keyword">struct</span> _store_object&#123;</span><br><span class="line">			<span class="keyword">void</span> * object;</span><br><span class="line">			zend_objects_store_dtort dtor;</span><br><span class="line">			<span class="keyword">zend_objects_free_object_storage_t</span> free_storage;</span><br><span class="line">			<span class="keyword">zend_objects_store_clone_t</span> clone;</span><br><span class="line">			<span class="keyword">const</span> zend_object_handlers * handlers;</span><br><span class="line">			zend_uint refcount;</span><br><span class="line">			gc_root_buffer *buffered;</span><br><span class="line">		&#125; obj;</span><br><span class="line">		<span class="keyword">struct</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> next;</span><br><span class="line">		&#125;free_list;</span><br><span class="line">	&#125;bucket;</span><br><span class="line">&#125;zend_object_store_bucket;</span><br></pre></td></tr></table></figure>
<p>这里有很多值得说的地方。前三个成员是元数据（它们的注释如上）。接下来的联合体用来区分这个bucket在哪被使用或者它只是bucket free list的一部分。对于这部内容，重点在结构体_store_object：</p>
<p>_store_object结构体中第一个成员变量object指向的是真正对象。它没有直接嵌入在zend_object_store_bucket是因为对应的大小不确定。在对象指针之后紧接着跟着三个handlers，它们负责destruction，freeing和cloning。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php7-string-array-object/">php7 string array object</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-有关缓存" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/25/有关缓存/" class="article-date">
  	<time datetime="2015-10-25T07:37:46.000Z" itemprop="datePublished">2015-10-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/25/有关缓存/">有关缓存</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在我们的web系统中，尤其是一些高并发的web系统，为了缩短响应时间来到达良好的用户体验，缓存都会无处不在。从DNS缓存、CDN、浏览器本地缓存、浏览器与http协议缓存、mysql的缓存、apache和nginx实现的缓存、语言层面的缓存如PHP的opcode缓存和redis等。</p>
<h4 id="DNS缓存">DNS缓存</h4><p>我们通过浏览器去访问网站时，要经过域名解析(DNS),这是为了更快地响应我们可以减少DNS的解析次数，主流的浏览器都支持DNS预取(DNS Prefetch),即将域名对应的ip存储在浏览器本地，当下次访问相同的网站时就不需要再次域名解析。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"x-dns-prefetch-control"</span> <span class="attribute">content</span>=<span class="value">"on"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>chrome查看本地DNS:chrome://net-internals/#dns</p>
<h4 id="CDN">CDN</h4><p>我们可以依据我们的常识来对理解CDN，去一个离我们近的地方去取东西往返的时间肯定相对是短的。通过把一些必要的数据存储在离用户最近的运营商服务器上，避免网络路由的跳转来达到快速响应。</p>
<h4 id="浏览器本地缓存">浏览器本地缓存</h4><p>在前端例如logo，公共的布局文件和js，在首次加载时就可以缓存在浏览器本地，不过这个需要告诉浏览器哪些需要缓存：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Cache-Control"</span> <span class="attribute">content</span>=<span class="value">"max-age=3600"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样1h内 浏览器不会在向服务器发送请求。另外还有Html5的Application Cache来实现移动端的离线浏览。</p>
<h4 id="浏览器和http交互">浏览器和http交互</h4><p>一旦浏览器端缓存过期，需要重新发送请求。第一请求后，服务器返回的信息多了Last—Modified，Exprires和ETag。Last-Modified:最近一次修改时间，Exprires:过期时间和ETag:服务器根据请求URL生成的标识。根据ETag找到对应的文件更新时间和Last-Modified比较，未变化则返回状态码304。</p>
<h4 id="PHP_opcode缓存">PHP opcode缓存</h4><p>现在php内置zendopcache ，编译时–enable-opcache，之后配置php.ini。<br>PHP 每次执行执行都要经过词法，语法分析，编译成opcode，最后由zend引擎执行。通过缓存opcode，跳过之前的分析和编译过程，直接执行来提高性能。</p>
<p>最后，这里只是简单罗列一些内容，还有一些内存级别的redis和服务器的缓存，有时间仔细研究后在记录下来。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/web-cache/">web cache</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-js-原型-实例-原型链" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/16/js-原型-实例-原型链/" class="article-date">
  	<time datetime="2015-10-16T14:41:22.000Z" itemprop="datePublished">2015-10-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/16/js-原型-实例-原型链/">js(原型-实例-原型链)</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="javascript的原型对象">javascript的原型对象</h4><p>在js中每一个函数都一个原型属性(prototype),它是一个指向另一个对象指针，这个对象可以让同一个函数的所有实例共享属性和方法，这个对象就是原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">student</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">student.prototype.name =<span class="string">"jack"</span>;</span><br><span class="line">student.prototype.class =<span class="string">"高1(2)班"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu1 = <span class="keyword">new</span> student();</span><br><span class="line">	<span class="built_in">console</span>.log(stu1.name); <span class="comment">//jack  </span></span><br><span class="line"><span class="keyword">var</span> stu2 = <span class="keyword">new</span> student();</span><br><span class="line">	<span class="built_in">console</span>.log(stu2.name); <span class="comment">//jack</span></span><br></pre></td></tr></table></figure>
<p>实例对象stu1和stu2 拥有同样的属性name和class，即共享了原型对象（student Prototype）的属性。</p>
<p>js中只要创建了一个函数，js就会为这个函数添加prototype属性，这个prototype属性指向函数的原型对象。而且原型对象也有一个construcor属性，指向它对应的函数。我们如果想向原型对象添加属性和方法，只能通过函数的prototype属性访问到原型对象，下面是构造函数，实例，原型对象之间的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">student.prototype ---------&gt; student Prototype</span><br><span class="line">stu1.[[Prototype]]---------&gt; student Prototype</span><br><span class="line">stu2.[[Prototype]]---------&gt; student Prototype</span><br><span class="line"></span><br><span class="line">student Prototype.constructor-------&gt;student</span><br></pre></td></tr></table></figure>
<p>构造函数stduent以及两个实例stu1和stu2 ，它们共同指向原型对象student Prototype，而实例和构造函数之间没有直接关联。同时还有原型对象的constructor指向构造函数。</p>
<h4 id="继承">继承</h4><p>js中的继承是通过原型链来实现继承。这里我就直接使用《javascript 高级程序程序设计<br>》中的例子,实现原型链的基本模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype = getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue());  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>上述来两个构造函数SuperType和SubType都一个属性和方法，实例instance可以调用SuperType的方法getSuperValue，即实现了继承；实现的方式是SubType的prototype属性值，不再指向js为它创建的默认原型对象而是指向了SuperType的实例，但是SuperType的实例是指向它自己的默认原型对象的，这样instance也就可以访问SuperType的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SubType.prototype---&gt;SubType Prototype</span><br><span class="line">instance.[[Prototype]]---&gt; SubType Prototype.[[Prototype]]---&gt;SuperType Prototype</span><br><span class="line">SuperType Prototype.constructor---&gt;SuperType</span><br><span class="line">SuperType.prototype ---&gt; SuperType Prototye</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原型-原型链-继承/">原型 原型链 继承</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-数组函数-3" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/16/数组函数-3/" class="article-date">
  	<time datetime="2015-10-16T14:40:11.000Z" itemprop="datePublished">2015-10-16</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/16/数组函数-3/">PHP内核学习 -- 数组函数 （获取首尾元素）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="PHP_获取数组头尾元素">PHP 获取数组头尾元素</h4><p>array_pop 和array_shift的函數原型如下,位置src/ext/standard/array.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PHP_FUNCTION(array_pop)&#123;</span><br><span class="line">	_phpi_pop(INTERNAL_FUNCTION_PARAM_PASSTHRU,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">PHP_FUNCTION(array_shift)&#123;</span><br><span class="line">	_phpi_php(INTERNAL_FUNCTION_PARAM_PASSTHRU,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的原型可以看出，获取数组头元素的array_shift 和获取尾元素的函数array_pop在源码中都是通过_phpi_php来处理的，_phpi_php的代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _phpi_pop(INTERNAL_FUNCTION_PARAMETES,<span class="keyword">int</span> off_the_end)</span><br><span class="line">&#123;</span><br><span class="line">	zval *<span class="built_in">stack</span>;   <span class="comment">/* Input stack */</span></span><br><span class="line">	     **val;    <span class="comment">/* Value to be popped */</span></span><br><span class="line">	<span class="keyword">char</span> *key = <span class="literal">NULL</span>;</span><br><span class="line">	uint key_len = <span class="number">0</span>;</span><br><span class="line">	ulong index;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"a"</span>,&amp;<span class="built_in">stack</span>) == FAILURE)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;     </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(zend_hash_num_elements(Z_ARRVAL_P(<span class="built_in">stack</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Get the first or last value and copy it into the return value */</span></span><br><span class="line">	<span class="keyword">if</span>(off_the_end)&#123;</span><br><span class="line">		<span class="preprocessor">###HashTable（ht）中成员变量ht-&gt;pInternalPointer 指向链表的末尾即数据的最后一个元素</span></span><br><span class="line">		zend_hash_internal_pointer_end(Z_ARRVAL_P(<span class="built_in">stack</span>));</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="preprocessor">###HashTable（ht）中成员变量ht-&gt;pInternalPointer 指向链表的头即数组的第一个元素</span></span><br><span class="line">		zend_hash_internal_pointer_reset(Z_ARRVAL_P(<span class="built_in">stack</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="preprocessor">###获取目标元素，并存储在val中</span></span><br><span class="line">	zend_hash_get_current_data(Z_ARRVAL_P(<span class="built_in">stack</span>),(<span class="keyword">void</span> **)&amp;val);</span><br><span class="line">	RETVAL_ZVAL_FAST(*val);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Delete the first or last value */</span></span><br><span class="line">	zend_hash_get_current_key_ex(Z_ARRVAL_P(<span class="built_in">stack</span>), &amp;key, &amp;key_len, &amp;index, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="function">key &amp;&amp; <span class="title">Z_ARRVAL_P</span><span class="params">(<span class="built_in">stack</span>)</span> </span>== &amp;EG(symbol_table)) &#123;</span><br><span class="line">		zend_delete_global_variable(key, key_len - <span class="number">1</span> TSRMLS_CC);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="preprocessor">###删除链表中元素 重点就在此重置hasttable中的链表</span></span><br><span class="line">	    zend_hash_del_key_or_index(Z_ARRVAL_P(<span class="built_in">stack</span>), key, key_len, index, (key) ? HASH_DEL_KEY : HASH_DEL_INDEX);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If we did a shift... re-index like it did before */</span></span><br><span class="line">	<span class="keyword">if</span> (!off_the_end) &#123;</span><br><span class="line">		zend_hash_reindex(Z_ARRVAL_P(<span class="built_in">stack</span>), <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="function">key_len &amp;&amp; <span class="title">Z_ARRVAL_P</span><span class="params">(<span class="built_in">stack</span>)</span>-&gt;nNextFreeElement &gt; 0 &amp;&amp; index &gt;</span>= Z_ARRVAL_P(<span class="built_in">stack</span>)-&gt;nNextFreeElement - <span class="number">1</span>) &#123;</span><br><span class="line">		Z_ARRVAL_P(<span class="built_in">stack</span>)-&gt;nNextFreeElement = Z_ARRVAL_P(<span class="built_in">stack</span>)-&gt;nNextFreeElement - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">       <span class="preprocessor">### ht-&gt;pInternalPointer = ht-&gt;pListHead</span></span><br><span class="line">	zend_hash_internal_pointer_reset(Z_ARRVAL_P(<span class="built_in">stack</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在获取目标元素后，将它复制一份新的，然后返回；但在这期间还有一步很重要的就是HashTable中链表重置（两种链表），zend_hash_del_key_or_index(src/zend/zend_hash.c)函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_hash_del_key_or_index</span><span class="params">(HashTable *ht, <span class="keyword">const</span> 	<span class="keyword">char</span> *arKey, uint nKeyLength, ulong h, <span class="keyword">int</span> flag)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	uint nIndex;</span><br><span class="line">	Bucket *p;</span><br><span class="line"></span><br><span class="line">	IS_CONSISTENT(ht);</span><br><span class="line">	<span class="preprocessor">### 针对string类型的键 计算hash值</span></span><br><span class="line">	<span class="keyword">if</span> (flag == HASH_DEL_KEY) &#123;</span><br><span class="line">		h = zend_inline_hash_func(arKey, nKeyLength);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="preprocessor">### 获取目标元素在arBuckets数组中的位置（arBuckets数组存放着数组中所有元素的实际存储位置）</span></span><br><span class="line">	nIndex = h &amp; ht-&gt;nTableMask;</span><br><span class="line">	</span><br><span class="line">	p = ht-&gt;arBuckets[nIndex];</span><br><span class="line">	<span class="preprocessor">### PHP中哈希冲突是通过拉链法解决的 所以此时的p指向一个由有相同hash值的元素组成的链表的</span></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((p-&gt;h == h) </span><br><span class="line">		 	&amp;&amp; (p-&gt;nKeyLength == nKeyLength)</span><br><span class="line">		 	&amp;&amp; ((p-&gt;nKeyLength == <span class="number">0</span>) <span class="comment">/* Numeric index (short circuits the memcmp() check) */</span></span><br><span class="line">			 || !<span class="built_in">memcmp</span>(p-&gt;arKey, arKey, nKeyLength))) &#123; <span class="comment">/*String index */</span></span><br><span class="line">		<span class="preprocessor">### 刚才说到了相同hash组成的链表，还有一个链表就是我们遍历数组使用到的，它维护者元素之间的相对顺序；</span></span><br><span class="line">		<span class="preprocessor">### i_zend_hash_bucket_delete 重置上述两种双向链表</span></span><br><span class="line">		i_zend_hash_bucket_delete(ht, p);</span><br><span class="line">		<span class="keyword">return</span> SUCCESS;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/array-pop-array-shift/">array_pop,array_shift</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-数组函数-2" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/06/数组函数-2/" class="article-date">
  	<time datetime="2015-10-06T15:09:59.000Z" itemprop="datePublished">2015-10-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/06/数组函数-2/">PHP内核学习 --- 数组函数（合并和替换）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="PHP_数组合并和替换">PHP 数组合并和替换</h4><p>函数array_merge,array_merge_recursice,array_replace,array_replace_recursice的源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PHP_FUNCTION(array_merge)</span><br><span class="line">&#123;</span><br><span class="line">php_array_merge_or_replace_wrapper(INTERNAL_FUNCTION_PARAM_PASSTHRU, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> 	</span><br><span class="line">PHP_FUNCTION(array_merge_recursive)</span><br><span class="line">&#123;</span><br><span class="line">php_array_merge_or_replace_wrapper(INTERNAL_FUNCTION_PARAM_PASSTHRU, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">  PHP_FUNCTION(array_replace)</span><br><span class="line">  &#123;</span><br><span class="line"> php_array_merge_or_replace_wrapper(INTERNAL_FUNCTION_PARAM_PASSTHRU, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  PHP_FUNCTION(array_replace_recursive)</span><br><span class="line">  &#123;</span><br><span class="line"> php_array_merge_or_replace_wrapper(INTERNAL_FUNCTION_PARAM_PASSTHRU, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从上述源代码中可以看出处理的核心在php_array_merge_or_replace_wrapper函数中，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">php_array_merge_or_replace_wrapper</span><span class="params">(INTERNAL_FUNCTION_PARAMETERS, <span class="keyword">int</span> recursive, <span class="keyword">int</span> replace)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	zval ***args = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> argc, i, init_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"+"</span>, &amp;args, &amp;argc) == FAILURE) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Z_TYPE_PP(args[i]) != IS_ARRAY) &#123;</span><br><span class="line">			php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_WARNING, <span class="string">"Argument #%d is not an array"</span>, i + <span class="number">1</span>);</span><br><span class="line">			efree(args);</span><br><span class="line">			RETURN_NULL();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> num = zend_hash_num_elements(Z_ARRVAL_PP(args[i]));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (num &gt; init_size) &#123;</span><br><span class="line">				init_size = num;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	array_init_size(return_value, init_size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!replace) &#123;</span><br><span class="line">			<span class="comment">//数组合并</span></span><br><span class="line">			php_array_merge(Z_ARRVAL_P(return_value), Z_ARRVAL_PP(args[i]), recursive TSRMLS_CC);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (recursive &amp;&amp; i &gt; <span class="number">0</span>) &#123; <span class="comment">/* First array will be copied directly instead */</span></span><br><span class="line">			php_array_replace_recursive(Z_ARRVAL_P(return_value), Z_ARRVAL_PP(args[i]) TSRMLS_CC);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		zend_hash_merge(Z_ARRVAL_P(return_value), Z_ARRVAL_PP(args[i]), (<span class="keyword">copy_ctor_func_t</span>) zval_add_ref, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(zval *), <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	efree(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是php_array_merge 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">PHPAPI <span class="keyword">int</span> <span class="title">php_array_merge</span><span class="params">(HashTable *dest, HashTable *src, <span class="keyword">int</span> recursive TSRMLS_DC)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span><br><span class="line"></span>&#123;</span><br><span class="line">zval **src_entry, **dest_entry;</span><br><span class="line"><span class="keyword">char</span> *string_key;</span><br><span class="line">uint string_key_len;</span><br><span class="line">ulong num_key;</span><br><span class="line">HashPosition pos;</span><br><span class="line">   <span class="comment">//重置hashtable src的成员变量pInternalPointer</span></span><br><span class="line">zend_hash_internal_pointer_reset_ex(src, &amp;pos);</span><br><span class="line"><span class="comment">//获取hash表中当前元素的地址：即其中某个Bucket的地址</span></span><br><span class="line"><span class="keyword">while</span> (zend_hash_get_current_data_ex(src, (<span class="keyword">void</span> **)&amp;src_entry, &amp;pos) == SUCCESS) &#123;</span><br><span class="line">	<span class="comment">/*获取对应数组中对应元素下标的类型，如果是字符串在返回HASH_KEY_IS_STRING并获取键值和其长度，</span><br><span class="line">	  或者是数字下标，返回HASH_KEY_IS_LONG和其值num_key*/</span></span><br><span class="line">	<span class="keyword">switch</span> (zend_hash_get_current_key_ex(src, &amp;string_key, &amp;string_key_len, &amp;num_key, <span class="number">0</span>, &amp;pos)) &#123;</span><br><span class="line">		<span class="keyword">case</span> HASH_KEY_IS_STRING:</span><br><span class="line">			<span class="keyword">if</span> (<span class="function">recursive &amp;&amp; <span class="title">zend_hash_find</span><span class="params">(dest, string_key, string_key_len, (<span class="keyword">void</span> **)</span>&amp;dest_entry) </span>== SUCCESS) &#123;</span><br><span class="line">				HashTable *thash = Z_TYPE_PP(dest_entry) == IS_ARRAY ? Z_ARRVAL_PP(dest_entry) : <span class="literal">NULL</span>;</span><br><span class="line">				zval *src_zval;</span><br><span class="line">				zval *tmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> ((thash &amp;&amp; thash-&gt;nApplyCount &gt; <span class="number">1</span>) || (*src_entry == *<span class="function">dest_entry &amp;&amp; <span class="title">Z_ISREF_PP</span><span class="params">(dest_entry)</span> &amp;&amp; <span class="params">(Z_REFCOUNT_PP(dest_entry)</span> % 2))) </span>&#123;</span><br><span class="line">					php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_WARNING, <span class="string">"recursion detected"</span>);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				SEPARATE_ZVAL(dest_entry);</span><br><span class="line">			</span><br><span class="line">				<span class="keyword">if</span> (Z_TYPE_PP(dest_entry) == IS_NULL) &#123;</span><br><span class="line">					convert_to_array_ex(dest_entry);</span><br><span class="line">					add_next_index_null(*dest_entry);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					convert_to_array_ex(dest_entry);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (Z_TYPE_PP(src_entry) == IS_OBJECT) &#123;</span><br><span class="line">					ALLOC_ZVAL(src_zval);</span><br><span class="line">					INIT_PZVAL_COPY(src_zval, *src_entry);</span><br><span class="line">					zval_copy_ctor(src_zval);</span><br><span class="line">					convert_to_array(src_zval);</span><br><span class="line">					tmp = src_zval;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					src_zval = *src_entry;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//如果是数组且递归合并 需要递归执行php_array_merge</span></span><br><span class="line">				<span class="keyword">if</span> (Z_TYPE_P(src_zval) == IS_ARRAY) &#123;</span><br><span class="line">					<span class="keyword">if</span> (thash) &#123;</span><br><span class="line">						thash-&gt;nApplyCount++;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (!php_array_merge(Z_ARRVAL_PP(dest_entry), Z_ARRVAL_P(src_zval), recursive TSRMLS_CC)) &#123;</span><br><span class="line">						<span class="keyword">if</span> (thash) &#123;</span><br><span class="line">							thash-&gt;nApplyCount--;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (thash) &#123;</span><br><span class="line">						thash-&gt;nApplyCount--;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				   <span class="comment">//不是数组类型，直接新增元素</span></span><br><span class="line">					Z_ADDREF_PP(src_entry);</span><br><span class="line">					zend_hash_next_index_insert(Z_ARRVAL_PP(dest_entry), &amp;src_zval, <span class="keyword">sizeof</span>(zval *), <span class="literal">NULL</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">					zval_ptr_dtor(&amp;tmp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//不执行递归后者没有发现存在相同元素 则直接更新</span></span><br><span class="line">				Z_ADDREF_PP(src_entry);</span><br><span class="line">				zend_hash_update(dest, string_key, string_key_len, src_entry, <span class="keyword">sizeof</span>(zval *), <span class="literal">NULL</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> HASH_KEY_IS_LONG:</span><br><span class="line">			<span class="comment">//如果是数字下标就不考虑 是否递归的问题，直接hashtable新写入一个元素（即Bucket）</span></span><br><span class="line">			Z_ADDREF_PP(src_entry);</span><br><span class="line">			zend_hash_next_index_insert(dest, src_entry, <span class="keyword">sizeof</span>(zval *), <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	zend_hash_move_forward_ex(src, &amp;pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次，替换功能实现，有两个函数完成: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">PHPAPI <span class="keyword">int</span> <span class="title">php_array_replace_recursive</span><span class="params">(HashTable *dest, HashTable *src TSRMLS_DC)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span><br><span class="line"></span>&#123;</span><br><span class="line">zval **src_entry, **dest_entry;</span><br><span class="line"><span class="keyword">char</span> *string_key;</span><br><span class="line">uint string_key_len;</span><br><span class="line">ulong num_key;</span><br><span class="line">HashPosition pos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (zend_hash_internal_pointer_reset_ex(src, &amp;pos);</span><br><span class="line">     zend_hash_get_current_data_ex(src, (<span class="keyword">void</span> **)&amp;src_entry, &amp;pos) == SUCCESS;</span><br><span class="line">     zend_hash_move_forward_ex(src, &amp;pos)) &#123;</span><br><span class="line">	<span class="keyword">switch</span> (zend_hash_get_current_key_ex(src, &amp;string_key, &amp;string_key_len, &amp;num_key, <span class="number">0</span>, &amp;pos)) &#123;</span><br><span class="line">		<span class="keyword">case</span> HASH_KEY_IS_STRING:</span><br><span class="line">			<span class="keyword">if</span> (Z_TYPE_PP(src_entry) != IS_ARRAY ||</span><br><span class="line">				zend_hash_find(dest, string_key, string_key_len, (<span class="keyword">void</span> **)&amp;dest_entry) == FAILURE ||</span><br><span class="line">				Z_TYPE_PP(dest_entry) != IS_ARRAY) &#123;</span><br><span class="line"></span><br><span class="line">				Z_ADDREF_PP(src_entry);</span><br><span class="line">				zend_hash_update(dest, string_key, string_key_len, src_entry, <span class="keyword">sizeof</span>(zval *), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> HASH_KEY_IS_LONG:</span><br><span class="line">			<span class="keyword">if</span> (Z_TYPE_PP(src_entry) != IS_ARRAY ||</span><br><span class="line">				zend_hash_index_find(dest, num_key, (<span class="keyword">void</span> **)&amp;dest_entry) == FAILURE ||</span><br><span class="line">				Z_TYPE_PP(dest_entry) != IS_ARRAY) &#123;</span><br><span class="line"></span><br><span class="line">				Z_ADDREF_PP(src_entry);</span><br><span class="line">				zend_hash_index_update(dest, num_key, src_entry, <span class="keyword">sizeof</span>(zval *), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      ..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我列出了这个函数的关键部分，待合并的元素是键值是数字还是字符串，不同的键值类型处理方式不同，键值：调用zend_hash_update,数字下标：zend_hash_index_update</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/array-merge-array-merge-recursice-array-replace-recursice-array-replace/">array_merge,array_merge_recursice,array_replace_recursice,array_replace</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-数组函数-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/06/数组函数-1/" class="article-date">
  	<time datetime="2015-10-06T07:34:23.000Z" itemprop="datePublished">2015-10-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/06/数组函数-1/">PHP内核学习 --- 数组函数 （值排序和键排序）</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="PHP_数组排序">PHP 数组排序</h4><p>PHP中数组arsort的源代码：src/ext/standard/array.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(arsort)&#123;</span><br><span class="line">	zval *<span class="built_in">array</span>;</span><br><span class="line">	<span class="keyword">long</span> sort_type = PHP_SORT_REGULAR;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,<span class="string">"a|l"</span>,$<span class="built_in">array</span>,&amp;sort_type) == FAILURE)&#123;</span><br><span class="line">		RETURN_FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	php_set_compare_func(sort_type TSRMLS_CC);</span><br><span class="line">	<span class="comment">//数组排序的zend实现</span></span><br><span class="line">	<span class="keyword">if</span> (zend_hash_sort(Z_ARRVAL_P(<span class="built_in">array</span>), zend_qsort, php_array_reverse_data_compare, <span class="number">0</span> TSRMLS_CC) == FAILURE) &#123;</span><br><span class="line">		RETURN_FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了之外的三个函数：asort，ksort，krsort 的源代码与上述代码类似；它们实现的核心都在第11行的zend_hash_sort函数中。下面是zend_hash_sort的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">				</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_hash_sort</span><span class="params">(HashTable *ht, sort_func_t sort_func,compare_func_t compar, </span><br><span class="line"><span class="keyword">int</span> renumber TSRMLS_DC)</span></span>&#123;</span><br><span class="line">	Bucket **arTmp;  <span class="comment">// 新的Bucket数组 数组元素为Bucket类型指针</span></span><br><span class="line">	Bucket *p;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">	IS_CONSISTENT(ht);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(ht-&gt;nNumOfElements&gt;<span class="number">1</span>) &amp;&amp; !(renumber &amp;&amp; ht-&gt;nNumOfElements&gt;<span class="number">0</span>)) &#123; <span class="comment">/* Doesn't require sorting */</span></span><br><span class="line">		<span class="keyword">return</span> SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * 保存哈希表中每个Bucket对应指针到数组arTmp中</span><br><span class="line">	 */</span></span><br><span class="line">	arTmp = (Bucket **) pemalloc(ht-&gt;<span class="function">nNumOfElements * <span class="title">sizeof</span><span class="params">(Bucket *)</span>, ht-&gt;persistent)</span>;</span><br><span class="line">	p = ht-&gt;pListHead;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		arTmp[i] = p;</span><br><span class="line">		p = p-&gt;pListNext;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//zend实现的快速排序 ,对Bucket重新排序，</span></span><br><span class="line">	(*sort_func)((<span class="keyword">void</span> *) arTmp, i, <span class="keyword">sizeof</span>(Bucket *), compar TSRMLS_CC);</span><br><span class="line"></span><br><span class="line">	HANDLE_BLOCK_INTERRUPTIONS();</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//34 - 50行</span></span><br><span class="line">    <span class="comment">//重置hash表中双向链表的节点（即Bucket）顺序</span></span><br><span class="line">	ht-&gt;pListHead = arTmp[<span class="number">0</span>];           </span><br><span class="line">	ht-&gt;pListTail = <span class="literal">NULL</span>;</span><br><span class="line">	ht-&gt;pInternalPointer = ht-&gt;pListHead;    <span class="comment">//ht-&gt;pInternalPointe:遍历数组元素</span></span><br><span class="line"></span><br><span class="line">	arTmp[<span class="number">0</span>]-&gt;pListLast = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		arTmp[<span class="number">0</span>]-&gt;pListNext = arTmp[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; i-<span class="number">1</span>; j++) &#123;</span><br><span class="line">			arTmp[j]-&gt;pListLast = arTmp[j-<span class="number">1</span>];</span><br><span class="line">			arTmp[j]-&gt;pListNext = arTmp[j+<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		arTmp[j]-&gt;pListLast = arTmp[j-<span class="number">1</span>];</span><br><span class="line">		arTmp[j]-&gt;pListNext = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		arTmp[<span class="number">0</span>]-&gt;pListNext = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ht-&gt;pListTail = arTmp[i-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	pefree(arTmp, ht-&gt;persistent);</span><br><span class="line">	HANDLE_UNBLOCK_INTERRUPTIONS();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (renumber) &#123;</span><br><span class="line">		zend_hash_reindex(ht, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PHP中hashtable 中两种双向链表，第一种：所有数组元素（Bucket）组成的双向链表，默认下各个元素之间的顺序是创建时的顺序，它们之间是通过结构体HashTable中的pListHead和pListTail 以及 结构体Bucket中的pListNext、pListLast来组成的双向链表的；第二种：就是同一个key下对应相同的hash值，即有些Bucket的成员变量h值相同，它们之间组成第二种双向链表。 以上四种数组排序就是按照Bucket中的某个成员变量快速排序之后，重置第一种链表中节点的相对顺序。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/数组值value-arsort-asort-数组key排序-krsort-ksort/">数组值value:arsort asort;数组key排序:krsort ksort</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-字符串函数-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/10/06/字符串函数-1/" class="article-date">
  	<time datetime="2015-10-06T03:26:15.000Z" itemprop="datePublished">2015-10-06</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/10/06/字符串函数-1/">PHP内核学习 --- 字符串函数 strstr,stristr,strpos,substr</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="PHP_字符串函数（strstr,stristr,strpos,substr）">PHP 字符串函数（strstr,stristr,strpos,substr）</h3><h4 id="1-_strstr,stristr,strpos,">1. strstr,stristr,strpos,</h4><p>strstr - 查找字符串的首次出现，stristr功能一样但区分大小写；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="built_in">string</span> $haystack,mixed $needle,<span class="keyword">bool</span> $before_needle = <span class="literal">false</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>还有就是如果想仅仅确定needle是否存在于haystack中，更好地选择是strpos函数。<br>内置字符串函数的代码位置：源码文件/ext/standard/string.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PHP_FUNCTION(<span class="built_in">strstr</span>)&#123;</span><br><span class="line">	zval *needle;</span><br><span class="line">	<span class="keyword">char</span> *haystack;</span><br><span class="line">	<span class="keyword">int</span> haystack_len;</span><br><span class="line">	<span class="keyword">char</span> *found = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">char</span> needle_char[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">long</span> found_offset;</span><br><span class="line">	zend_bool part = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	.....</span><br><span class="line">		found = php_memnstr(haystack, Z_STRVAL_P(needle), Z_STRLEN_P(needle), haystack + haystack_len);</span><br><span class="line">	.....</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中核心的函数就是php_memnstr(),参数说明主字符串的指针，子串也就是被查字符串的指针，子字符串的长度，主字符串的末尾指针； 特别说明一点：php_memnstr只不过是定义的一个宏：#define php_memnstr zend_memnstr,<br>真正的函数实现：源码目录/Zend/zend_operators.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">zend_memnstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *haystack, <span class="keyword">const</span> <span class="keyword">char</span> *needle, <span class="keyword">int</span> needle_len, <span class="keyword">char</span> *end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *p = haystack;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> ne = needle[needle_len-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (needle_len == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">char</span> *)<span class="built_in">memchr</span>(p, *needle, (end-p));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (needle_len &gt; end-haystack) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 最差情况下，不需要遍历到主字符串的末尾，end-=needl_len,就是遍历的终点 </span></span><br><span class="line">	end -= needle_len;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p &lt;= end) &#123;</span><br><span class="line">	   <span class="comment">//先比较头尾是否一致，达到排除掉只有末尾字符不相符的情况，减少比较的次数</span></span><br><span class="line">		<span class="keyword">if</span> ((p = (<span class="keyword">char</span> *)<span class="built_in">memchr</span>(p, *needle, (end-p+<span class="number">1</span>))) &amp;&amp; ne == p[needle_len-<span class="number">1</span>]) &#123; 				<span class="keyword">if</span> (!<span class="built_in">memcmp</span>(needle, p, needle_len-<span class="number">1</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数有其实就是字符串的简单匹配，没用使用KMP算法，但也做了一些改进，如注释。<br>以上注释中的两处是暴力字符匹配中源码的两处改进的地方。<br>strstr和stristr的区别就是 后者会把字符串转成统一的小写,代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">PHPAPI <span class="keyword">char</span> *<span class="title">php_stristr</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *t, size_t s_len, size_t t_len)</span></span>&#123;</span><br><span class="line">	php_strtolower(s,s_len);</span><br><span class="line">	php_strtolower(t,t_len);</span><br><span class="line">	<span class="keyword">return</span> php_memnstr(s,t,t_len,s+s_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-substr">2.substr</h4><p>substr 函数在php 5.2中在将截取之后原字符串也会发生变化，这应该是个bug，在php 5.6.13中没有出现这个问题。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PHP-strstr-stristr-substr/">PHP strstr,stristr,substr</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-ext-struct" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/25/ext-struct/" class="article-date">
  	<time datetime="2015-08-24T22:43:57.000Z" itemprop="datePublished">2015-08-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/25/ext-struct/">PHP 内核学习 --- 扩展结构</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="PHP的扩展结构">PHP的扩展结构</h3><p>通过php下源码目录下的ext_skel 工具创建一个自己的扩展 “./configure –extname=wwbext”, 下面来了解一下一个扩展的框架结构：</p>
<p>一个扩展通常有6部分组成：<br> 1.引入头文件<br> 2.声明导出函数<br> 3.声明Zend函数块<br> 4.声明Zend模块<br> 5.实现get_module()函数<br> 6.实现导出函数</p>
<h4 id="1-头文件">1.头文件</h4><p>在php扩展中，必须要引入一个php.h的头文件（main目录下）。它包含扩展所需要的宏和API定义。</p>
<h4 id="2-导出函数声明">2.导出函数声明</h4><p>通过声明和实现导出函数，php脚本才能访问到我们所编写的扩展中的函数和类。<br>导出函数的声明形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zif_wwbext</span><span class="params">(</span><br><span class="line">	<span class="keyword">int</span> ht,</span><br><span class="line">	zval *return_value,</span><br><span class="line">	zval *this_ptr,</span><br><span class="line">	<span class="keyword">int</span> return_value_used,</span><br><span class="line">	zend_executor_globals *executor_globals</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中导出函数5个参数的作用：<br>ht：保存扩展函数参数的个数，通过ZEND_NUM_ARGS()宏访问<br>return_value:保存扩展函数的返回值<br>this_ptr:获得扩展函数所属的对象<br>return_value_used:标识函数的返回值是否为脚本所使用，1：是 ，0：否<br>executor_globals：指向Zend引擎的全局设置,通过TSRMLS_FETCH()引用这个值</p>
<h4 id="3-Zend函数块">3.Zend函数块</h4><p>虽然声明的导出函数，但是Zend引擎不会自动引入导出函数，这个时候我们需要zend_function_entry结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _zend_function_entry&#123;</span><br><span class="line">	<span class="keyword">char</span> *fname;</span><br><span class="line">	<span class="keyword">void</span> (*handler) (INTERNAL_FUNCTION_PARAMETERS);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> * func_arg_types;</span><br><span class="line">&#125;zend_function_entry;</span><br></pre></td></tr></table></figure>
<p>成员变量的含义：<br>fname:PHP脚本里调用的函数名<br>handler：C函数句柄，在这里就是导出函数的句柄<br>func_arg_types:一个参数是否强制按引用方式传递，一般为NULL<br>Zend引擎通过zend_function_entry结构数组把导出函数引入内部</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> zend_function_entry wwbext_functions[]=&#123;</span><br><span class="line">	PHP_FE(confirm_wwbext_complied,<span class="literal">NULL</span>)</span><br><span class="line">	PHP_FE_END</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>导入大致过程：循环zend_function_entry数组，依次将函数载入内核函数表</p>
<h4 id="4-声明Zend模块">4.声明Zend模块</h4><p>PHP的扩展信息都保存在zend_module_entry结构中，这个结构包含zend引擎需要知道的模块信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tpyedef <span class="keyword">struct</span> _zend_module_entry zend_module_entry;</span><br><span class="line"><span class="keyword">struct</span> _zend_module_entry&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> size;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> zend_api;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> zend_api;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> zts;</span><br><span class="line">	<span class="keyword">char</span> *name;</span><br><span class="line">	zend_function_entry *functions;</span><br><span class="line">	<span class="keyword">int</span> (*module_startup_func)(INT_FUNC_ARGS);</span><br><span class="line">	<span class="keyword">int</span> (*module_shutdown_func) (SHUTDOWM_FUNC_ARGS);</span><br><span class="line">	<span class="keyword">int</span> (*request_startup_func) (INT_FUNC_ARGS);</span><br><span class="line">	<span class="keyword">int</span> (*request_shutdown_func) (SHUTDOWN_FUNC_AGGS);</span><br><span class="line">	<span class="keyword">void</span> (*info_func) (ZEND_MODULE_INFO_FUNC_ARGS);</span><br><span class="line">	<span class="keyword">char</span> *version;</span><br><span class="line">	.............</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前四个成员通过STANDARD_MOUDLE_HEADER宏来填充；name:模块名； functions:第三部分的Zend的函数块指针；module_startup_func:模块初始化函数，可以通过宏ZEND_MINIT来启动；module_end_func:模块结束函数，对应的宏ZEND_MSHUTDOWN;request_startup_func:请求启动函数，宏ZEND_RMINIT；request_end_func:请求关闭函数，对应的宏ZEND_RSHUTDOWN，最后的versiion代表版本信息。<br>具体到我们的新扩展wwbext，结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">zend_moudle_entry wwbext_module_entry = &#123;</span><br><span class="line">	STANDARD_MOUDLE_HEADER,</span><br><span class="line">	<span class="string">"wwbext"</span>,</span><br><span class="line">	wwbext_functions,</span><br><span class="line">	PHP_MINIT(wwbext),</span><br><span class="line">	PHP_MSHUTDOWN(wwbext),</span><br><span class="line">	PHP_RINIT(wwext),</span><br><span class="line">	PHP_RSHUTDOWN(wwbext)</span><br><span class="line">	PHP_WWBEXT_VERSION,</span><br><span class="line">	STANDARD_MOUDLE_PROPERTIES</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-get_module()函数">5.get_module()函数</h4><p>当wwbext这个扩展被动态加载时回去调用get_module函数，实现过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> COMPILE_DL_WWBEXT</span></span><br><span class="line">ZEND_GET_MODULE(wwbext)</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>ZEND_GET_MODULE宏的张开如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> ZEND_GET_MOUDLE(name) \</span><br><span class="line">	ZEND_DLEXPORT zend_module_entry *get_module(void)&#123;\</span><br><span class="line">		return &amp;name##_module_entry;\</span><br><span class="line">	&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过get_module函数的zend模块指针就是第四部分的模块指针，所以PHP内核和扩展是通过get_module来通信的。</p>
<h4 id="6-导出函数">6.导出函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PHP_FUNCTION(confirm_wwbext_compiledd)&#123;</span><br><span class="line">	<span class="keyword">char</span> *arg = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">size_t</span> arg_len,len;</span><br><span class="line">	zend_string *<span class="built_in">string</span>;</span><br><span class="line">	<span class="keyword">if</span>(zend_parse_parameters(ZEND_NUM_ARGS(),<span class="string">"s"</span>,$arg,$arg_len) == FAILURE)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	strg = strpprintf(<span class="number">0</span>, <span class="string">"Congratulations! You have successfully modified ext/%.78s/config.m4. Module %.78s is now compiled into PHP."</span>, <span class="string">"wwbext"</span>, arg);</span><br><span class="line">RETURN_STR(strg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此扩展的最后一步实现导函数，通过总结发现PHP内核和扩展通信是通过get_moduleh获取模块，而模块又是通过导出函数获取扩展内的自定义函数放入zend_function_entry数组，来完成我们的扩展函数可以在脚本中调用。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php扩展结构/">php扩展结构</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-hashtable" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/11/hashtable/" class="article-date">
  	<time datetime="2015-08-10T22:21:38.000Z" itemprop="datePublished">2015-08-11</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/11/hashtable/">PHP内核学习 -- new hashtable in php 7</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="PHP7_HashTable"><strong>PHP7</strong> <strong>HashTable</strong></h3><p>本文将概述hashtable在php7的实现，和为什么新的hashtable会更加高效。</p>
<p>本质上讲，PHP的数组就是一个有序的词典，一个有序的键/值对列表，而这种key/value的映射关系是通过hashtable来实现的。</p>
<p>hashtable的概念是简单地来讲：字符串键值通过哈希函数得到一个数字，而这个数字是一个常规数组的下标。但是两个不同的键值可能经过哈希函数后得到两个相同的值，所以hashtable的实现还要解决哈希冲突。</p>
<p>哈希冲突的基本解决办法有两种：一种是开放地址，另一种是链式法；PHP中使用了第二种，下面直接描述PHP中的hashtable是如何实现的，新一代PHP引擎的hashtable有什么不同，为什么更高效？</p>
<h4 id="hashtable在PHP中5的实现">hashtable在PHP中5的实现</h4><p>下图是php5中hashtable实现的简述：<br><img src="http://wangwenbo.github.io/img/basic_hashtable.svg" alt="Hashtable png"></p>
<p>如上图，a,b,c这些键值所对应的值存在“bucket”结构中，每一个bucket都是独立分配空间的，而buckets组成互相之间独立的链表来解决哈希冲突。<br>另外除此之外，还有一个链表来保存元素的顺序（如：数组中的元素顺序是它的插入顺序），数组键值“a”,“b”，“c”，它对应的链表就应该是下面这个样子：<br><img src="http://wangwenbo.github.io/img/ordered_hashtable.svg" alt="Hashtable2 png"><br>这中hashtable实现在内存使用和执行低效的原因有以下几个原因：</p>
<ol>
<li>bucket 要独立分配。每次分配都要额外占用内存。同时独立分配就意味着bucket的地址相对分散，影响缓存效率。</li>
<li>zvals 也要单独分配而且 每一个bucket要保存同一个zval的指针。<h4 id="zval在PHP7中的实现">zval在PHP7中的实现</h4>在介绍新的hahstable之前，先来看一下新的zval结构：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">struct</span> _zval_struct &#123;    </span><br><span class="line">	zend_value value;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			ZEND_ENDIAN_LOHI_4(</span><br><span class="line">				zend_uchar type,</span><br><span class="line">				zend_uchar type_flags,</span><br><span class="line">				zend_uchar const_flags,</span><br><span class="line">				zend_uchar reserved)</span><br><span class="line">			&#125; v;</span><br><span class="line">		<span class="keyword">uint32_t</span> type_info;</span><br><span class="line">	&#125; u1;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">uint32_t</span> var_flags;</span><br><span class="line">		<span class="keyword">uint32_t</span> next;       <span class="comment">/* hash collision chain */</span></span><br><span class="line">		<span class="keyword">uint32_t</span> cache_slot; <span class="comment">/* literal cache slot */</span></span><br><span class="line">		<span class="keyword">uint32_t</span> lineno;     <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line">	&#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个zval结构有三部分组成，第一部分zend_value 负责存储实际的变量值；第二部分的type_info 代表变量的类型，从而决定第一部分的实际存储的值；第三部分不得经常使用到。在特殊的上下文下 存储一些特别的信息，比如：抽象语法树用它来存储行号，VM constants 用它来存储缓存索引，以及hashtable中存储哈希碰撞是之下链表的下一个元素。</p>
<p>新旧zval之间的明显区别就是新的zval实现中不再有引用字段。原因就是zvals不再独立申请分配。而是嵌入到了存储它的结构中，比如hashtable。</p>
<p>虽然    zval自身不再包含引用字段，但是像string，array，object和resouce等类型的值依然在使用引用字段。这样做的优势：<br>   1.Zvals storing simple values (like booleans, integers or floats) no longer require any allocations. So this saves the allocation header overhead and improves performance by avoiding unnecessary allocs and frees and improving cache locality.</p>
<p>   2.Zvals storing simple values don’t need to store a refcount and GC root buffer.   </p>
<p>   3.We avoid double refcounting. E.g. previously objects both used the zval refcount and an additional object refcount, which was    necessary to support by-object passing semantics.</p>
<p>   4.As all complex values now embed a refcount, they can be shared independently of the zval mechanism. In particular it is now also possible to share strings. This is important to the hashtable implementation, as it no longer needs to copy non-interned string keys.</p>
<h4 id="hashtable_in_PHP7">hashtable in PHP7</h4><p>php中的哈希边有两部组成：HashTable和Bucket</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _Bucket&#123;</span><br><span class="line">	zend_ulong h;</span><br><span class="line">	zend_string *key;</span><br><span class="line">	zval  val;</span><br><span class="line">&#125; Bucket;</span><br></pre></td></tr></table></figure>
<p>Buckets是哈希表中重要的组成。在Buckets包含hash h，键值key和zval的值。同时zval嵌入到Bucket中，就和Bucket一起分配资源减少单独操作的开销。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _HashTable&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> nTableSize;  <span class="comment">//哈希表大小</span></span><br><span class="line">	<span class="keyword">uint32_t</span> nTableMask;</span><br><span class="line">	<span class="keyword">uint32_t</span> nNumUsed;</span><br><span class="line">	<span class="keyword">uint32_t</span> nNumOfElements;</span><br><span class="line">	zend_long nNextFreeElement;</span><br><span class="line">	Bucket    *arData;	</span><br><span class="line">	<span class="keyword">uint32_t</span>  *arHash;</span><br><span class="line">	<span class="keyword">dtor_func_t</span> pDestructor;</span><br><span class="line">	<span class="keyword">uint32_t</span> nInternalPointer;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span>&#123;</span><br><span class="line">			ZEND_ENDIAN_LOHI_3(</span><br><span class="line">				zend_uchar flags,</span><br><span class="line">				zend_uchar nApplyCount,</span><br><span class="line">				<span class="keyword">uint16_t</span> reserve)</span><br><span class="line">		&#125; v;</span><br><span class="line">		<span class="keyword">uint32_t</span> flags;</span><br><span class="line">	&#125; u;</span><br><span class="line">&#125; HashTable;</span><br></pre></td></tr></table></figure>
<p>arData数组中直接存储Bucket内容，而不是每个Bucket的指针，这样减少了独立分配每个Bucket和释放的开销。</p>
<h4 id="HashTbale中的元素顺序">HashTbale中的元素顺序</h4><p>数组arData的元素顺序是由写入顺序决定的，与key之无关。nNumUsed代表arData中已经分配的大小，nNumOfElements代表arData中实际元素的多少。两个字段看似代表的是同一个意思，那为什么还要设置两个变量？</p>
<pre><code>&lt;?php
    <span class="variable">$array</span> = [<span class="string">'foo'</span>=&gt;<span class="number">0</span>,<span class="string">'bar'</span>=&gt;<span class="number">1</span>,<span class="number">0</span>=&gt;<span class="number">2</span>,<span class="string">'xyz'</span>=&gt;<span class="number">3</span>,<span class="number">2</span>=&gt;<span class="number">4</span>];
    unset(<span class="variable">$array</span>[<span class="number">0</span>]);
    unset(<span class="variable">$array</span>[<span class="string">'xyz'</span>]);
?&gt;
</code></pre><p>此时的arData：nTableSize = 8 ；nNumOfElements = 3 ；nNumUsed = 5<br>[0]: key=”foo”, val=int(0)<br>[1]: key=”bar”, val=int(1)<br>“<a href="val=UNDEF">2</a>: val=UNDEF“<br>“<a href="val=UNDEF">3</a>: val=UNDEF“<br>[4]: h=2, val=int(4)<br>[5]: NOT INITIALIZED<br>[6]: NOT INITIALIZED<br>[7]: NOT INITIALIZED</p>
<p>那我们上面的数组遍历时，我们却到不到 下标为2和3的值，数组的遍历过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; ht-&gt;nUumhashbiaoUsed;++i)&#123;</span><br><span class="line">	Bucket *b = &amp;ht-&gt;arData[i];</span><br><span class="line">	<span class="keyword">if</span>(Z_ISUNDEF(b-&gt;val)) <span class="keyword">continue</span>;</span><br><span class="line">	<span class="comment">//处理Bucket</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php7-hashtable/">php7 hashtable</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
    <article id="post-php7-1" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/08/09/php7-1/" class="article-date">
  	<time datetime="2015-08-09T13:03:49.000Z" itemprop="datePublished">2015-08-09</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/08/09/php7-1/">php7_1</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="PHP7_变量的内核实现_-Part_1">PHP7 变量的内核实现 -Part 1</h3><p>【原文链接】（<a href="http://nikic.github.io/2015/05/05/Internal-value-representation-in-PHP-7-part-1.html）" target="_blank" rel="external">http://nikic.github.io/2015/05/05/Internal-value-representation-in-PHP-7-part-1.html）</a><br>我的上一篇文章描述了在PHP7中hashtable实现的改进。接下来我们来看一下PHP中变量新的实现形式。<br>因为这部分内容涉及较多的内容，所以它被分成两部分：第一部分来描述PHP5和PHP7在zval（Zend value）实现上的不同之处，同时也会涉及引用的实现。第二部分将会详细地探究一些类型的变量的实现，如string，object等变。</p>
<h3 id="Zvals_in_PHP5">Zvals in PHP5</h3><p>PHP5中zval的结构体定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _zval_struct&#123;</span><br><span class="line">	zvalue_value value;</span><br><span class="line">	zend_uint refcount_gc;</span><br><span class="line">	zend_uchar type;</span><br><span class="line">	zend_uchar is_ref_gc;</span><br><span class="line">&#125; zval;</span><br></pre></td></tr></table></figure>
<p>正如你已经看到的，一个zval结构体由 value，type还有_gc成员组成。其中value是一个联合体，它用来存储不同的变量值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> _zvalue_value&#123;</span><br><span class="line">	<span class="keyword">long</span> lval;            <span class="comment">//存储布尔值，整型和资源类型</span></span><br><span class="line">	<span class="keyword">double</span> dval;          <span class="comment">//浮点数</span></span><br><span class="line">	<span class="keyword">struct</span>&#123;</span><br><span class="line">		<span class="keyword">char</span> *val;</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">	&#125; str;                 <span class="comment">//字符串</span></span><br><span class="line">	HashTable *ht;         <span class="comment">//数组</span></span><br><span class="line">	zend_object_value obj; <span class="comment">//对象</span></span><br><span class="line">	zend_ast * ast;		    <span class="comment">//for constant expressions</span></span><br><span class="line">&#125; zvalue_value;</span><br></pre></td></tr></table></figure>
<p>一个C联合体结构一次只能一个成员变量被使用，它的大小有联合体中最大的成员变量决定。联合体中的所有成员变量共享同一块内存，通过你调用不同成员联合体被解释为不同的类型。假如你读取联合体中的lval,那么它的值就是一个有符号的整数。又假如你读取它的dval成员，它的值就是一个双精度浮点数。</p>
<p>zval的属性type存储变量的类型（一个数字），通过type去指定联合体中哪个成员被使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_NULL <span class="number">0</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_LONG <span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_DOUBLE <span class="number">2</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_BOOL <span class="number">3</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_ARRAY <span class="number">4</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_OBJECT <span class="number">5</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_STRING <span class="number">6</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_RESOURCE <span class="number">7</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Special types used for late-binding of constants */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_CONSTANT <span class="number">8</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_CONSTANT_AST <span class="number">9</span></span></span><br></pre></td></tr></table></figure>
<h3 id="PHP5的引用计数">PHP5的引用计数</h3><p>PHP 5的Zvals是被分配到堆上而且PHP 需要追踪zvals是否当前还在使用或者哪个应该释放。为了上述目的，引用计数被引入：zval的refcount_gc 记录一个zval被“refrenced”的次数。比如 $a = $b =42 ,42（存储在zval中）被两个变量引用，所以它的引用计数42。如果引用计数等于0，那就表示这个zval没有被使用，可以释放。</p>
<p>需要特别注意的是这里提到的引用计数不同于PHP reference（using &amp;）。接下来通过“reference” 和 “PHP reference”在概念上做区分。接下来我们先忽略后者。</p>
<p>一个和引用计数紧密相关的就是“写时复制”：多个变量可以共享以zval，只要它们的值是一样的。如果要修改zval则需要重新复制一个新的zval并在新的zval上更改。</p>
<p>我们来一下探究写时复制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$a = <span class="number">42</span>; <span class="comment">//$a       -&gt;zval_1(type=IS_LONG,value=42,refcount=1)</span></span><br><span class="line">$b = $a; <span class="comment">//$a,$b    -&gt;zval_1(type=IS_LONG,value=42,refcount=2)</span></span><br><span class="line">$c = $b; <span class="comment">//$a,$b.$c -&gt;zval_1(type=IS_LONG,value=42,refcount=3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//The following line causes a zval separation</span></span><br><span class="line">$a += <span class="number">1</span>;  <span class="comment">//$b,$c   -&gt;zval_1（type=IS_LONG，value=42，refcount=2）</span></span><br><span class="line">          <span class="comment">//$a      -&gt;zval_2(type=IS_LONG,value=43，refcount=1)</span></span><br><span class="line">          </span><br><span class="line">unset($b); <span class="comment">//$c     -&gt;zval_1(type=IS_LONG,value=42,refcount =1) </span></span><br><span class="line">           <span class="comment">//$a     -&gt;zval_2(type=IS_LONG,value=43,refcount =1)</span></span><br><span class="line">unset($c); <span class="comment">//zval_1 is destoryed, because refcount=0</span></span><br><span class="line">		   <span class="comment">//$a    -&gt;zval_2(type=IS_LONG,value=43,refcount=1)</span></span><br></pre></td></tr></table></figure>
<h3 id="Motivation_for_change">Motivation for change</h3><p>我们一起讨论一下内存占用（64位系统）：首先，zvalue_value联合体中str和obj成员最大为16字节，所以zvalue_value大小是16字节。zval结构体整体大小24字节，zval_gc_info是32字节。在堆上分配zval还需要额外的16字节，因此一个zval总共需要48字节。</p>
<p>从这些方面去考虑zval实现上一些低效的方式。一个仅仅存储整型类型的zval，仅仅需要8个字节。zval的类型标示type只需要一个1字节，却需要填充额外的8个字节。</p>
<p>对于我们真正需要的16个字节，我们还需要16个字节的引用计数和cycle collection以及额外16字节的分配头信息。即使不考虑我们真正需要执行的16个字节的内存分配和释放，其他的操作的内存开销代价也很大。</p>
<p>基于以上内容，提出以下几个问题：简单地整型真的需要存储引用计数，循环收集，堆分配吗？答案是否定的。</p>
<p>关于PHP 5zval实现方式的一些问题总结：</p>
 <ul><br>  <li>Zvals总是要求堆分配</li><br>  <li>即使当zval的值是一个整型并且不可能形成循环嵌套使用时，Zvals依然要引用计数和循环采集信息</li><br>  <li>一些情况下需要相当次数的间接寻址。例如，一个变量的值为对象，这就需要4次指针解引用(4个节点的指针链)。</li><br>  <li>由于直接的引用计数zval，变量值无法在zvals之间共享。比如，一个字符串无法由zval和hashtable 的key共享（hashtable的key与zval的存储方式不同）</li><br> </ul>


<h3 id="PHP7的Zvals">PHP7的Zvals</h3><p>PHP 7中的zval的根本变化是它不再独立堆分配和不再存储引用计数。取而代之的是一些复杂数据类型(strings,arrays,objects)自己存储引用计数。这样做的优势是：</p>
<ul><br>    <li>基本变量类型不再需要堆分配和引用计数</li><br>    <li>不再有双计数。以object为例，只是使用object自己存储的引用计数</li><br>    <li>因为引用计数现在有value自身保存，所以value可以在独立于zval实现共享。一个字符串既可以在zval和hashtable键值之间共享</li><br>    <li>较少的间接寻址，也就说找到所需要的值需要指针跳转的次数减少</li><br></ul>

<p>新zval的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _zval_struct&#123;</span><br><span class="line">	zend_value value;</span><br><span class="line">	<span class="keyword">union</span>&#123;</span><br><span class="line">		<span class="keyword">struct</span>&#123;</span><br><span class="line">			ZEND_ENDIAN_LOHI4&#123;</span><br><span class="line">				zend_uchar type,</span><br><span class="line">				zend_uchar type_flags,</span><br><span class="line">				zend_uchar const_flags,</span><br><span class="line">				zend_uchar reserved</span><br><span class="line">			&#125; v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">uint32_t</span> type_info;</span><br><span class="line">	&#125; u1;</span><br><span class="line">	<span class="keyword">union</span>&#123;</span><br><span class="line">		<span class="keyword">uint32_t</span> var_flags;</span><br><span class="line">		<span class="keyword">uint32_t</span> next;                <span class="comment">//hash collision chain</span></span><br><span class="line">		<span class="keyword">uint32_t</span> cache_slot;          <span class="comment">//literal cache solt</span></span><br><span class="line">		<span class="keyword">uint32_t</span> lineno;              <span class="comment">//line number(for ast nodes)</span></span><br><span class="line">		<span class="keyword">uint32_t</span> num_args;            <span class="comment">//arguments number for EX(This)</span></span><br><span class="line">		<span class="keyword">uint32_t</span> fe_pos;             <span class="comment">//foreach position</span></span><br><span class="line">		<span class="keyword">uint32_t</span> fe_iter_idx;        <span class="comment">//foreach iterator index</span></span><br><span class="line">	&#125; u2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个成员value依然是一个联合体。第二个成员是整数，保存类型信息（其中 宏ZEND_ENDIAN_LOHI4只是为了跨平台时保持布局一致，因此可以先忽略它）。这个子结构体中重要的是type（与之前zval的type类似）和type_flags, 这两部分详细的解释很快就会涉及。</p>
<p>截止到目前来看，这个结构存在一个小问题；成员value是8字节，由于结构体字节填充最终zval的大小为16字节。然而我们不需要用8个字节去保存一个type。因此zval中又包含了一个u2联合体，u2默认情况下不使用，一旦使用可以用来存储4个字节的数据。其中不同的成员变量对应不同的数据用途。</p>
<p>PHP 7的value成员内部定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> _zend_value&#123;</span><br><span class="line">	zend_long lval;</span><br><span class="line">	<span class="keyword">double</span> dval;</span><br><span class="line">	zend_refcounted *counted;</span><br><span class="line">	zend_string *str;</span><br><span class="line">	zend_array  *arr;</span><br><span class="line">	zend_object *obj;</span><br><span class="line">	zend_resource *res;</span><br><span class="line">	zend_reference *ref;</span><br><span class="line">	zend_ast_ref *ast;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Ingore these for now , they ara special</span></span><br><span class="line">	zval *zv;</span><br><span class="line">	<span class="keyword">void</span> *ptr;</span><br><span class="line">	zend_class_entry *ce;</span><br><span class="line">	zend_function *func;</span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		ZEND_ENDIAN_LOHT(</span><br><span class="line">			<span class="keyword">unint32_t</span> w1,</span><br><span class="line">			<span class="keyword">unint32_t</span> w2</span><br><span class="line">		)</span><br><span class="line">	&#125; ww;</span><br><span class="line">&#125; zend_value;</span><br></pre></td></tr></table></figure>
<p>首先，联合体value是8字节而不再是16字节。它直接保存保存整型（lval）和浮点数（dval），其它类型的变量则存储指针。除了被标记为特殊的成员变量之外，其它类型的指针都使用引用计数和拥有一个共同的header，这个header有zend_refcounted定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _zend_refcounted&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> refcount;</span><br><span class="line">	<span class="keyword">union</span>&#123;</span><br><span class="line">		<span class="keyword">struct</span>&#123;</span><br><span class="line">			ZEND_ENDIAN_LOHI_3(</span><br><span class="line">				zend_uchar type,</span><br><span class="line">				zend_uchar flags,</span><br><span class="line">				<span class="keyword">uint16_t</span>   gc_info)</span><br><span class="line">		&#125;V;</span><br><span class="line">		<span class="keyword">uint32_t</span> type_info;</span><br><span class="line">	&#125; u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>zend_refcounted结构体包含refcount。此外，它还包含type，falgs，gc_info。type是zval的type的复制，GC通过它来区分不同zend_refcounted结构体。falgs对不同的变量类型有不同的用途，这个部分将在第二部分针对不同类型具体解释。</p>
<p>gc_info 相当于旧zval的缓存实体。只不过有原来的一个执行“root buffer“的指针变成一个数字索引。因为这“root buffer”是固定大小（10000elements），可以通过16bit数字来代替64bit指针。gc_info 也可以被encode 进node的color属性中，color被用来在collection是标记node。</p>
<h3 id="Zval_内存管理">Zval 内存管理</h3><p>我已经提到zvals不再单独进行堆分配。但是zvals依然需要被存储在某处，那么这个过程是怎样的哪？zvals依然是堆分配的主要部分，但是它们直接切入到其中。例如，一个哈希bucket 将会直接被嵌入一个zval本身而不再是一个zval的指针。这样一个函数的变量表或者一个对象的属性表将会是一个被分配在统一在内存块中的zval数组，而不是被分在不同的内存块。这样一来，这样的存储实现就减少了间接寻址的次数。</p>
<p>按照先前的zval设计，一旦zval被引用就需要复制一份zval指针和增加引用计数。而现在则要复制一份zval的值，以及如果value需要使用引用计数的话，将引用计数增加。</p>
<p>PHP 怎么判断当前的zval中的value需要被计数？这个不仅仅依靠type来决定，因为一些类型如strings，arrays并不总是需要计数的。我们通过zval的type_info来决定是否需要计算引用。There are a number of other bits encoding properties of the type:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_TYPE_CONSTANT     (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)  <span class="comment">/*special*/</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_TYPE_IMMUTABLE    (<span class="number">1</span>&lt;&lt;<span class="number">1</span>)  <span class="comment">/*special*/</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_TYPE_REFCOUNTED   (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_TYPE_COLLECTABLE  (<span class="number">1</span>&lt;&lt;<span class="number">3</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_TYPE_COPYABLE     (<span class="number">1</span>&lt;&lt;<span class="number">4</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_TYPE_SYMBOLTABLE  (<span class="number">1</span>&lt;&lt;<span class="number">5</span>)   <span class="comment">/*special*/</span></span></span><br></pre></td></tr></table></figure>
<p>变量的类型有三种基本属性，它们分别是“refcounted”,”collectable”和“copyable”。我们已经知道“refcounted（引用计数）”。Collectable 意味着这个 zval可以进行. 例如 字符串这种类型可以有refcounted属性，但是不会出现循环引用自己。</p>
<p>当“duplication”执行时，Copyability 决定value是否需要被复制。一个“duplication”是硬复制，如果复制一个指向array的zval，这不仅仅是增加此array的引用计数。而是新建一个独立的新的zval来指向复制的array。但是objects和resources这种类型，它们的复制操作不是想上面一样，只不过是增加了引用计数。这相当于传递对对象和资源类型的语义。</p>
<p>接下来的表格展示不同变量类型和它们分别对应的falgs。像整型和布尔等基本数据类型不使用指针指向另一个结构体。其中表格中还有一列“immutable” ，它用来标记不可更改的数组，这部分将在第二部分讨论。</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">refcounted</th>
<th style="text-align:center">collectable</th>
<th style="text-align:center">copyable</th>
<th style="text-align:center">immutable</th>
</tr>
</thead>
<tbody>
<tr>
<td>simple types</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>string</td>
<td style="text-align:center">x</td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>interned string</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>array</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>immutable array</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td>object</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>resource</td>
<td style="text-align:center">x</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>reference</td>
<td style="text-align:center">x</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>基于上面的介绍，我们通过两个例子来看一下新的zval内存管理是怎样的。<br>首先，一个简单地整数类型的例子，不同于前文中PHP5的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$a = <span class="number">42</span>;    <span class="comment">// $a = zval_1(type = IS_LONG,value=42)</span></span><br><span class="line">$b = $a;    <span class="comment">// $a = zval_1(type=IS_LONG, value=42)</span></span><br><span class="line">               <span class="comment">// $b = zval_2(type=IS_LONG, value=42)</span></span><br><span class="line"></span><br><span class="line">   $a += <span class="number">1</span>;    <span class="comment">// $a = zval_1(type=IS_LONG, value=43)</span></span><br><span class="line">               <span class="comment">// $b = zval_2(type=IS_LONG, value=42)</span></span><br><span class="line"></span><br><span class="line">   unset($a);  <span class="comment">// $a = zval_1(type=IS_UNDEF)</span></span><br><span class="line">               <span class="comment">// $b = zval_2(type=IS_LONG, value=42)</span></span><br></pre></td></tr></table></figure>
<p>整数值不再被多个变量共享，每个变量都有自己对应的zval。这里我用了value = 而不是-&gt;就是要标明值被嵌入在了zval中而没有被重新分配内存。unset一个变量，它的zval变成IS_UNDEF。下面我们看一个更有趣和复杂的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$a = [ ];   <span class="comment">// $a = zval_1(type=IS_ARRAY) -&gt; zend_array_1(refcount=1, value=[])</span></span><br><span class="line">   $b = $a;    <span class="comment">// $a = zval_1(type=IS_ARRAY) -&gt; zend_array_1(refcount=2, value=[])</span></span><br><span class="line">               <span class="comment">// $b = zval_2(type=IS_ARRAY) ---^</span></span><br><span class="line">   <span class="comment">// Zval separation occurs here</span></span><br><span class="line">   $a[] = <span class="number">1</span>       <span class="comment">// $a = zval_1(type=IS_ARRAY) -&gt; zend_array_2(refcount=1,    value=[1])</span></span><br><span class="line">                  <span class="comment">// $b = zval_2(type=IS_ARRAY) -&gt; zend_array_1(refcount=1, value=[])</span></span><br><span class="line">   unset($a);     <span class="comment">// $a = zval_1(type=IS_UNDEF) and zend_array_2 is destroyed</span></span><br><span class="line">                  <span class="comment">// $b = zval_2(type=IS_ARRAY) -&gt; zend_array_1(refcount=1, value=[])</span></span><br></pre></td></tr></table></figure>
<p>在第二个例子中，不同的变量依然对应一个不同的zval，但是所有的zvals执行同一个zend_array结构体。一旦变量改变就需要重新复制一份新的。这个过程和php 5的工作机制很相似。</p>
<h3 id="Types">Types</h3><p>PHP 7 支持的类型列表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// regular data types</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_UNDEF                    <span class="number">0</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_NULL                     <span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_FALSE                    <span class="number">2</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_TRUE                     <span class="number">3</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_LONG                     <span class="number">4</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_DOUBLE                   <span class="number">5</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_STRING                   <span class="number">6</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_ARRAY                    <span class="number">7</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_OBJECT                   <span class="number">8</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_RESOURCE                 <span class="number">9</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_REFERENCE                <span class="number">10</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// constant expressions</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_CONSTANT                 <span class="number">11</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_CONSTANT_AST             <span class="number">12</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// internal types</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_INDIRECT                 <span class="number">15</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_PTR                      <span class="number">17</span></span></span><br></pre></td></tr></table></figure>
<p>这个列表和PHP 5中的很相似，但是还有一些不同：</p>
<p> 1.the IS_UNDEF type is used in places where previously a NULL zval pointer (not to be confused with an IS_NULL zval) was used. For example, in the refcounting examples above the IS_UNDEF type is set for variables that have been unset.<br> 2.The IS_BOOL type has been split into IS_FALSE and IS_TRUE. As such the value of the boolean is now encoded in the type, which allows the optimization of a number of type-based checks. This change is transparent to userland, where this is still a single “boolean” type.<br> 3.PHP references no longer use an is_ref flag on the zval and use a new IS_REFERENCE type instead. How this works will be described in the next section.<br> 4.The IS_INDIRECT and IS_PTR types are special internal types.</p>
<p> The IS_LONG type now uses a zend_long value instead of an ordinary C long. The reason behind this is that on 64-bit Windows (LLP64) a long is only 32-bit wide, so PHP 5 ended up always using 32-bit numbers on Windows. PHP 7 will allow you to use 64-bit numbers if you’re on an 64-bit operating system, even if that operating system is Windows.</p>
<p>Details of the individual zend_refcounted types will be discussed in the next part. For now we’ll only look at the implementation of PHP references.</p>
<h3 id="References">References</h3><p>PHP 7使用了和PHP 5完全不同的方式去处理PHP &amp;引用（这也是PHP7的一个源码级别的bug）。 下面是PHP5中PHP references如何工作的？</p>
<p>通常情况下，写时复制的原理就是在要修改一个变量之前，先将这些变量共享的zval分离，这么做的目的是防止这次更改影响其它变量共享原来的zval。这个相当于语法上的值传递。</p>
<p>对于PHP reference（&amp;），上面的处理方式并不适用。假如一个value是PHP reference，你就是想将改变作用于共享同一个zval的变量。作为PHP 5zvals的一部分is_ref决定一个value是否是PHP reference，也决定了在修改之前是否需要分离zval。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$a = [];  	<span class="comment">// $a     -&gt; zval_1(type=IS_ARRAY, refcount=1, is_ref=0) -&gt; HashTable_1(value=[])</span></span><br><span class="line">$b =&amp; $a; 	<span class="comment">// $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_1(value=[])</span></span><br><span class="line"></span><br><span class="line">$b[] = <span class="number">1</span>; 	<span class="comment">// $a = $b = zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_1(value=[1])</span></span><br><span class="line">         		<span class="comment">// Due to the is_ref=1 PHP will *not* separate the zval</span></span><br></pre></td></tr></table></figure>
<p>这种设计的一个明显的问题就是在引用复制的变量和否引用变量之间无法共享value。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$a = [];  <span class="comment">// $a         -&gt; zval_1(type=IS_ARRAY, refcount=1, is_ref=0) -&gt; HashTable_1(value=[])</span></span><br><span class="line">   $b = $a;  <span class="comment">// $a, $b     -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=0) -&gt; HashTable_1(value=[])</span></span><br><span class="line">   $c = $b   <span class="comment">// $a, $b, $c -&gt; zval_1(type=IS_ARRAY, refcount=3, is_ref=0) -&gt; HashTable_1(value=[])</span></span><br><span class="line"></span><br><span class="line">   $d =&amp; $c; <span class="comment">// $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=0) -&gt; HashTable_1(value=[])</span></span><br><span class="line">             <span class="comment">// $c, $d -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_2(value=[])</span></span><br><span class="line">             <span class="comment">// $d is a reference of $c, but *not* of $a and $b, so the zval needs to be copied</span></span><br><span class="line">             <span class="comment">// here. Now we have the same zval once with is_ref=0 and once with is_ref=1.</span></span><br><span class="line"></span><br><span class="line">   $d[] = <span class="number">1</span>; <span class="comment">// $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=0) -&gt; HashTable_1(value=[])</span></span><br><span class="line">             <span class="comment">// $c, $d -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_2(value=[1])</span></span><br><span class="line">             <span class="comment">// Because there are two separate zvals $d[] = 1 does not modify $a and $b.</span></span><br></pre></td></tr></table></figure>
<p>PHP5中这种引用行为是php的变量引用比正常使用值慢的其中一个原因。再给出另一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$<span class="built_in">array</span> = range(<span class="number">0</span>, <span class="number">1000000</span>);</span><br><span class="line">$ref =&amp; $<span class="built_in">array</span>;</span><br><span class="line">var_dump(count($<span class="built_in">array</span>)); <span class="comment">// &lt;-- separation occurs here</span></span><br></pre></td></tr></table></figure>
<p>因为count函数接收的是值传递，但是$array是一个PHP reference，因此在执行count函数前先复制一份$array.如果$array不是引用，value就可以共享。</p>
<p>现在，我们转向PHP 7中PHP references的实现。因为zvals不在单独分配，所以不可能使用PHP5的实现方式。<br>PHP7增加了一个新的类型IS_REFERENCE,zend_references结构体来作为它的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _zend_reference&#123;</span><br><span class="line">	zend_refcounted gc;</span><br><span class="line">	zval            val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质上来讲，一个zend_reference是a refcounted zval。在引用集合里的所用变量都是保存着一个zval，而这个zval的type是IS_REFERENCE,IS_REFERENCE指向相同的zend_reference结构体。<br>让我们站在PHP7的语法角度，重新思考一下上面的代码。为了简洁，下面的代码省略了变量们对应的独立zvals。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$a = [];  <span class="comment">// $a                                     -&gt; zend_array_1(refcount=1, value=[])</span></span><br><span class="line">$b =&amp; $a; <span class="comment">// $a, $b -&gt; zend_reference_1(refcount=2) -&gt; zend_array_1(refcount=1, value=[])</span></span><br><span class="line"></span><br><span class="line">$b[] = <span class="number">1</span>; <span class="comment">// $a, $b -&gt; zend_reference_1(refcount=2) -&gt; zend_array_1(refcount=1, value=[1])</span></span><br></pre></td></tr></table></figure>
<p>通过引用创建了一个zend_reference。zend_reference的refcount=2是因为引用集合有两个变量，value自身的refcount=1是因为只有一个zend_reference指向它。先我们来看一下引用和非引用的混合使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$a = [];  <span class="comment">// $a         -&gt; zend_array_1(refcount=1, value=[])</span></span><br><span class="line">$b = $a;  <span class="comment">// $a, $b,    -&gt; zend_array_1(refcount=2, value=[])</span></span><br><span class="line">$c = $b   <span class="comment">// $a, $b, $c -&gt; zend_array_1(refcount=3, value=[])</span></span><br><span class="line"></span><br><span class="line">$d =&amp; $c; <span class="comment">// $a, $b                                 -&gt; zend_array_1(refcount=3, value=[])</span></span><br><span class="line">             <span class="comment">// $c, $d -&gt; zend_reference_1(refcount=2) ---^</span></span><br><span class="line">             <span class="comment">// Note that all variables share the same zend_array, even though some are</span></span><br><span class="line">             <span class="comment">// PHP references and some aren't.</span></span><br><span class="line"></span><br><span class="line">$d[] = <span class="number">1</span>;   <span class="comment">// $a, $b                                 -&gt; zend_array_1(refcount=2, value=[])</span></span><br><span class="line">         		<span class="comment">// $c, $d -&gt; zend_reference_1(refcount=2) -&gt; zend_array_2(refcount=1, value=[1])</span></span><br><span class="line">         		<span class="comment">// Only at this point, once an assignment occurs, the zend_array is duplicated.</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，所有的变量共享同一个数组（即使一些是通过引用赋值的），这一点是和PHP 5有很大的不同。在PHP 7中将一个大的，被引用的数组传递给count依然是安全的，它不会被复制。引用通常比正常值要小，因为它们一个zend_reference结构体而且通常不在引擎代码的fast-path中处理。</p>
<h3 id="Wrapping_up">Wrapping up</h3><p>总的来说，PHP 7中最基本的变化就是zval不再在堆上独立分配和将引用存储在自身结构之中。取而代之，复杂的数据类型如字符串、数组和对象会拥有引用计数。这样做的结果就是较少的内存分配，较少的间接寻址和内存占用。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PHP7-ZVAL/">PHP7 ZVAL</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>







  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 阳关冰上
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>