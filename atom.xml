<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[Hexo]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.flydream.org//"/>
  <updated>2015-08-10T23:50:31.000Z</updated>
  <id>http://www.flydream.org//</id>
  
  <author>
    <name><![CDATA[John Doe]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[new hashtable in php 7]]></title>
    <link href="http://www.flydream.org/2015/08/11/hashtable/"/>
    <id>http://www.flydream.org/2015/08/11/hashtable/</id>
    <published>2015-08-10T22:21:38.000Z</published>
    <updated>2015-08-10T23:50:31.000Z</updated>
    <content type="html"><![CDATA[<h3 id="PHP7_HashTable"><strong>PHP7</strong> <strong>HashTable</strong></h3><p>本文将概述hashtable在php7的实现，和为什么新的hashtable会更加高效。</p>
<p>本质上讲，PHP的数组就是一个有序的词典，一个有序的键/值对列表，而这种key/value的映射关系是通过hashtable来实现的。</p>
<p>hashtable的概念是简单地来讲：字符串键值通过哈希函数得到一个数字，而这个数字是一个常规数组的下标。但是两个不同的键值可能经过哈希函数后得到两个相同的值，所以hashtable的实现还要解决哈希冲突。</p>
<p>哈希冲突的基本解决办法有两种：一种是开放地址，另一种是链式法；PHP中使用了第二种，下面直接描述PHP中的hashtable是如何实现的，新一代PHP引擎的hashtable有什么不同，为什么更高效？</p>
<h4 id="hashtable在PHP中5的实现">hashtable在PHP中5的实现</h4><p>下图是php5中hashtable实现的简述：<br><img src="http://chuantu.biz/t2/11/1439250546x-1566638931.png" alt="Hashtable png"></p>
<p>如上图，a,b,c这些键值所对应的值存在“bucket”结构中，每一个bucket都是独立分配空间的，而buckets组成互相之间独立的链表来解决哈希冲突。<br>另外除此之外，还有一个链表来保存元素的顺序（如：数组中的元素顺序是它的插入顺序），数组键值“a”,“b”，“c”，它对应的链表就应该是下面这个样子：<br><img src="http://chuantu.biz/t2/11/1439250599x-1566638931.png" alt="Hashtable2 png"><br>这中hashtable实现在内存使用和执行低效的原因有以下几个原因：</p>
<ol>
<li>bucket 要独立分配。每次分配都要额外占用内存。同时独立分配就意味着bucket的地址相对分散，影响缓存效率。</li>
<li>zvals 也要单独分配而且 每一个bucket要保存同一个zval的指针。<h5 id="hashtable在PHP7中的实现">hashtable在PHP7中的实现</h5>在介绍新的hahstable之前，先来看一下新的zval结构：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">struct</span> _zval_struct &#123;    </span><br><span class="line">	zend_value value;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			ZEND_ENDIAN_LOHI_4(</span><br><span class="line">				zend_uchar type,</span><br><span class="line">				zend_uchar type_flags,</span><br><span class="line">				zend_uchar const_flags,</span><br><span class="line">				zend_uchar reserved)</span><br><span class="line">			&#125; v;</span><br><span class="line">		<span class="keyword">uint32_t</span> type_info;</span><br><span class="line">	&#125; u1;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">uint32_t</span> var_flags;</span><br><span class="line">		<span class="keyword">uint32_t</span> next;       <span class="comment">/* hash collision chain */</span></span><br><span class="line">		<span class="keyword">uint32_t</span> cache_slot; <span class="comment">/* literal cache slot */</span></span><br><span class="line">		<span class="keyword">uint32_t</span> lineno;     <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line">	&#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="PHP7_HashTable"><strong>PHP7</strong> <strong>HashTable</strong></h3><p>本文将概述hashtable在php7的实现，和为什么新的hashtable会更加高效。</p>
<p>本质上讲，PHP]]>
    </summary>
    
      <category term="php7 hashtable" scheme="http://www.flydream.org/tags/php7-hashtable/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[php7_1]]></title>
    <link href="http://www.flydream.org/2015/08/09/php7-1/"/>
    <id>http://www.flydream.org/2015/08/09/php7-1/</id>
    <published>2015-08-09T13:03:49.000Z</published>
    <updated>2015-08-09T13:03:49.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP 内核学习 -- 变量的作用域和生命周期]]></title>
    <link href="http://www.flydream.org/2015/08/08/varlifttime/"/>
    <id>http://www.flydream.org/2015/08/08/varlifttime/</id>
    <published>2015-08-08T08:44:32.000Z</published>
    <updated>2015-08-08T12:32:01.000Z</updated>
    <content type="html"><![CDATA[<h3 id="作用域_生命周期"><strong>作用域</strong> <strong>生命周期</strong></h3><p>变量的作用域本质是一块代码区域，在这个区域内可以访问某个具体的变量，超出这个区域后，变量就无法被访问到。</p>
<h4 id="全局变量和局部变量">全局变量和局部变量</h4><p>全局变量是在整个程序中任何地方随意调用的变量， 在PHP中，除了声明在函数体内的普通变量均为全局变量，在函数体内则可以通过global语句来声明。 相对于全局变量，局部变量的作用域是程序中的部分代码（如函数中），而不是程序的全部。</p>
<pre><code><span class="php"><span class="preprocessor">&lt;?php</span>
    <span class="function"><span class="keyword">function</span> <span class="title">scope</span><span class="params">()</span></span>{
        <span class="variable">$liftcycle</span> = <span class="string">"wang"</span>;
    }
<span class="preprocessor">?&gt;</span></span>
</code></pre><p>变量的生命周期和作用域有一定的联系，如函数中的局部变量$filecycle，它的生命开始func scope的执行，结束于函数执行完毕。</p>
<p>PHP变量的作用域是如何实现 ？全局变量和局部变量的的作用域实现有什么区别？</p>
<p>zend引擎有一个_zend_executor_globals结构，全局变量就保存在symbol_table这个全局符号表中；active_symbol_table中保存局部变量，这些局部变量可能是来自函数或者对象的属性等；而且每个独立的函数运行时都有自己的active_symbol_table,保证作用域独立。</p>
<p>下面来看一下，_zend_execute_data (zend/zend_complie.h)的结构：</p>
<pre><code><span class="comment"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">typedef</span> <span class="keyword">struct</span> _zend_execute_data &#123;    </span><br><span class="line">	<span class="keyword">struct</span> _zend_op *opline;</span><br><span class="line">	zend_function_state function_state;</span><br><span class="line">	zend_op_array *op_array;</span><br><span class="line">	zval *object;</span><br><span class="line">	HashTable *symbol_table;</span><br><span class="line">	<span class="keyword">struct</span> _zend_execute_data *prev_execute_data;</span><br><span class="line">	zval *old_error_reporting;</span><br><span class="line">	zend_bool nested;</span><br><span class="line">	zval **original_return_value;</span><br><span class="line">	zend_class_entry *current_scope;</span><br><span class="line">	zend_class_entry *current_called_scope;</span><br><span class="line">	zval *current_this;</span><br><span class="line">	<span class="keyword">struct</span> _zend_op *fast_ret; <span class="comment">/* used by FAST_CALL/FAST_RET (finally keyword) */</span></span><br><span class="line">	zval *delayed_exception;</span><br><span class="line">	call_slot *call_slots;</span><br><span class="line">	call_slot *call;</span><br><span class="line">&#125; zend_execute_data;</span><br></pre></td></tr></table></figure></span>
</code></pre><p>函数中的局部变量就存储在_zend_execute_data的symbol_table中，在执行当前函数的op_array时， 全局zend_executor_globals中的<em>active_symbol_table会指向当前_zend_execute_data中的</em>symbol_table。 因为每个函数调用开始时都会重新初始化EG(active_symbol_table)为NULL， 在这个函数的所有opcode的执行过程中这个全局变量会一直存在，并且所有的局部变量修改都是在它上面操作完成的，如前面的赋值操作等。 而此时，其他函数中的symbol_table会存放在栈中，将当前函数执行完并返回时，程序会将之前保存的zend_execute_data恢复， 从而其他函数中的变量也就不会被找到，局部变量的作用域就是以这种方式来实现的。 相关操作在 Zend/zend_vm_execute.h 文件中定义的execute函数中一目了然，如下所示代码：</p>
<pre><code><span class="comment"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">zend_vm_enter:</span><br><span class="line"><span class="comment">/* Initialize execute_data */</span></span><br><span class="line">execute_data = (zend_execute_data *)zend_vm_stack_alloc(</span><br><span class="line">    <span class="keyword">sizeof</span>(zend_execute_data) +</span><br><span class="line">    <span class="keyword">sizeof</span>(zval**) * op_array-&gt;last_var *(EG(active_symbol_table) ? <span class="number">1</span> : <span class="number">2</span>) +</span><br><span class="line">    <span class="keyword">sizeof</span>(temp_variable) * op_array-&gt;T TSRMLS_CC);</span><br><span class="line"> </span><br><span class="line">EX(symbol_table) = EG(active_symbol_table);</span><br><span class="line">EX(prev_execute_data) = EG(current_execute_data);</span><br><span class="line">EG(current_execute_data) = execute_data;</span><br></pre></td></tr></table></figure></span>
</code></pre><p>EX宏的作用是获取结构体zend_execute_data的字段值。它的实现是:#define EX(element) execute_data-&gt;element</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="作用域_生命周期"><strong>作用域</strong> <strong>生命周期</strong></h3><p>变量的作用域本质是一块代码区域，在这个区域内可以访问某个具体的变量，超出这个区域后，变量就无法被访问到。</p>
<h4 id="全局变量和局部]]>
    </summary>
    
      <category term="PHP内核 变量 作用域 生命周期" scheme="http://www.flydream.org/tags/PHP%E5%86%85%E6%A0%B8-%E5%8F%98%E9%87%8F-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP 内核学习 -- 变量的结构和类型]]></title>
    <link href="http://www.flydream.org/2015/08/08/variableAnalysie/"/>
    <id>http://www.flydream.org/2015/08/08/variableAnalysie/</id>
    <published>2015-08-07T22:36:05.000Z</published>
    <updated>2015-08-08T08:42:39.000Z</updated>
    <content type="html"><![CDATA[<h3 id="弱变量_ZVAL_HashTable"><strong>弱变量</strong>  <strong>ZVAL</strong>  <strong>HashTable</strong></h3><p>PHP是解释性语言，同时也是拥有弱变量类型的语言.</p>
<h4 id="1-变量的存储结构">1.变量的存储结构</h4><p>PHP的变量存储结构ZVAL(Zend/zend.h)如下：</p>
<pre><code>struct _zval_struct{
    /<span class="keyword">*</span>变量信息<span class="keyword">*</span>/
    zvalue_value value; /<span class="keyword">*</span>存储变量的值<span class="keyword">*</span>/
    zend_uint refcount__gc; /<span class="keyword">*</span>引用次数<span class="keyword">*</span>/
    zend_uchar type     /<span class="keyword">*</span>变量的类型<span class="keyword">*</span>/
    zend_uchar is_ref__gc;  /<span class="keyword">*</span>是否引用<span class="keyword">*</span>/
}zval;
</code></pre><p>其中zval中type的作用就是用来标示不同的类型，它的值可以为：IS_LONG,IS_DOUBLE,IS_STRING,IS_BOOL，IS_ARRAY,IS_OBJECT，IS_RESOURCE,IS_NULL    。</p>
<h4 id="2-变量的值">2.变量的值</h4><p>之前提到的zval中的成员变量value（zvalue_value)就是变量值实际存储的地方，zvalue_value 的结果如下：</p>
<pre><code><span class="keyword">typedef</span> <span class="keyword">union</span> _zvalue_value{
    <span class="keyword">long</span> lval;
    <span class="keyword">double</span> dval;
    <span class="keyword">struct</span>{
        <span class="keyword">char</span> *val;
        <span class="keyword">int</span> len;
    } str;         <span class="comment">/*字符串*/</span>
    HashTable *ht;    <span class="comment">/*数组*/</span>
    zend_object_value obj;  <span class="comment">/*对象*/</span>
    zend_ast *ast;    <span class="comment">/*抽象语法树*/</span>
}zvalue_value;
</code></pre><p>由于一个变量只能是一种类型,所以变量实际存储的结构zvalue_value,采用联合体的结构，这样可以避免浪费大量内存。<br>zvalue_value 中各个成员负责存储不同的变量，整型和布尔值在存储在zvalue_value.lval；dval存储浮点数； str存储字符串；ht 负责存储数组； obj和ast分别存储对象和语法树。</p>
<h4 id="-array（数组）">.array（数组）</h4><p>数组在PHP是一种很强大的变量，因为PHP为数组提供了丰富的内置函数，同时还可以存储其它类型的变量。PHP数组的强大依赖于哈希表，一种高效的键值对存储结构。在PHP中，处处可见哈希表的存在，从变量的作用域到函数表(active_table)和对象等。</p>
<h4 id="Object（对象）">Object（对象）</h4><pre><code>typedef struct <span class="number">_</span>zend<span class="number">_</span><span class="keyword">object</span><span class="number">_</span><span class="keyword">value</span>{
    zend<span class="number">_</span><span class="keyword">object</span><span class="number">_</span>handle handle;  <span class="comment">//对象在对象池中的索引</span>
    zend<span class="number">_</span><span class="keyword">object</span><span class="number">_</span>handlers *handlers;
}
</code></pre><p>EG宏，一个全局结构体用于保存在运行时的数据。 PHP的对象只有在运行时才会被创建，其中就包括了用来保存所有被创建的对象的对象池EG(objects_store)，而handle域就是当前对象在对象池中所在的索引，handlers字段则是将对象进行操作时的处理函数保存起来。 这个结构体及对象相关的类的结构_zend_class_entry。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="弱变量_ZVAL_HashTable"><strong>弱变量</strong>  <strong>ZVAL</strong>  <strong>HashTable</strong></h3><p>PHP是解释性语言，同时也是拥有弱变量类型的语言.</p>
<h4]]>
    </summary>
    
      <category term="PHP内核 变量" scheme="http://www.flydream.org/tags/PHP%E5%86%85%E6%A0%B8-%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hello World]]></title>
    <link href="http://www.flydream.org/2015/08/03/hello-world/"/>
    <id>http://www.flydream.org/2015/08/03/hello-world/</id>
    <published>2015-08-03T15:13:03.000Z</published>
    <updated>2015-08-03T15:13:03.000Z</updated>
    <content type="html"><![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="http://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick_Start">Quick Start</h2><h3 id="Create_a_new_post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run_server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate_static_files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy_to_remote_sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="http://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Welcome to <a href="http://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="http://hexo.io]]>
    </summary>
    
  </entry>
  
</feed>