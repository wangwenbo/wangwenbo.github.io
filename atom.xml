<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Web PHP]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://www.flydream.org/"/>
  <updated>2016-03-08T23:56:47.000Z</updated>
  <id>http://www.flydream.org/</id>
  
  <author>
    <name><![CDATA[阳关冰上]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[初识nginx模块]]></title>
    <link href="http://www.flydream.org/2016/03/06/about-nginx-module/"/>
    <id>http://www.flydream.org/2016/03/06/about-nginx-module/</id>
    <published>2016-03-06T15:14:36.000Z</published>
    <updated>2016-03-08T23:56:47.000Z</updated>
    <content type="html"><![CDATA[<h3 id="nginx的配置结构">nginx的配置结构</h3><p>nginx的核心是配置也就是nginx.conf的文件，nginx的配置大致可以分为如下几类：events，<br>http，server，location等几类配置块，而且http中可以嵌套server，location；除此之外，具体的配置内容会涉及内存、磁盘分配，mime类型，虚拟主机和请求分发等内容，就不再详细列举啦，可以阅读一下《Nginx模块开发与架构解析》的第二章内容。实例：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> &#10;#user  nobody;&#10;worker_processes  1;   &#10;&#10;#error_log  logs/error.log;         &#10;#error_log  logs/error.log  notice;  //logs/error.log:&#38169;&#35823;&#26085;&#24535;&#36335;&#24452; notice:&#38169;&#35823;&#31867;&#22411;&#10;#error_log  logs/error.log  info;&#10;&#10;#pid        logs/nginx.pid;   //master&#36827;&#31243;&#25991;&#20214;&#10;&#10;&#10;events &#123;&#10;   &#9;worker_connections  1024;&#10;&#125;&#10;&#10;&#10;http &#123;&#10;   &#9;include       mime.types;&#10;   &#9;default_type  application/octet-stream;&#10;&#10;   &#9;sendfile        on;&#10;   &#9;#tcp_nopush     on;&#10;&#10;   &#9;#keepalive_timeout  0;&#10;   &#9;keepalive_timeout  65;&#10;&#10;   &#9;#gzip  on;&#10;&#10;   server &#123;&#10;       listen       80;&#10;       server_name  localhost;&#10;&#10;       #charset koi8-r;&#10;&#10;       #access_log  logs/host.access.log  main;&#10;&#10;       location / &#123;&#10;           root   html;&#10;           index  index.html index.htm;&#10;       &#125;&#10;&#10;       #error_page  404              /404.html;&#10;&#10;       # redirect server error pages to the static page /50x.html&#10;       #&#10;       error_page   500 502 503 504  /50x.html;&#10;       location = /50x.html &#123;&#10;           root   html;&#10;       &#125;&#10;&#10;   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="nginx模块的工作原理">nginx模块的工作原理</h3><p>针对http模块，nginx在接到一个http请求后，它会查找配置文件映射到对应的location块，然后根据location中配置的指令去启动不同的模块，再详细的的说这些模块中一个是handler模块和多个filter模块。handler模块负责处理和生成响应内容，filter模块负责过滤响应内容，就提的流程图：(此流程图来自：<a href="http://blog.codinglabs.org/articles/intro-of-nginx-module-development.html" target="_blank" rel="external">http://blog.codinglabs.org/articles/intro-of-nginx-module-development.html</a>)<br><img src="http://wangwenbo.github.io/image/nginx1.png" alt="nginx1 png"></p>
<h3 id="我们自己的http模块">我们自己的http模块</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#10;location /test&#123;&#10;&#9;wwb;&#10;&#125;</span><br></pre></td></tr></table></figure>
<p>一个http模块的功能实现需要：<br>1.读入配置文件中的指令<br>2.http包装<br>3.响应结果</p>
<h4 id="模块配置结构体">模块配置结构体</h4><p>ngnix模块配置结构的命名规则ngx<em>http</em>[module-name]_[main|srv|loc]_conf_t, 其中main，server，location分别代表不同的配置块和层级，具体到这里我们的配置结构体命名为：ngx_http_wwb_loc_conf_t:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typdef <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="keyword">ngx_str_t</span> ed;</span><br><span class="line">&#125; <span class="keyword">ngx_http_wwb_loc_conf_t</span>;</span><br></pre></td></tr></table></figure>
<p>当配置中出现wwb时，nginx就会调用对应的ngx_http_wwb方法,在这个方法中我们可以重置handler方法，指向我们自定义模块的handler方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> * <span class="title">ngx_http_wwb</span><span class="params">(ngx_conf_t *cf, ngx_command_t *cmd, <span class="keyword">void</span> *conf)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   	<span class="keyword">ngx_http_core_loc_conf_t</span>  *clcf;</span><br><span class="line">   	clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);</span><br><span class="line">   	<span class="comment">/* HTTP框架在处理用户请求进行到NGX_HTTP_CONNENT_PHASE阶段是，如果请求的主机域名、URI与wwb配置项所在的配置块匹配，就将调用我们实现的ngx_http_wwb_handler方法处理这个请求 */</span></span><br><span class="line">   	clcf-&gt;handler = ngx_http_wwb_handler;</span><br><span class="line">   	ngx_conf_set_str_slot(cf,cmd,conf);</span><br><span class="line">   	<span class="keyword">return</span> NGX_CONF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义模块">自定义模块</h4><p>我们自定义的模块也要加入到ngx_modules这个全局数组中，在Nginx启动时，自定义模块和其他模块一起初始化。这包含两个结构体：ngx_http_wwb_module_ctx和ngx_http_wwb_module,如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Http context of the module */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">ngx_http_module_t</span>  ngx_http_wwb_module_ctx = &#123;</span><br><span class="line">   	<span class="literal">NULL</span>,                                  <span class="comment">/* preconfiguration */</span></span><br><span class="line">   	<span class="literal">NULL</span>,                                  <span class="comment">/* postconfiguration */</span></span><br><span class="line">   	<span class="literal">NULL</span>,                                  <span class="comment">/* create main configuration */</span></span><br><span class="line">   	<span class="literal">NULL</span>,                                  <span class="comment">/* init main configuration */</span></span><br><span class="line">   	<span class="literal">NULL</span>,                                  <span class="comment">/* create server configuration */</span></span><br><span class="line">   	<span class="literal">NULL</span>,                                  <span class="comment">/* merge server configuration */</span></span><br><span class="line">   	ngx_http_wwb_create_loc_conf,         <span class="comment">/* create location configration */</span></span><br><span class="line">   	ngx_http_echo_merge_loc_conf           <span class="comment">/* merge location configration */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Module */</span></span><br><span class="line"><span class="keyword">ngx_module_t</span>  ngx_http_wwb_module = &#123;</span><br><span class="line">  	 	NGX_MODULE_V1,</span><br><span class="line">   	&amp;ngx_http_wwb_module_ctx,              <span class="comment">/* module context */</span></span><br><span class="line">   	ngx_http_wwb_commands,                 <span class="comment">/* module directives */</span></span><br><span class="line">   	NGX_HTTP_MODULE,                       <span class="comment">/* module type */</span></span><br><span class="line">   	<span class="literal">NULL</span>,                                  <span class="comment">/* init master */</span></span><br><span class="line">   	<span class="literal">NULL</span>,                                  <span class="comment">/* init module */</span></span><br><span class="line">   	<span class="literal">NULL</span>,                                  <span class="comment">/* init process */</span></span><br><span class="line">   	<span class="literal">NULL</span>,                                  <span class="comment">/* init thread */</span></span><br><span class="line">   	<span class="literal">NULL</span>,                                  <span class="comment">/* exit thread */</span></span><br><span class="line">  	 	<span class="literal">NULL</span>,                                  <span class="comment">/* exit process */</span></span><br><span class="line">   	<span class="literal">NULL</span>,                                  <span class="comment">/* exit master */</span></span><br><span class="line">   	NGX_MODULE_V1_PADDING</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="合并配置项">合并配置项</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">ngx_http_wwb_create_loc_conf</span><span class="params">(ngx_conf_t *cf)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   	<span class="keyword">ngx_http_wwb_loc_conf_t</span>  *conf;</span><br><span class="line">   	conf = ngx_pcalloc(cf-&gt;pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_http_wwb_loc_conf_t</span>));</span><br><span class="line">  	 	<span class="keyword">if</span> (conf == <span class="literal">NULL</span>) &#123;</span><br><span class="line">       	<span class="keyword">return</span> NGX_CONF_ERROR;</span><br><span class="line">   	&#125;</span><br><span class="line">   	conf-&gt;ed.len = <span class="number">0</span>;</span><br><span class="line">   	conf-&gt;ed.data = <span class="literal">NULL</span>;</span><br><span class="line">   	<span class="keyword">return</span> conf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> * <span class="title">ngx_http_wwb_merge_loc_conf</span><span class="params">(ngx_conf_t *cf, <span class="keyword">void</span> *parent, <span class="keyword">void</span> *child)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   	<span class="keyword">ngx_http_wwb_loc_conf_t</span> *prev = parent;</span><br><span class="line">   	<span class="keyword">ngx_http_wwb_loc_conf_t</span> *conf = child;</span><br><span class="line">   	ngx_conf_merge_str_value(conf-&gt;ed, prev-&gt;ed, <span class="string">""</span>);</span><br><span class="line">   	<span class="keyword">return</span> NGX_CONF_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义模块的handler方法">自定义模块的handler方法</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/* Handler function */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ngx_int_t <span class="title">ngx_http_wwb_handler</span><span class="params">(ngx_http_request_t *r)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">   <span class="keyword">ngx_int_t</span> rc;</span><br><span class="line">   <span class="keyword">ngx_buf_t</span> *b;  <span class="comment">//构造ngx_bug_t准备发送包体</span></span><br><span class="line">   <span class="keyword">ngx_chain_t</span> out;  <span class="comment">//构造发送时的ngx_chain_t结构体</span></span><br><span class="line">   <span class="keyword">ngx_http_echo_loc_conf_t</span> *elcf;</span><br><span class="line">   elcf = ngx_http_get_module_loc_conf(r, ngx_http_wwb_module);</span><br><span class="line">   <span class="keyword">if</span>(!(r-&gt;method &amp; (NGX_HTTP_HEAD|NGX_HTTP_GET|NGX_HTTP_POST)))</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> NGX_HTTP_NOT_ALLOWED;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//设置响应</span></span><br><span class="line">   r-&gt;headers_out.content_type.len = <span class="keyword">sizeof</span>(<span class="string">"text/html"</span>) - <span class="number">1</span>;</span><br><span class="line">   r-&gt;headers_out.content_type.data = (u_char *) <span class="string">"text/html"</span>;</span><br><span class="line">   r-&gt;headers_out.status = NGX_HTTP_OK;</span><br><span class="line">   r-&gt;headers_out.content_length_n = elcf-&gt;ed.len;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">//发送http头部</span></span><br><span class="line">   <span class="keyword">if</span>(r-&gt;method == NGX_HTTP_HEAD)</span><br><span class="line">   &#123;</span><br><span class="line">       rc = ngx_http_send_header(r);</span><br><span class="line">       <span class="keyword">if</span>(rc != NGX_OK)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">return</span> rc;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//将要发送的包体内容写入ngx_buf_t结构体</span></span><br><span class="line">   b = ngx_pcalloc(r-&gt;pool, <span class="keyword">sizeof</span>(<span class="keyword">ngx_buf_t</span>));</span><br><span class="line">   <span class="keyword">if</span>(b == <span class="literal">NULL</span>)</span><br><span class="line">   &#123;</span><br><span class="line">       ngx_log_error(NGX_LOG_ERR, r-&gt;connection-&gt;<span class="built_in">log</span>, <span class="number">0</span>, <span class="string">"Failed to allocate response buffer."</span>);</span><br><span class="line">       <span class="keyword">return</span> NGX_HTTP_INTERNAL_SERVER_ERROR;</span><br><span class="line">   &#125;</span><br><span class="line">   out.buf = b;</span><br><span class="line">   out.next = <span class="literal">NULL</span>;</span><br><span class="line">   b-&gt;pos = elcf-&gt;ed.data;</span><br><span class="line">   b-&gt;last = elcf-&gt;ed.data + (elcf-&gt;ed.len);</span><br><span class="line">   b-&gt;memory = <span class="number">1</span>;</span><br><span class="line">   b-&gt;last_buf = <span class="number">1</span>;</span><br><span class="line">   rc = ngx_http_send_header(r);</span><br><span class="line">   <span class="keyword">if</span>(rc != NGX_OK)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">return</span> rc;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//调用过滤模块，过滤响应内容</span></span><br><span class="line">   <span class="keyword">return</span> ngx_http_output_filter(r, &amp;out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参考文献：<br>1.《深入理解Nginx 模块开发与架构设计（第二版）》<br>2.<a href="http://blog.codinglabs.org/articles/intro-of-nginx-module-development.html" target="_blank" rel="external">http://blog.codinglabs.org/articles/intro-of-nginx-module-development.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="nginx的配置结构">nginx的配置结构</h3><p>nginx的核心是配置也就是nginx.conf的文件，nginx的配置大致可以分为如下几类：events，<br>http，server，location等几类配置块，而且http中可以嵌套server]]>
    </summary>
    
      <category term="配置nginx.conf" scheme="http://www.flydream.org/tags/%E9%85%8D%E7%BD%AEnginx-conf/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初识redis]]></title>
    <link href="http://www.flydream.org/2016/02/28/about-redis/"/>
    <id>http://www.flydream.org/2016/02/28/about-redis/</id>
    <published>2016-02-28T00:17:40.000Z</published>
    <updated>2016-02-29T23:47:10.000Z</updated>
    <content type="html"><![CDATA[<h3 id="事务与WATCH">事务与WATCH</h3><p>每次上线新功能都会经过开发完成，测试通过和运维发布这样一个过程，中间任何一个步骤出错这次发布就算失败，它们其实是一件事情：“成功发布上线”。</p>
<p>redis的事务大概也就是上面的这个意思，一些redis命令组合在一起一次执行，它们是一体的。<br>redis的事务以multi这个特殊命令开始，以exec结束。</p>
<p>redis事务的原理：设置一个标识告诉redis不要立即执行命令而是将它们存入一个队列，在特定时刻依次全部执行。</p>
<p>第一步设置事务标识：multi</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">multiCommond</span><span class="params">(redisClient *c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(c-&gt;flags &amp; REDIS_MULTI&#123;</span><br><span class="line">		<span class="comment">//出错</span></span><br><span class="line">		<span class="keyword">return</span>；</span><br><span class="line">	&#125;</span><br><span class="line">	c-&gt;flags |= REDIS_MULTI;  <span class="comment">//设置事务标识</span></span><br><span class="line">	<span class="comment">//.....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步将命令入队：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">processCommand</span><span class="params">(redisClient *c)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(c-&gt;flags &amp; REDIS_MULTI &amp;&amp; c-&gt;cm-&gt;proc!=discardCommand </span><br><span class="line">		&amp;&amp; c-&gt;cm-&gt;proc!=execCommand </span><br><span class="line">		&amp;&amp; c-&gt;cm-&gt;proc!=multiCommand </span><br><span class="line">		&amp;&amp; c-&gt;cm-&gt;proc!=watchCommand)&#123;</span><br><span class="line">			queueMultiCommand(c);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="comment">//..........</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第二步中，其中有四个特殊命令无需入队，它们分别是discard，watch，exec，multi；后面我们会再说到discard和watch，至于exec和multi就不用多说啦。</p>
<p>第三步执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">execCommand</span><span class="params">(redisClient *c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">	<span class="comment">//......</span></span><br><span class="line">	<span class="preprocessor">###执行队列中的命令</span></span><br><span class="line">	<span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;c-&gt;mstate.count;j++)&#123;</span><br><span class="line">		c-&gt;argc = c-&gt;mstate.commands[j].argc;</span><br><span class="line">		c-&gt;argv = c-&gt;mstate.commands[j].argv;</span><br><span class="line">		c-&gt;cmd = c-&gt;mstate.commands[j].cmd;</span><br><span class="line">		</span><br><span class="line">		call(c); <span class="preprocessor">###执行命令</span></span><br><span class="line">		</span><br><span class="line">		c-&gt;mstate.commands[j].argc =c-&gt;argc ;</span><br><span class="line">		c-&gt;mstate.commands[j].argv = c-&gt;argv;</span><br><span class="line">		c-&gt;mstate.commands[j].cmd = c-&gt;cmd;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//.....</span></span><br><span class="line">	<span class="preprocessor">###释放队列</span></span><br><span class="line">	freeClientMultiState(c);</span><br><span class="line">	initClientMultiState(c);</span><br><span class="line">	</span><br><span class="line">	<span class="preprocessor">###去除事务标识</span></span><br><span class="line">	c-&gt;flag &amp; = ~(REDIS_MULTI | REIDS_DIRTY_CAS)</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过事务，redis可以延迟命令的执行减少链接次数提高效率，但在保持数据一致上还需要watch的配合，我们可以对一个或多个键值监视，一旦发生变化之后的事务执行就算失败。通过这种机制来保证数据的正确。discard可以来取消监视，在multi和exec命令之间执行会同时取消监视和事务。</p>
<h3 id="虚拟内存VM">虚拟内存VM</h3><p>内存空间总会有用尽的可能，虚拟内存就是将redis的键(key)依然保存在内存但键对应的值(value)则从内存置换到磁盘，参数配置如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">vm-enabled yes               <span class="preprocessor">#开启VM</span></span><br><span class="line">vm-swap-file /tmp/redis.swap <span class="preprocessor">#value保存的文件路径</span></span><br><span class="line">vm-max-memory <span class="number">12345</span>          <span class="preprocessor">#redsi的内存上限，超过就将value置换到磁盘</span></span><br><span class="line">vm-page-size  <span class="number">32</span>             <span class="preprocessor">#设置每页大小<span class="number">32</span>字节</span></span><br><span class="line">vm-pages   <span class="number">100000</span>            <span class="preprocessor">#swap文件中使用多少页面</span></span><br><span class="line">vm-max-threads <span class="number">4</span>             <span class="preprocessor">#用于执行换出的工作线程数量， <span class="number">0</span>：不使用工作线程</span></span><br></pre></td></tr></table></figure>
<h5 id="非阻塞式VM">非阻塞式VM</h5><p>当我们以非阻塞方式去访问一个已经被置换到磁盘的数据时，处理过程大致如下：此时的redis有一个主线程和I/O线程，先将这个I/O任务放入server.io_newjobs 队列，之后I/O线程来处理这个任务，完成后将这个任务放入server.io_processed队列并发信号给主线程。</p>
<p>I/O任务对象的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> iojob&#123;</span><br><span class="line">	<span class="keyword">int</span> type;    <span class="preprocessor">### 任务类型（</span></span><br><span class="line">	redisDb *db; <span class="preprocessor">### 数据库</span></span><br><span class="line">	robj *key；  <span class="preprocessor">### 键值</span></span><br><span class="line">	.........</span><br><span class="line">	<span class="keyword">off_t</span> page;  <span class="preprocessor">### 对象所在的页</span></span><br><span class="line">	<span class="keyword">off_t</span> pages; <span class="preprocessor">### 对象占用了多少页</span></span><br><span class="line">	<span class="keyword">int</span> canceled; <span class="preprocessor">### 任务是否取消</span></span><br><span class="line">	<span class="keyword">pthread_t</span> thread; <span class="preprocessor">### 线程ID</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中iojob的type值：REDIS_IOJOB_LOAD：从swap加载到内存； REDIS_IOJOB_PREPARE_SWAP 计算从保存到swap需要多少页 REDIS_IOJOB_DO_SWAP：将值置换到swap。</p>
<p>参考文献：《Redis IN ACTIOIN》 《php核心技术与最佳实践》</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="事务与WATCH">事务与WATCH</h3><p>每次上线新功能都会经过开发完成，测试通过和运维发布这样一个过程，中间任何一个步骤出错这次发布就算失败，它们其实是一件事情：“成功发布上线”。</p>
<p>redis的事务大概也就是上面的这个意思，一些redis]]>
    </summary>
    
      <category term="事务  虚拟内存(VM) 非阻塞VM" scheme="http://www.flydream.org/tags/%E4%BA%8B%E5%8A%A1-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98-vm-%E9%9D%9E%E9%98%BB%E5%A1%9Evm/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[http 缓存]]></title>
    <link href="http://www.flydream.org/2016/02/13/http-cache/"/>
    <id>http://www.flydream.org/2016/02/13/http-cache/</id>
    <published>2016-02-13T07:36:40.000Z</published>
    <updated>2016-02-29T23:48:07.000Z</updated>
    <content type="html"><![CDATA[<p>HTTP协议缓存的目标是去除许多情况下对于发送请求的需求和去除许多情况下发送完整请求的需求。以不发送请求或减少请求传输的数据量来优化整个HTTP架构，此目标的实现可以产生如下好处：</p>
<ul>
<li>减少网络传输的冗余信息量</li>
<li>缓解网络瓶颈的问题</li>
<li>降低对原始服务器的请求量</li>
<li>减少了传送距离，降低了因为距离而产生的时延</li>
</ul>
<p>缓存基本处理过程包括七个步骤。</p>
<p>1.接收 – 缓存从网络中读取抵达的请求报文<br>2.解析 – 缓存对报文进行解析，提取出URL和各种首部<br>3.查询 – 缓存查看是否有本地副本可用，如果没有，就获取一份副本，并保存在本地<br>4.新鲜度检测 – 缓存查看已缓存副本是否足够新鲜，如果不是，就询问服务器是否有任何更新<br>5.创建响应 – 缓存会用新的首部和已缓存主体来构建一条响应报文<br>6.发送 – 缓存通过网络将响应发回给客户端<br>7.日志 – 缓存可选地创建一个日志文件条目来描述这个事务</p>
<p>这里的缓存可以是本地客户端缓存，也可以是代理缓存之类的公共缓存。</p>
<h4 id="HTTP缓存模型">HTTP缓存模型</h4><p>HTTP缓存可以在不依赖服务器记住有哪些缓存拥有文档副本，而实现文档的一致。这些机制称为文档过期（document expiration）和服务器再验证（server revalidation），也可以称它们为截止模型和证实模型。</p>
<p>截止模型是HTTP请求中带上标记文档的过期时间，HTTP协议中使用如下两个字段标记过期时间：</p>
<ul>
<li>Expires字段 – 指定一个绝对的过期日期。</li>
<li><p>Cache-control:max-age – 定义文档的最大使用期，从第一次生成文档到文档不再新鲜，无法使用为止，最大的合法生存时间（单位为s）<br>仅仅使用截止模型还不够，即使文档过期了，也并不意味着当前文档和原始服务器的文档不一致了。此时就到证实模型大显身手的时候了。证实模型需要询问原始服务器文档是否发生了变化。其依赖于HTTP协议的如下字段：</p>
</li>
<li><p>If-Modified-Since字段 – 如果从指定日期之后文档被修改了，就执行请求的方法。可以与 Last-modified服务器响应首部配合使用。它告诉服务器只有在客户端缓存了对象的副本后，又服务器对其进行了修改的情况下，才在回复中发送此对象。如果服务器对象没有修改，返回304 Not Modified。如果服务器修改了此对象，发送此对象，返回200 OK。如果服务器删除了些对象，返回404 Not Found。</p>
</li>
<li>If-None-Match字段 – 服务器可以为文档提供特殊的标签（ETag），如果此标签与服务器的标签不一样，就会执行请求的方法。<br>如果服务器应答中包括一个ETag，又包括一个Last-Mofidied值，则客户端在发送请求时使用两种证实机制，并且只有当两种证实机制都满足时才会返回304 Not Modified。</li>
</ul>
<p>参看文献：《http权威指南》</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>HTTP协议缓存的目标是去除许多情况下对于发送请求的需求和去除许多情况下发送完整请求的需求。以不发送请求或减少请求传输的数据量来优化整个HTTP架构，此目标的实现可以产生如下好处：</p>
<ul>
<li>减少网络传输的冗余信息量</li>
<li>缓解网络瓶颈的问题</]]>
    </summary>
    
      <category term="http cache" scheme="http://www.flydream.org/tags/http-cache/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[TSRM(线程安全)]]></title>
    <link href="http://www.flydream.org/2016/02/11/TSRM/"/>
    <id>http://www.flydream.org/2016/02/11/TSRM/</id>
    <published>2016-02-11T09:39:12.000Z</published>
    <updated>2016-02-12T02:50:53.000Z</updated>
    <content type="html"><![CDATA[<h3 id="TRSM的宏">TRSM的宏</h3><p>在查看源码的时经常会看到一个函数的参数中有这样一个宏TSRMLS_CC,而TSRMLS_CC表示启用线程安全。单线程中不存在线程安全的问题，但在多线程中这却是个问题，一个扩展启动后可能会被多个独立的请求同时调用。先看一下启用线程安全的宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TSRMLS_D	void ***tsrm_ls</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TSRMLS_DC	, TSRMLS_D</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TSRMLS_C	tsrm_ls</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> TSRMLS_CC	, TSRMLS_C</span></span><br></pre></td></tr></table></figure>
<h3 id="扩展中的线程安全">扩展中的线程安全</h3><h4 id="申明全局变量">申明全局变量</h4><p>扩展中需要线程安全是因为其中有全局变量，扩展中申明全局变量的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">ZEND_BEGIN_MODULE_GLOBALS(wwb)</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> counter;</span><br><span class="line">ZEND_END_MODULE_GLOBALS(wwb)</span><br></pre></td></tr></table></figure>
<p>上述扩展wwb中的全局变量的生成是通过ZEND_BEGIN/END_MODULE_GLOBALS的宏来实现的，它展开如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _zend_wwb_globals&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> counter;</span><br><span class="line">&#125; zend_wwb_globals wwb_globals</span><br></pre></td></tr></table></figure>
<h4 id="对全局变量的访问（线程安全与非线程安全）">对全局变量的访问（线程安全与非线程安全）</h4><p>其生命周期随着模块(MINIT)/请求（RINIT）的开始，随着MSHUTDOWN/RSHUTDOWN而结束。针对线程安全获取变量通过int wwb_globals_id:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> ZTS</span></span><br><span class="line">	ts_allocate_id(&amp;wwb_globals_id,</span><br><span class="line">		<span class="keyword">sizeof</span>(zend_wwb_globals),</span><br><span class="line">		php_wwb_globals_ctor,php_wwb_globals_dctor);</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>分配的地址存储在vector中，通过wwb_globlas_id来索引；通过两个回调函数来完成初始化和资源回收。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">php_wwb_globals_ctor</span><span class="params">(zend_wwb_globals * wwb_globals TSRMLS_DC)</span></span>&#123;</span><br><span class="line">	wwb_globals-&gt;counter = <span class="number">0</span>;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">php_wwb_globals_dtor</span><span class="params">(zend_wwb_globals * wwb_globals TSRMLS_DC)</span></span>&#123;</span><br><span class="line">	<span class="comment">/*初始化时申请的资源 在在此处释放*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在非线程安全的情况下，直接访问wwb_globals。</p>
<p>最后来看一下，模块变量到底是何时启动和关闭的,上述内容是如何发挥作用的:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PHP_MINIT_FUNCTION(wwb)&#123;</span><br><span class="line">	<span class="preprocessor">#<span class="keyword">ifdef</span> ZTS</span></span><br><span class="line">		ts_allocate_id(&amp;wwb_globals_id,</span><br><span class="line">			<span class="keyword">sizeof</span>(zend_wwb_globals),</span><br><span class="line">			(ts_allocate_ctor)php_wwb_globals_ctor,</span><br><span class="line">			(ts_allocate_dtor)php_wwb_globals_dtor);</span><br><span class="line">	<span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line">		php_wwb_globals_ctor(&amp;wwb_globals TSRMLS_CC)</span><br><span class="line">	<span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">return</span> SUCCESS;							</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PHP_MSHUTDOWN_FUNCTION(wwb)&#123;</span><br><span class="line">	<span class="preprocessor">#<span class="keyword">ifdef</span> ZTS</span></span><br><span class="line">		php_wwb_globals_dtor(&amp;wwb_globals TSRMLS_CC);</span><br><span class="line">	<span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">		<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>额外的补充一下：如何操作全局变量，不能像上面的代码一样每次ifdef的判断,  可以在php_wwb.h的头文件中定义宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> ZTS</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">include</span> <span class="string">"TRSRM.h"</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> WWB_G(v)  TSRMG(wwb_globals_id,zend_wwb_globals*,v)</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">else</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> WWB_G(v)  (wwb_globals.v)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>其中v是zend_wwb_globals中的成员变量。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="TRSM的宏">TRSM的宏</h3><p>在查看源码的时经常会看到一个函数的参数中有这样一个宏TSRMLS_CC,而TSRMLS_CC表示启用线程安全。单线程中不存在线程安全的问题，但在多线程中这却是个问题，一个扩展启动后可能会被多个独立的请求同时调用。先看一下]]>
    </summary>
    
      <category term="线程安全 全局变量" scheme="http://www.flydream.org/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP内核学习--curl]]></title>
    <link href="http://www.flydream.org/2016/01/03/%E7%BD%91%E7%BB%9C%E5%87%BD%E6%95%B0-curl/"/>
    <id>http://www.flydream.org/2016/01/03/网络函数-curl/</id>
    <published>2016-01-03T13:28:58.000Z</published>
    <updated>2016-01-17T13:09:20.000Z</updated>
    <content type="html"><![CDATA[<h3 id="curl">curl</h3><p>curl函数使我们经常用到的网络函数之一，通过这篇文章了解curl的内部原理和php的生命周期（cli）。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="variable">$cn</span> = curl_init();</span><br><span class="line">curl_setopt(<span class="variable">$cn</span>,CURLOPT_URL,<span class="string">"www.baidu.com"</span>);</span><br><span class="line"><span class="variable">$res</span> = curl_exec(<span class="variable">$cn</span>);</span><br><span class="line"><span class="variable">$info</span> n= curl_getinfo(<span class="variable">$cn</span>);</span><br><span class="line"></span><br><span class="line">print_r(<span class="variable">$res</span>);</span><br><span class="line">print_r(<span class="string">"=========\n"</span>);</span><br><span class="line">print_r(<span class="variable">$info</span>);</span><br></pre></td></tr></table></figure>
<p>当我们以cli模式执行时，通过gdb我们可以看到内核执行过程。<br>首先，在zi_curl_inits设置断点，执行后断点处信息：zif_curl_init (ht=0, return_value=0x100eba798, return_value_ptr=0x100e854d0, this_ptr=0x0,<br>    return_value_used=1, tsrm_ls=0x100f01ae0) at ext/curl/interface.c:1950；</p>
<p>然后，进入curl_init函数源码，step/next调试源码，执行完curl_init源码后。</p>
<p>紧接着，执行zend_do_fcall_common_helper_SPEC (execute_data=0x100e854e8, tsrm_ls=0x100f01ae0)<br>    at Zend/zend_vm_execute.h:559</p>
<p>最后，execute_ex (execute_data=0x100e854e8, tsrm_ls=0x100f01ae0) at Zend/zend_vm_execute.h:355， 在这里执行opline。</p>
<p>之后的curl_exec,curl_getinfo,都重复着这个过程。</p>
<p>下面来看，具体的过程：<br>curl_init 初始化要做的就是初始化一个cURL的session，涉及到两个比较重要的结构体：CURL和php_curl，下面先列出相关的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="keyword">struct</span> _php_curl_error   err;</span><br><span class="line">	<span class="keyword">struct</span> _php_curl_free    *to_free;</span><br><span class="line">	<span class="keyword">struct</span> _php_curl_send_headers header;</span><br><span class="line">	<span class="keyword">void</span> ***thread_ctx;</span><br><span class="line">	CURL                    *cp;</span><br><span class="line">	php_curl_handlers       *handlers;</span><br><span class="line">	<span class="keyword">long</span>                     id;</span><br><span class="line">	zend_bool                in_callback;</span><br><span class="line">	zval                     *clone;</span><br><span class="line">	zend_bool                safe_upload;</span><br><span class="line">&#125; php_curl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	zval            *func_name;</span><br><span class="line">	zend_fcall_info_cache fci_cache;</span><br><span class="line">	FILE            *fp;</span><br><span class="line">	smart_str       buf;</span><br><span class="line">	<span class="keyword">int</span>             method;</span><br><span class="line">	zval		*stream;</span><br><span class="line">&#125; php_curl_write;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	zval            *func_name;</span><br><span class="line">	zend_fcall_info_cache fci_cache;</span><br><span class="line">	FILE            *fp;</span><br><span class="line">	<span class="keyword">long</span>            fd;</span><br><span class="line">	<span class="keyword">int</span>             method;</span><br><span class="line">	zval		*stream;</span><br><span class="line">&#125; php_curl_read;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	zval 		*func_name;</span><br><span class="line">	zend_fcall_info_cache fci_cache;</span><br><span class="line">	<span class="keyword">int</span>    	        method;</span><br><span class="line">&#125; php_curl_progress, php_curl_fnmatch;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">	php_curl_write *write;</span><br><span class="line">	php_curl_write *write_header;</span><br><span class="line">	php_curl_read  *read;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> CURLOPT_PASSWDFUNCTION != <span class="number">0</span></span></span><br><span class="line">	zval           *passwd;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">	zval           *std_err;</span><br><span class="line">	php_curl_progress *progress;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">if</span> LIBCURL_VERSION_NUM &gt;= <span class="number">0x071500</span> <span class="comment">/* Available since 7.21.0 */</span></span></span><br><span class="line">	php_curl_fnmatch  *fnmatch;</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br><span class="line">&#125; php_curl_handlers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _php_curl_error  &#123;</span><br><span class="line">	<span class="keyword">char</span> str[CURL_ERROR_SIZE + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span>  no;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _php_curl_send_headers &#123;</span><br><span class="line">	<span class="keyword">char</span> *str;</span><br><span class="line">	<span class="keyword">size_t</span> str_len;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _php_curl_free &#123;</span><br><span class="line">	zend_llist str;</span><br><span class="line">	zend_llist post;</span><br><span class="line">	HashTable *slist;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>完成初始化，资源的申请之后，我们要设置参数：curl_setopt,在curl_setopt的执行中ZEND_FETCH_RESOURCE是重要的一步:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PHP_FUNCTION(curl_setopt)</span><br><span class="line">&#123;</span><br><span class="line">zval       *zid, **zvalue;</span><br><span class="line"><span class="keyword">long</span>        options;</span><br><span class="line">php_curl   *ch;</span><br><span class="line"></span><br><span class="line">   ......................</span><br><span class="line">   </span><br><span class="line">ZEND_FETCH_RESOURCE(ch, php_curl *, &amp;zid, -<span class="number">1</span>, le_curl_name, le_curl);</span><br><span class="line"></span><br><span class="line">......................</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (_php_curl_setopt(ch, options, zvalue TSRMLS_CC) == SUCCESS) &#123;</span><br><span class="line">	RETURN_TRUE;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	RETURN_FALSE;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ZEND_FETCH_RESOUCE的执行定位到Zend/zend_list.c:119，其中涉及了zend_list_find:获取资源或者get_active_class_name:获取当前的类等处理过程。</p>
<p>最后，curl_exec执行:<br>zif_curl_exec (ht=1, return_value=0x100ebd520, return_value_ptr=0x100e85470, this_ptr=0x0, return_value_used=1,tsrm_ls=0x100f003e0) at ext/curl/interface.c:2976</p>
<p>以上这些只是 php中curl执行的大致过程，里面还有更多地细节以及现在我也没理解的知识。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="curl">curl</h3><p>curl函数使我们经常用到的网络函数之一，通过这篇文章了解curl的内部原理和php的生命周期（cli）。</p>
<figure class="highlight php"><table><tr><td class="gutt]]>
    </summary>
    
      <category term="curl" scheme="http://www.flydream.org/tags/curl/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[生成器和mysql异步]]></title>
    <link href="http://www.flydream.org/2015/12/22/%E5%8D%8F%E7%A8%8B%E5%92%8Cmysql%E5%BC%82%E6%AD%A5/"/>
    <id>http://www.flydream.org/2015/12/22/协程和mysql异步/</id>
    <published>2015-12-21T23:26:45.000Z</published>
    <updated>2015-12-27T07:18:56.000Z</updated>
    <content type="html"><![CDATA[<h3 id="yield_和_Generator生成器">yield 和 Generator生成器</h3><p>第一个问题：什么是生成器Generator？首先我们可以认为它是一个函数。紧接着第二个问题，这个函数和其它的函数有什么不同吗？不同点在于这个函数是可中断的，返回值是依次返回的，一般函数是一次返回。<br>第三个问题：函数返回值依次返回有什么优点或者用途？ 我们应该都遇到过一次读取一个大文件，内存不够用的情况，函数返回值的依次返回，就不需要一次申请占用很多的内存空间，而且数据可以更快地得到处理而不要等数据全部读取完。</p>
<p>Generator 实现了Iterator接口，所以不要自己去调用去在实现Iterator接口中的next、current、key、rewind和valid等方法。基本用法如下:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span><span class="params">(<span class="variable">$name</span>)</span></span>&#123;</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">"hello, "</span>;</span><br><span class="line">		<span class="keyword">foreach</span>(<span class="variable">$name</span> <span class="keyword">as</span> <span class="variable">$n</span>)&#123;</span><br><span class="line">			 <span class="keyword">yield</span> <span class="variable">$n</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">foreach</span>(sayHello(<span class="keyword">array</span>(<span class="string">"I'm"</span>,<span class="string">" the key"</span>,<span class="string">" yield!"</span>)) <span class="keyword">as</span> <span class="variable">$val</span>)&#123;</span><br><span class="line">	<span class="keyword">echo</span> <span class="variable">$val</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="协程">协程</h4><p>协程即两个程序之间的双向通信，迭代生成器回传数据的功能通过send方法实现，下面通过例子看yield如何即是接受者又是发送:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   	<span class="variable">$ret</span> = (<span class="keyword">yield</span> <span class="string">'yield1'</span>);</span><br><span class="line">   	var_dump(<span class="variable">$ret</span>);</span><br><span class="line">   	<span class="variable">$ret</span> = (<span class="keyword">yield</span> <span class="string">'yield2'</span>);</span><br><span class="line">   	var_dump(<span class="variable">$ret</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$gen</span> = gen();</span><br><span class="line">var_dump(<span class="variable">$gen</span>-&gt;current());    <span class="comment">// string(6) "yield1"</span></span><br><span class="line">var_dump(<span class="variable">$gen</span>-&gt;send(<span class="string">'ret1'</span>)); <span class="comment">// string(4) "ret1"   (the first 	var_dump in gen)</span></span><br><span class="line">                             	<span class="comment">// string(6) "yield2" (the var_dump of the -&gt;send() return value)</span></span><br><span class="line">var_dump(<span class="variable">$gen</span>-&gt;send(<span class="string">'ret2'</span>)); <span class="comment">// string(4) "ret2"   (again from within gen)</span></span><br><span class="line">                             <span class="comment">// NULL               (the return value of -&gt;send())</span></span><br></pre></td></tr></table></figure>
<h3 id="异步mysql">异步mysql</h3><p>mysqlnd (mysql native drive的简写)是php针对mysql驱动的扩展。使用时,编译参数，如下：<br>–with-mysql=mysqlnd<br>–with-mysqli=mysqlnd<br>–with-pdo-mysql=mysqlnd<br>–enable-mysqlnd</p>
<p>mysql的异步化：查询请求和获取返回结果异步执行，mysqlnd提供的方法：mysqlnd_async_query 发送请求，mysqlnd_reap_async_query 获取结果；mysqli的query方法中设置MYSQLI_ASYNC参数。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">db</span></span>&#123;</span><br><span class="line">   	<span class="keyword">static</span> <span class="variable">$links</span>;</span><br><span class="line">   	<span class="keyword">private</span> <span class="variable">$obj</span>;</span><br><span class="line"></span><br><span class="line">   	<span class="function"><span class="keyword">function</span> <span class="title">getConn</span><span class="params">()</span></span>&#123;</span><br><span class="line">       	<span class="variable">$host</span> = <span class="string">'127.0.0.1'</span>;</span><br><span class="line">       	<span class="variable">$user</span> = <span class="string">'root'</span>;</span><br><span class="line">       	<span class="variable">$password</span> = <span class="string">''</span>;</span><br><span class="line">       	<span class="variable">$database</span> = <span class="string">'mysql'</span>;</span><br><span class="line">       	<span class="variable">$this</span>-&gt;obj = <span class="keyword">new</span> mysqli(<span class="variable">$host</span>, <span class="variable">$user</span>, <span class="variable">$password</span>, <span class="variable">$database</span>);</span><br><span class="line">       	<span class="keyword">self</span>::<span class="variable">$links</span>[spl_object_hash(<span class="variable">$this</span>-&gt;obj)] = <span class="variable">$this</span>-&gt;obj;</span><br><span class="line">      	 	<span class="keyword">return</span> <span class="keyword">self</span>::<span class="variable">$links</span>[spl_object_hash(<span class="variable">$this</span>-&gt;obj)];</span><br><span class="line">  		&#125;</span><br><span class="line">  		</span><br><span class="line">  		<span class="function"><span class="keyword">function</span> <span class="title">async_query</span><span class="params">(<span class="variable">$sql</span>)</span></span>&#123;</span><br><span class="line">       	<span class="variable">$link</span> = <span class="variable">$this</span>-&gt;getConn();</span><br><span class="line">       	<span class="variable">$link</span>-&gt;query(<span class="variable">$sql</span>, MYSQLI_ASYNC);  <span class="comment">//异步的查询请求</span></span><br><span class="line">       	<span class="keyword">return</span> <span class="variable">$link</span>;</span><br><span class="line">   	&#125;</span><br><span class="line"></span><br><span class="line">   	<span class="function"><span class="keyword">function</span> <span class="title">fetch</span><span class="params">()</span></span>&#123;</span><br><span class="line">       	<span class="keyword">for</span>(<span class="variable">$i</span> = <span class="number">1</span>; <span class="variable">$i</span> &lt;= <span class="number">5</span>; <span class="variable">$i</span>++)&#123;</span><br><span class="line">          		<span class="variable">$read</span> = <span class="variable">$errors</span> = <span class="variable">$reject</span> = <span class="keyword">self</span>::<span class="variable">$links</span>;</span><br><span class="line">           	<span class="variable">$re</span> = mysqli_poll(<span class="variable">$read</span>, <span class="variable">$errors</span>, <span class="variable">$reject</span>, <span class="number">1</span>);</span><br><span class="line">           	<span class="keyword">foreach</span>(<span class="variable">$read</span> <span class="keyword">as</span> <span class="variable">$obj</span>)&#123;</span><br><span class="line">               	<span class="keyword">if</span>(<span class="variable">$this</span>-&gt;obj === <span class="variable">$obj</span>)&#123;</span><br><span class="line">                   	<span class="variable">$sql_result</span> = <span class="variable">$obj</span>-&gt;reap_async_query(); <span class="comment">//异步获取查询结果</span></span><br><span class="line">                   	<span class="variable">$sql_result_array</span> = <span class="variable">$sql_result</span>-&gt;fetch_array(MYSQLI_ASSOC);<span class="comment">//只有一行</span></span><br><span class="line">                   	<span class="variable">$sql_result</span>-&gt;free();</span><br><span class="line">                   	<span class="keyword">return</span> <span class="variable">$sql_result_array</span>;</span><br><span class="line">               	&#125;</span><br><span class="line">           	&#125;	</span><br><span class="line">       	&#125;</span><br><span class="line">   	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【参考文章】<br><a href="http://www.bo56.com/通过协程实现mysql查询的异步化" target="_blank" rel="external">http://www.bo56.com/通过协程实现mysql查询的异步化</a><br><a href="http://www.laruence.com/2015/05/28/3038.html" target="_blank" rel="external">http://www.laruence.com/2015/05/28/3038.html</a><br><a href="http://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html" target="_blank" rel="external">http://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="yield_和_Generator生成器">yield 和 Generator生成器</h3><p>第一个问题：什么是生成器Generator？首先我们可以认为它是一个函数。紧接着第二个问题，这个函数和其它的函数有什么不同吗？不同点在于这个函数是可中断的，返回值是]]>
    </summary>
    
      <category term="协程 mysql异步 yield generator mysqlnd" scheme="http://www.flydream.org/tags/%E5%8D%8F%E7%A8%8B-mysql%E5%BC%82%E6%AD%A5-yield-generator-mysqlnd/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP内核学习 --- 数组函数（键值大小写转换和切分）]]></title>
    <link href="http://www.flydream.org/2015/11/27/array-change-key-case-array-chunk/"/>
    <id>http://www.flydream.org/2015/11/27/array-change-key-case-array-chunk/</id>
    <published>2015-11-26T23:27:16.000Z</published>
    <updated>2015-11-28T00:38:59.000Z</updated>
    <content type="html"><![CDATA[<h3 id="1-PHP_数组元素键值大小写转换">1.PHP 数组元素键值大小写转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	PHP_FUNCTION(array_change_key_case)</span><br><span class="line">&#123;</span><br><span class="line">	array_init_size(return_value, zend_hash_num_elements(Z_ARRVAL_P(<span class="built_in">array</span>))); <span class="comment">//初始化返回值</span></span><br><span class="line"></span><br><span class="line">	zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(<span class="built_in">array</span>), &amp;pos);</span><br><span class="line">	<span class="keyword">while</span> (zend_hash_get_current_data_ex(Z_ARRVAL_P(<span class="built_in">array</span>), (<span class="keyword">void</span> **)&amp;entry, &amp;pos) == SUCCESS) &#123;</span><br><span class="line">		<span class="preprocessor">###这里添加索引，新数组每个元素和原来数组的元素共用同一个zval,符合写时复制的机制</span></span><br><span class="line">		zval_add_ref(entry);  </span><br><span class="line"></span><br><span class="line">		<span class="keyword">switch</span> (zend_hash_get_current_key_ex(Z_ARRVAL_P(<span class="built_in">array</span>), &amp;string_key, &amp;str_key_len, &amp;num_key, <span class="number">0</span>, &amp;pos)) &#123;</span><br><span class="line">		   <span class="preprocessor">###判断数组元素的键值是字符串还是数组下标，通过判断Buckets中的nKeyLength是否有值来判断；如果为数字下标，则nKeyLength无值</span></span><br><span class="line">			<span class="keyword">case</span> HASH_KEY_IS_LONG: </span><br><span class="line">				zend_hash_index_update(Z_ARRVAL_P(return_value), num_key, entry, <span class="keyword">sizeof</span>(entry), <span class="literal">NULL</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> HASH_KEY_IS_STRING:</span><br><span class="line">				new_key = estrndup(string_key, str_key_len - <span class="number">1</span>);</span><br><span class="line">				<span class="keyword">if</span> (change_to_upper) &#123;</span><br><span class="line">					php_strtoupper(new_key, str_key_len - <span class="number">1</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					php_strtolower(new_key, str_key_len - <span class="number">1</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				zend_hash_update(Z_ARRVAL_P(return_value), new_key, str_key_len, entry, <span class="keyword">sizeof</span>(entry), <span class="literal">NULL</span>);</span><br><span class="line">				efree(new_key);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="preprocessor">###移至下一个元素</span></span><br><span class="line">		zend_hash_move_forward_ex(Z_ARRVAL_P(<span class="built_in">array</span>), &amp;pos);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-PHP_数组切分">2.PHP 数组切分</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PHP_FUNCTION(array_chunk)</span><br><span class="line">&#123;</span><br><span class="line">.........</span><br><span class="line"></span><br><span class="line">array_init_size(return_value, ((num_in - <span class="number">1</span>) / size) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">zend_hash_internal_pointer_reset_ex(Z_ARRVAL_P(input), &amp;pos);</span><br><span class="line"><span class="keyword">while</span> (zend_hash_get_current_data_ex(Z_ARRVAL_P(input), (<span class="keyword">void</span>**)&amp;entry, &amp;pos) == SUCCESS) &#123;</span><br><span class="line">	<span class="preprocessor">### 创建chunk，其中元素个数=size</span></span><br><span class="line">	<span class="keyword">if</span> (!chunk) &#123;</span><br><span class="line">		MAKE_STD_ZVAL(chunk);</span><br><span class="line">		array_init_size(chunk, size);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	zval_add_ref(entry);</span><br><span class="line">	<span class="preprocessor">### 保留键值</span></span><br><span class="line">	<span class="keyword">if</span> (preserve_keys) &#123;</span><br><span class="line">		key_type = zend_hash_get_current_key_ex(Z_ARRVAL_P(input), &amp;str_key, &amp;str_key_len, &amp;num_key, <span class="number">0</span>, &amp;pos);</span><br><span class="line">		<span class="keyword">switch</span> (key_type) &#123;</span><br><span class="line">			<span class="keyword">case</span> HASH_KEY_IS_STRING:</span><br><span class="line">				add_assoc_zval_ex(chunk, str_key, str_key_len, *entry);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				add_index_zval(chunk, num_key, *entry);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;  <span class="preprocessor">### 数字下标 新增元素</span></span><br><span class="line">		add_next_index_zval(chunk, *entry);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="preprocessor">### chunk已经到达要切分的大小，就放入返回值，返回值是数字数组</span></span><br><span class="line">	<span class="keyword">if</span> (!(++current % size)) &#123;</span><br><span class="line">		add_next_index_zval(return_value, chunk);</span><br><span class="line">		chunk = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	zend_hash_move_forward_ex(Z_ARRVAL_P(input), &amp;pos);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">	<span class="preprocessor">### 收尾工作 无法整除时最后一个chunk的大小&lt;size</span></span><br><span class="line">	<span class="keyword">if</span> (chunk) &#123;</span><br><span class="line">	add_next_index_zval(return_value, chunk);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>add_assoc_zval_ex和add_index_zval 区别就是元素键值是字符还是数字。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="1-PHP_数组元素键值大小写转换">1.PHP 数组元素键值大小写转换</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><]]>
    </summary>
    
      <category term="array_change_key_case,array_chunk" scheme="http://www.flydream.org/tags/array-change-key-case-array-chunk/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nginx和php的pfm]]></title>
    <link href="http://www.flydream.org/2015/11/22/ngigx-pfm/"/>
    <id>http://www.flydream.org/2015/11/22/ngigx-pfm/</id>
    <published>2015-11-22T02:06:29.000Z</published>
    <updated>2015-11-22T08:46:06.000Z</updated>
    <content type="html"><![CDATA[<h1 id="nginx与pfm">nginx与pfm</h1><p>nginx与php的结合，就是静态网页由nginx来解析，而动态内容则交给php来处理。这里采用的nginx的FastCGI模块和PHP的php-fpm来共同工作。</p>
<h3 id="1-nginx的nginx-conf">1.nginx的nginx.conf</h3><p>在nginx的配置文件nginx.conf中，开启和修改一下配置项：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># pass the PHP scritpts to FastCGI server listening on 127.0.0.1.9000</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line">location ~\.php$&#123;</span><br><span class="line">	root		  html;</span><br><span class="line">	fastcgi_pass  <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">9100</span></span><br><span class="line">	fastcgi_index index.php</span><br><span class="line">	fastcgi_param SCRIPT_FIFLNAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">	fastcig_param PATH_INFO <span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">	<span class="keyword">include</span>       fastcgi_params;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述fastcgi指令的作用：<br>fastcgi_pass:指定服务器监听的地址和端口；<br>fastcgi_param:指定传递到服务器的参数，其中SCRIPT_FILENAME 就是php要执行的脚本的完整路径，脚本的名字存储在$fastcgi_script_name中；<br>fastcgi_index:如果URI的请求以/结尾，那么index.php就会默认补充在/之后，也可以看做默认值。<br>这些只是fastcgi指令中很少的一部分，还有更多关于负载均衡、缓存等的指令。</p>
<h3 id="2-php-fpm">2.php-fpm</h3><p>对php-fpm的进程控制，通过信号量实现：<br>1.SIGINT、SIGTERM:立刻终止进程<br>2.SIGQUIT:平滑终止进程<br>3.SIGUSR1:重新打开日志文件<br>4.SIGUSR2:平滑重载所有worker进程并重新载入配置和二进制模块</p>
<p>命令如下：<br>kill -SIGINT ‘cat /usr/local/php5/var/run/php-fpm.pid’</p>
<p>第一次打开pfm，可以在php的安装目录的/usr/local/php5/sbin 下执行./php-fpm,也可以通过init脚本启动，在php的源码sapi/fpm/init.d.php-fpm 是pfm的init脚本。也可把它复制到/etc/init.d/php-fpm下，然后改变权限 chmod 755 /etc/init.d/php-fpm,最后通过执行chkconfig –add php-fom  和chkconfig –level 35 php-fpm on。<br>我们就可以通过server php-fpm （start|stop|force_quit|restart|reload）来管理啦。</p>
<h1 id="nginx的高并发和负载均衡">nginx的高并发和负载均衡</h1><h3 id="1-epoll">1.epoll</h3><p>高并发下建立的tcp连接，在同一时刻保持活跃状态的可能只有一少部分。这种情况下，将所有连接告诉操作系统，由操作系统全部遍历找出其中活跃的连接，显然会造成资源浪费。epoll则把select或者poll更加细分，分三部分：epoll_create创建epoll对象，之后通过epoll_ctl向epoll对象添加全部连接，最后调用epoll_wait收集处于活跃的连接。<br>epoll怎么知道哪些连接处于活跃状态？epoll中的所有事件都会与设备驱动程序建立回调关系，即当有事件发生时会调用回调方法将这样的事件写入rdllist这个双向链表中。epoll_wait会去这个双向链表中，获取处于活跃状态的事件。通过这种机制实现了epoll的高效。</p>
<h3 id="2-nginx的“惊群”与负载均衡">2.nginx的“惊群”与负载均衡</h3><p>nginx中一个mater主进程和多个worker进程一起工作。当一个请求到来时，多个worker进程会去争夺，最先执行accept的可以成功机建立连接。但是这引起了多余的进程切换，增加了系统开销，即“惊群问题”。<br>nginx的解决办法：加accept_mutex锁，只用调用ngx_trylock_accept_mutex成功后，当前worker进程才能去处理。<br>接着的问题是，如果当前worker进程有很多要处理的事件事件，它一直占据着不释放锁，那么其他worker进程就无法工作，有些请求可能就不能达到及时响应，没有达到多个worker的目的。所以nginx会有两个post事件的队列，它们分别是ngx_posted_accept_events和ngx_posted_events，其中第一个负责处理新来的事件，处理完后立马释放accpet_mutex锁，第二队列用来处理普通事件。<br>问题到这里还没有结束，如果，每次都是同一个进程抢到锁，但是它已经达到了连接上限。那么这些请求它是处理不了的，这怎么办？<br>nginx的worker进程在抢accept_mutex锁之前，首先判断ngx_accept_disabled是否&gt;0,只有小于零才会去抢锁。ngx_accept_distabled = 总连接数/8-空闲连接数。<br>所以nginx的负载均衡是靠两个post队列和ngx_accept_distabled来实现的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="nginx与pfm">nginx与pfm</h1><p>nginx与php的结合，就是静态网页由nginx来解析，而动态内容则交给php来处理。这里采用的nginx的FastCGI模块和PHP的php-fpm来共同工作。</p>
<h3 id="1-nginx的n]]>
    </summary>
    
      <category term="nginx pfm 高并发 负载均衡" scheme="http://www.flydream.org/tags/nginx-pfm-%E9%AB%98%E5%B9%B6%E5%8F%91-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[pcntl_thread]]></title>
    <link href="http://www.flydream.org/2015/11/15/pcntl-thread/"/>
    <id>http://www.flydream.org/2015/11/15/pcntl-thread/</id>
    <published>2015-11-15T12:07:10.000Z</published>
    <updated>2015-11-17T00:05:52.000Z</updated>
    <content type="html"><![CDATA[<p>Uninx进程间通信(ipc)方式：消息队列、信号量和共享内存。<br>在具体编码之前，php的编译时需要 –enable-pcntl –enable-sysvmsg</p>
<h4 id="1-消息队列">1.消息队列</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">multiCntl</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="variable">$semId</span>;</span><br><span class="line">	<span class="keyword">private</span> <span class="variable">$name</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="variable">$key</span>=ftok(<span class="keyword">__FILE__</span>,<span class="string">'t'</span>);</span><br><span class="line">		<span class="variable">$this</span>-&gt;semId=sem_get(<span class="variable">$key</span>); <span class="comment">//信号量</span></span><br><span class="line">	&#125;</span><br><span class="line">   </span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">startCntl</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="comment">//创建队列:0x300033是我们创建的队列的key</span></span><br><span class="line">		<span class="variable">$this</span>-&gt;queue = msg_get_queue(<span class="number">0x300033</span>);</span><br><span class="line">		<span class="comment">//msg_remove_queue($this-&gt;queue);</span></span><br><span class="line">		<span class="comment">//die;</span></span><br><span class="line">		<span class="comment">//在当前进程(即主进程)下，创建新进程(子进程)</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span>&lt;<span class="number">3</span>;<span class="variable">$i</span>++)&#123;</span><br><span class="line">			 <span class="variable">$pid</span> = pcntl_fork();</span><br><span class="line">			 <span class="keyword">echo</span> <span class="variable">$i</span>.<span class="string">"==="</span>.<span class="variable">$pid</span>.<span class="string">"\n"</span>;</span><br><span class="line">			 <span class="keyword">if</span>(<span class="variable">$pid</span> &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			 	<span class="comment">//主进程</span></span><br><span class="line">			 	<span class="variable">$workerpid</span>[]=<span class="variable">$pid</span>;</span><br><span class="line">			 &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			 	<span class="comment">//子进程</span></span><br><span class="line">			 	<span class="variable">$this</span>-&gt;worker(<span class="variable">$i</span>);</span><br><span class="line">			 	<span class="keyword">exit</span>;   <span class="comment">//继续执行主进程</span></span><br><span class="line">			 &#125;</span><br><span class="line">		</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">worker</span><span class="params">(<span class="variable">$i</span>)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//消息队列</span></span><br><span class="line">		<span class="keyword">echo</span> <span class="variable">$i</span>.<span class="string">"\n"</span>;</span><br><span class="line">		<span class="variable">$msgtype</span> = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">switch</span>(<span class="variable">$i</span>)&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'0'</span>:</span><br><span class="line">				msg_send(<span class="variable">$this</span>-&gt;queue,<span class="variable">$msgtype</span>,<span class="string">"wang"</span>,<span class="keyword">false</span>,<span class="keyword">true</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">				msg_send(<span class="variable">$this</span>-&gt;queue,<span class="variable">$msgtype</span>,<span class="string">"wen"</span>,<span class="keyword">false</span>,<span class="keyword">true</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">				msg_send(<span class="variable">$this</span>-&gt;queue,<span class="variable">$msgtype</span>,<span class="string">"bo"</span>,<span class="keyword">false</span>,<span class="keyword">true</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getQueueMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="variable">$msg_type</span> = <span class="number">0</span>;</span><br><span class="line">		<span class="variable">$msg_pkt</span> = <span class="string">''</span>;</span><br><span class="line">		<span class="variable">$errCode</span> = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">			<span class="variable">$info</span> = msg_receive(<span class="variable">$this</span>-&gt;queue, <span class="number">0</span>, <span class="variable">$msg_type</span>, <span class="number">8192</span>, <span class="variable">$msg_pkt</span>, <span class="keyword">false</span>, <span class="variable">$errCode</span>);</span><br><span class="line">			print_r(<span class="variable">$msg_pkt</span>);</span><br><span class="line">			<span class="comment"># code...</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$mc</span> = <span class="keyword">new</span> multiCntl();</span><br><span class="line"><span class="variable">$mc</span>-&gt;startCntl();</span><br><span class="line"><span class="variable">$mc</span>-&gt;getQueueMsg();</span><br><span class="line"><span class="preprocessor">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>输出结果：<br>0===85521<br>0===0<br>0<br>1===0<br>1<br>1===85523<br>2===85525<br>2===0<br>2<br>wangwenbo</p>
<h4 id="2-信号量">2.信号量</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">worker</span><span class="params">(<span class="variable">$i</span>)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//消息队列</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="variable">$i</span>.<span class="string">"\n"</span>;</span><br><span class="line">	<span class="variable">$msgtype</span> = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">switch</span>(<span class="variable">$i</span>)&#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'0'</span>:</span><br><span class="line">			msg_send(<span class="variable">$this</span>-&gt;queue,<span class="variable">$msgtype</span>,<span class="string">"wang"</span>,<span class="keyword">false</span>,<span class="keyword">true</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'1'</span>:</span><br><span class="line">			msg_send(<span class="variable">$this</span>-&gt;queue,<span class="variable">$msgtype</span>,<span class="string">"wen"</span>,<span class="keyword">false</span>,<span class="keyword">true</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> <span class="string">'2'</span>:</span><br><span class="line">			msg_send(<span class="variable">$this</span>-&gt;queue,<span class="variable">$msgtype</span>,<span class="string">"bo"</span>,<span class="keyword">false</span>,<span class="keyword">true</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//信号量</span></span><br><span class="line">	sem_acquire(<span class="variable">$this</span>-&gt;semId);</span><br><span class="line">	<span class="variable">$this</span>-&gt;name.=<span class="variable">$set</span>[<span class="variable">$i</span>];</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">"信号量:"</span>.<span class="variable">$this</span>-&gt;name.<span class="string">"\n"</span>;</span><br><span class="line">	sem_release(<span class="variable">$this</span>-&gt;semId);	</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getSemMsg</span><span class="params">()</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(count(<span class="variable">$this</span>-&gt;workerpid) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">foreach</span>(<span class="variable">$this</span>-&gt;workerpid <span class="keyword">as</span> <span class="variable">$k</span>=&gt;<span class="variable">$pid</span>)&#123;</span><br><span class="line">			<span class="variable">$res</span> = pcntl_waitpid(<span class="variable">$pid</span>,<span class="variable">$status</span>,WNOHANG);</span><br><span class="line">			<span class="keyword">if</span>(<span class="variable">$res</span> == -<span class="number">1</span> || <span class="variable">$res</span> &gt; <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">unset</span>(<span class="variable">$this</span>-&gt;workerpid[<span class="variable">$k</span>]);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	print_r(<span class="string">"信号量："</span>.<span class="variable">$this</span>-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<br>信号量：“123”wang<br>信号量：“123”wen<br>信号量：“123”bo</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Uninx进程间通信(ipc)方式：消息队列、信号量和共享内存。<br>在具体编码之前，php的编译时需要 –enable-pcntl –enable-sysvmsg</p>
<h4 id="1-消息队列">1.消息队列</h4><figure class="highlig]]>
    </summary>
    
      <category term="进程间通信" scheme="http://www.flydream.org/tags/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[php7_2]]></title>
    <link href="http://www.flydream.org/2015/10/26/php7-2/"/>
    <id>http://www.flydream.org/2015/10/26/php7-2/</id>
    <published>2015-10-25T22:27:08.000Z</published>
    <updated>2016-02-28T06:59:22.000Z</updated>
    <content type="html"><![CDATA[<p>【原文链接】（<a href="http://nikic.github.io/2015/06/19/Internal-value-representation-in-PHP-7-part-2.html" target="_blank" rel="external">http://nikic.github.io/2015/06/19/Internal-value-representation-in-PHP-7-part-2.html</a> ）<br>本文的最开始部分，首先讨论变量值在PHP 5 和PHP 7内部实现上的明显变化。最主要的不同就是zvals不在会被独立分配和存储自身的引用计数。例如整数、浮点数这样的基本数据类型的值直接存储在其对应的zval中，而一些复杂的数据类型在zval存储指向另一个结构体的指针。</p>
<p>对于刚才提到的复杂数据类型，它们有一个共同的header，即zend_refcounted:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _zend_refcounted&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> refcount;</span><br><span class="line">	<span class="keyword">union</span>&#123;</span><br><span class="line">		<span class="keyword">struct</span>&#123;</span><br><span class="line">			ZEND_ENDIAN_LOHI_3(</span><br><span class="line">				zend_uchar type,</span><br><span class="line">				zend_uchar flags,</span><br><span class="line">				<span class="keyword">uint16_t</span>   gc_info)</span><br><span class="line">		&#125;v;</span><br><span class="line">		<span class="keyword">uint32_t</span> typeinfo;</span><br><span class="line">	&#125; u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>zend_refcounted中的成员变量有引用次数的refcount，变量类型的type、用于GC的gc_info和类型指定flags。</p>
<p>接下来要具体要谈及每一种复杂类型变量实现并且和它们在PHP 5中的实现方式作比较。其中引用类型，我们刚才已经介绍过。本文也不会提及resources类型，因为关于这部分不是很有趣。</p>
<h4 id="Strings">Strings</h4><p>PHP 7中通过zend_string来表现字符串，zend_string的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _zend_string&#123;</span><br><span class="line">	zend_refcouned gc;</span><br><span class="line">	zend_ulong     h;     <span class="comment">/* hash value */</span></span><br><span class="line">	<span class="keyword">size_t</span>         len;</span><br><span class="line">	<span class="keyword">char</span>           val[<span class="number">1</span>].</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了引用计数这个在前一段落提到的成员变量之外，zend_string还包含一个hash值h和一个表示字符串长度的len以及字符串值val（这里申明的是一个元素大小的字符数组，是不是觉得奇怪）。缓存hash值h是为了避免在hashtable中多次查找时重复计算。</p>
<p>假如你对“dirty C hacks”并不熟悉，那么成员变量val就会显得很奇怪。val是一个只有一个字符大小的数组，但是却用来存储一个完整地string类型值（大多数情况下，这个值都不值在一个字符）。其实这是运用了“struct hack”的技术：申明一个只含有一个元素的数组，当在创建一个zend_string时我们用它的val成员变量来存储一个更长的字符串。</p>
<p>这种新的string类型和常规的C strings相比是有一些优势的：首先，字符串长度直接嵌入其中。这就意味着字符串的长度不需要到处传递。其次，因为包含了zend_refcounted,所以可以在不使用zvals的情况下实现字符串的多处共享。尤其对共享hashtable键值尤其重要。</p>
<p>但是新的string类型也有缺点：虽然通过zend_string(str-&gt;val)可以轻易地取得c字符串，但是反之则不行，我们只能复制一份新值到新分配的zend_string中。当我们遍历处理字符串时就会造成不便（常量字符串由C源码生成）。</p>
<p>字符串的flags类型（它们存储在GC flags域中）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_STR_PERSISTENT  (<span class="number">1</span>&lt;&lt;<span class="number">0</span>) <span class="comment">/* allocated using malloc */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_STR_INTERNED    (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) <span class="comment">/* interned string */</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_STR_PERMANENT   (<span class="number">1</span>&lt;&lt;<span class="number">2</span>) <span class="comment">/* interned string surving request boundary */</span></span></span><br></pre></td></tr></table></figure>
<p>Persistent strings是通过操作系统分配内存而不是通过zend的内存管理器(ZMM)，也因为这样它的生命周期长于一次请求。<br>这之前的PHP 5中，我们要使用persistent string需要先将它复制到ZMM，现在通过指定flag就可以在zvals直接使用。</p>
<p>Interned strings在一次请求结束之前都不会被销毁，也就因为这样所以它不需要引用计数。这种类型的字符串是不可以重复，所以每次创建一个新的之前engine都会先检查其内容是否已存在。在PHP源码中出现的字符串(string literals,变量和函数名等)通常都是内部字符串。Permanent strings在一次请求开始之前就被创建的interned strings。当一般interned strings在一次请求结束后都被销毁后，permanent strings依然存在。</p>
<p>假如opache是interned strings，它就会被存储在共享内存(SHM)中，可以在PHP的工作进程间共享。这种情形下，permanent strings的概念也就无所谓啦，因为它们永远不会被销毁。</p>
<h4 id="Arrays">Arrays</h4><p>因为在之前的文章已经提过新数组的实现，所以这里我就不在详细阐述它。也不再具体的去介绍最近的变化，因为基本原理还是一样的。</p>
<p>这里我仅仅说一个和新数组有关的概念，即Immutable arrays，这个概念在之前的hashtable文章中并没有涉及到。这样的数组相当于内部字符串，所以它们没有引用计数而且生命周期直到一次请求结束或者更长。</p>
<p>考虑到内存管理，immutable arrays只有当opcache开启时才可使用。来看一下它到底有什么不同，思考一下面的代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="variable">$i</span>=<span class="number">0</span>;<span class="variable">$i</span> &lt; <span class="number">1000000</span>;++<span class="variable">$i</span>)&#123;</span><br><span class="line">	<span class="variable">$array</span>[]=[<span class="string">'foo'</span>];</span><br><span class="line">&#125;</span><br><span class="line">var_dump(memory_get_usage());</span><br></pre></td></tr></table></figure>
<p>开启opcache时内存占用32M，但是没有opcache内存占用390M，这是因为$array的每个元素都要从新复制一份。这里没有使用引用计数而是重新复制的原因是literal VM operands 通过这样来避免共享内存发生。我希望未来我们可以在不用opcache的情况下更好地处理这种情况。</p>
<h4 id="Objects_in_PHP_5">Objects in PHP 5</h4><p>在思考PHP 7的对象实现之前，我们先来了解一下它在PHP 5中是如何工作的以及它的一些低效的地方：zval自身被用来去存储zend_object_value:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _zend_object_value&#123;</span><br><span class="line">	zend_object_handle handle;</span><br><span class="line">	<span class="keyword">const</span> zend_object_handlers *handlers;</span><br><span class="line">&#125;zend_object_value;</span><br></pre></td></tr></table></figure>
<p>handle是对象的唯一标示，通过它来查找对象的数据。handles是一个VTable指针，它指向了对象中实现的方法。一般情况下，php中对象它们的handler table没有什么区别，但是php 扩展创建的对象它们对应handler table会有不同。这个不同类似于重载操作符。</p>
<p>handle是“object store”的数组索引，”object store”作为一个元素保存在数组中,”object store”的结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _zend_object_store_bucket&#123;</span><br><span class="line">	zend_bool destructor_called;    <span class="comment">//销毁时调用</span></span><br><span class="line">	zend_bool valid;                <span class="comment">//是否在被使用</span></span><br><span class="line">	zend_uchar apply_count;         <span class="comment">//对象被访问的次数</span></span><br><span class="line">	<span class="keyword">union</span> _store_bucket &#123;</span><br><span class="line">		<span class="keyword">struct</span> _store_object&#123;</span><br><span class="line">			<span class="keyword">void</span> * object;</span><br><span class="line">			zend_objects_store_dtort dtor;</span><br><span class="line">			<span class="keyword">zend_objects_free_object_storage_t</span> free_storage;</span><br><span class="line">			<span class="keyword">zend_objects_store_clone_t</span> clone;</span><br><span class="line">			<span class="keyword">const</span> zend_object_handlers * handlers;</span><br><span class="line">			zend_uint refcount;</span><br><span class="line">			gc_root_buffer *buffered;</span><br><span class="line">		&#125; obj;</span><br><span class="line">		<span class="keyword">struct</span>&#123;</span><br><span class="line">			<span class="keyword">int</span> next;</span><br><span class="line">		&#125;free_list;</span><br><span class="line">	&#125;bucket;</span><br><span class="line">&#125;zend_object_store_bucket;</span><br></pre></td></tr></table></figure>
<p>这里有很多值得说的地方。前三个成员是元数据（destructor_called:对象的析构函数是否已调用，valid:当前对象是否被调用,apply_count:这个对象被调用的次数）。接下来的联合体用来区分这个bucket正在被使用或者它只是bucket free list的一部分。对于这部内容，重点在结构体_store_object：<br>在这个联合体中结构体_store_object的使用也是很重要的：</p>
<p>_store_object结构体中第一个成员变量object指向的是真正对象。它没有直接嵌入在object store bucket之中，是因为对象的大小不确定。在对象指针之后紧跟着三个handlers，它们负责析构，释放和克隆。尤其要注意的是对象的析构和释放是分开的两个步骤。实际上克隆从未被使用过。原因就是zend_objects_store_clone_t不是一般的对象的handlers，它们会被复制在每个独立的对象中而不是共享。</p>
<p>在dtor,free_storage和clone三个句柄之后的是普通的对象handlers。const zend_object_handlers * handlers的目的是为了防止对象被销毁而zval却不知道。</p>
<p>紧接着这个结构体中还包含一个引用计数，PHP 5中的zval已经存储了一个引用计数为什么这里还要再存储一个哪？对于php中简单的复制操作，zval中引用计数增加即可。但对于必须创建一个新的zval并从一个已有的zval(zend_object_value)中复制值时，这个对象就需要引用计数。这种双引用计数是PHP 5zval内部实现造成的问题。最后buffered指针指向GC root buffer，它被复制也是相似的道理。</p>
<p>现在我们看一下真正的对象。对于用户创建的对象，它的定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _zend_object &#123;</span><br><span class="line">	zend_class_entry *ce;</span><br><span class="line">	HashTable *properties;</span><br><span class="line">	zval ** properties_table;</span><br><span class="line">	HashTable *guards;</span><br><span class="line">&#125; zend_object;</span><br></pre></td></tr></table></figure>
<p>zend_class_entry 是一个指向一个类实例。接下来的两个成员变量对应两种不同的对象属性存储方式。对于动态属性(不是在声明类时添加的而是在运行时动态加入的)则使用哈希类型的properties，它用来通过属性名映射属性值。</p>
<p>然而对于属性声明这里还有一个优化：在编译期间每个属性被定义为一个索引而对应的属性值通过索引被存储在properties_table中。属性名和它们对应的索引映射关系则存储在这个class entry的哈希表中。这样做的目的是为每个类的对象在申请内存。而且属性对应的索引也可以在运行中被缓存。</p>
<p>guards用于实现魔术方法的递归如__get,这里不再深入。</p>
<p>除了之前已经提到的双引用计数问题，对一个只有一个属性的对象它也要136字节的内存（还没包含zvals）。而且还有很对的间接寻址：例如，唯一获取一个对象的属性，你首先需要找到对象的store bucket，然后是zend object，在然后是属性表和zval。如此一来就已经是至少四层间接寻址（在实际中，这个过程不少于七）。</p>
<h4 id="Objects_in_PHP_7">Objects in PHP 7</h4><p>PHP7尝试去解决前文提到的问题，它们分别是解决双引用计数，减少不必要的内存占用和减少间接寻址。新的zend_object结构体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _zend_object&#123;</span><br><span class="line">	zend_refcounted gc;</span><br><span class="line">	<span class="keyword">uint32_t</span>        handle;</span><br><span class="line">	zend_class_entry *ce;</span><br><span class="line">	<span class="keyword">const</span> zend_object_handlers *handlers;</span><br><span class="line">	HashTable       *properties;</span><br><span class="line">	zval            properties_table[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的这个结构体是优化后的一个对象结构体：zend_object_value已经被一个直接指向对象的结构体替换同时object store结构虽然没有完全消失但也不再那么重要。</p>
<p>去除包含一个zend_refcounted,你也会看到对象的handle和handlers也已经被移入zend_object。而且现在properties_table also makes use of the struct hack,所以zend_object和属性表可以被分配在同一个块中。当然，属性表也直接把zvals嵌入其中，而不再是包含指向zvals的指针。</p>
<p>guards表在新的对象结构体中不再直接出现。取而代之是在需要的时候把它放入properties_table的第一个槽位，比如：对象使用了__get。但是如果没有使用这些魔术方法，guards表就是可以省略。</p>
<p>dtor，free_storage和clone三个handlers之前存放在object store bucket中，现在也不移入了handlers表中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _zend_object_handlers&#123;</span><br><span class="line">	<span class="comment">/* offset of real object header (usually zero) */</span></span><br><span class="line">   	<span class="keyword">int</span>                                     offset;</span><br><span class="line">  		<span class="comment">/* general object functions */</span></span><br><span class="line">   	<span class="keyword">zend_object_free_obj_t</span>                  free_obj;</span><br><span class="line">   	<span class="keyword">zend_object_dtor_obj_t</span>                  dtor_obj;</span><br><span class="line">   	<span class="keyword">zend_object_clone_obj_t</span>                 clone_obj;</span><br><span class="line">   	<span class="comment">/* individual object functions */</span></span><br><span class="line">  		 <span class="comment">// ... rest is about the same in PHP 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的结构体顶部是一个表示offset成员变量，它很明显不是一个句柄。offset与对象的内部表现有关：内部的对象会嵌入标准的zend_object,但也会增加一些额外的成员变量。在PHP5中的它的形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> custom_object&#123;</span><br><span class="line">	zend_object <span class="built_in">std</span>;</span><br><span class="line">	<span class="keyword">uint32_t</span> something;</span><br><span class="line">	<span class="comment">// ....</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述结构体中成员变量的安排就代表着zend_object *可以扮演者结构体custom_object的角色。这是C中标准的结构体继承。但是在PHP 7中这种实现伴随着一个问题：因为zend_object使用struct hack来存储属性表，所以PHP会在zend_object中存储属性值，而这样可能会覆盖custom_object中其它的成员变量值。这也是为什么在PHP7中额外的成员变量定义在zend_object之前的原因：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> custom_object&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> something;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line">	zend_object <span class="built_in">std</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而上述结构也意味着由于zend_object<em> 和 custom_object </em>被一个offset分隔开，它们之间无法再接着转换。这个offset就是_zend_object_handlers中的第一个成员变量。在编译时这个offset由offsetof宏来具体实现。</p>
<p>你或许会疑问为什么PHP 7的对象(_zend_object)依然包含一个handle。毕竟，我们现在都会直接保存指向zend_object的指针，我们不在需要handle去object store中去查找定位一个对象。</p>
<p>但是这个handle还是需要的，原因就是object store虽然现在体形变小了但依然存在着。handle现在只是保存着对象指针的数组的索引。当创建一个新对象，指向这个对象的指针就会被写入object sotre中并通过handle来定位一旦对象释放对应的handle就移除。</p>
<p>为什么我们还需要object store？原因就是在生命周期的request shutdown期间，由于这个executor已经部分关闭会导致再运行用户的代码会不安全。为了避免这个问题PHP需要在一个更早的时间点去析构所有的对象来阻止用户代码的运行。所以我们需要一个当前所有对象的列表。</p>
<p>而且这个handle在调试时也有使用到，因为它是每个对象的唯一标识，通过它可以很容易识别两个对象是真的相同还是只是内容一致。HHVM虽然没有object store的概念但也保存着这个handle。</p>
<p>相比PHP 5的实现，我们现在仅有一个引用计数以及更小的内存占用：我们现在一个基本对象需要40个字节和属性申明占用16个字节，这其中已经包含它的zval结构。随着中间结构体或者被丢弃或者被内嵌，间接寻址的次数已经明显减少。因此现在一次属性的读取只要能够一个间接寻址而不再是4次。</p>
<h4 id="Indirect_zval">Indirect zval</h4><p>在这里我们涉及到zval的所有基本类型，以及一些在特定情况下出现的一些特殊类型。一个是PHP 7 中新增的IS_INDIRECT.</p>
<p>indirect zval意味着它的值存储在其它的zval中。特别注意的与IS_REFERENCE类型不同，它直接指向另外一个zval，而不是指向一个嵌入了zval的zend_reference结构。</p>
<p>通过思考PHP变量的实现(对象属性的存储)，我们要去理解什么样的特殊情形下会需要这么做：</p>
<p>在编译时会生符号表(CV)，所有的变量的值都会被存入符号表中通过对应的变量名对应的索引来在符号表中定位每个变量对应的值。然而PHP是允许我们动态的引用变量的，假如想在全局范围内引用变量，也可以通过$GLOBALS。如果这种情况发生，PHP会为函数/脚本创建一个符号表，在这个符号表中保存着变量名和对应值的映射。</p>
<p>这也带来一个问题：如何同时支持两种处理方式？对于普通的变量获取，我们需要基本的符号表同时系统符号表来处理变量的复制引用。在PHP 5中，符号表(CV)采用了二级zval <em>*指针的方式。它们指向包含了一级zval </em>指针（指向真正的zval）的二级表。</p>
<p>+—— CV_ptr_ptr[0]<br>| +—- CV_ptr_ptr[1]<br>| | +– CV_ptr_ptr[2]<br>| | |<br>| | +-&gt; CV_ptr[0] –&gt; some zval<br>| +—&gt; CV_ptr[1] –&gt; some zval<br>+—–&gt; CV_ptr[2] –&gt; some zval</p>
<p>现在，自从系统符号表的使用，包含着zval <em>指针的二级表就不在使用了同时zval *</em> 指向哈希表的buckets。下面通过实例来说明一下，分别定义了三个变量$a,$b,$c:</p>
<p>CV_ptr_ptr[0] –&gt; SymbolTable[“a”].pDataPtr –&gt; some zval<br>CV_ptr_ptr[1] –&gt; SymbolTable[“b”].pDataPtr –&gt; some zval<br>CV_ptr_ptr[2] –&gt; SymbolTable[“c”].pDataPtr –&gt; some zval</p>
<p>在PHP 7中这种方式不再可行，原因就是哈希表已经被重新设计过，此时指向bucket的指针已经无效。在原来策略不再可行的时，PHP 7采用来完全相反的策略：系统符号表中包含一个INDIRECT实体，它指向CV实体。CV表在整个系统符号表的生命周期里都不会再重新分配。</p>
<p>现在你在一个函数中创建了变量$a,$b和$c,而且还动态地创建了$d,系统符号表会看起来像下面这个样子：</p>
<p>SymbolTable[“a”].value = INDIRECT –&gt; CV[0] = LONG 42<br>SymbolTable[“b”].value = INDIRECT –&gt; CV[1] = DOUBLE 42.0<br>SymbolTable[“c”].value = INDIRECT –&gt; CV[2] = STRING –&gt; zend_string(“42”)<br>SymbolTable[“d”].value = ARRAY –&gt; zend_array([4, 2])</p>
<p>Indirect zvals也可以指向一个IS_UNDEF类型的zval，这种情况等效于哈希表中没有对应的键。同样unset($a)操作会将CV[0]赋值为UNDEF，这和哈希表中没有对应的键值是等效的。</p>
<h5 id="Constants_和_ASTs">Constants 和 ASTs</h5><p>在PHP 5和7中还有两个特别的类型值得一说，它们是IS_CONSTANT和IS_CONSTANT_AST。思考一个实例，来理解究竟发生了什么：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span><span class="params">(<span class="variable">$a</span> = ANSWER,<span class="variable">$b</span>=ANSWER+ANSWER)</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable">$a</span>+<span class="variable">$b</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">define(<span class="string">'ANSWER'</span>,<span class="number">42</span>);</span><br><span class="line">var_dump(test()); <span class="comment">//int(42 + 42 * 42)</span></span><br></pre></td></tr></table></figure>
<p>test函数的参数默认值是常量ANSWER，然而常量定义在在函数定义之后。常量只有在define()之后才可用。</p>
<p>之所以可以运行的原因就是“static expression”，它可以在首次真正使用时才评估表达式，而参数，属性默认值，常量等等都支持“static expression”。</p>
<p>如果值是一个常量（类常量），这个是一个IS_CONSTANT类型的zval。如果值是一个表达式，这个zval是IS_CONSTANT_AST类型的并指向一个抽象语法树。</p>
<p>总结一下我们对PHP 7 value的表述。我想要表述的是两个主题：在虚拟机方面的优化尤其是新的调用机制和在编译上的改进。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>【原文链接】（<a href="http://nikic.github.io/2015/06/19/Internal-value-representation-in-PHP-7-part-2.html" target="_blank" rel="external">http]]>
    </summary>
    
      <category term="php7 string array object" scheme="http://www.flydream.org/tags/php7-string-array-object/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[有关缓存]]></title>
    <link href="http://www.flydream.org/2015/10/25/%E6%9C%89%E5%85%B3%E7%BC%93%E5%AD%98/"/>
    <id>http://www.flydream.org/2015/10/25/有关缓存/</id>
    <published>2015-10-25T07:37:46.000Z</published>
    <updated>2015-10-25T09:08:40.000Z</updated>
    <content type="html"><![CDATA[<p>在我们的web系统中，尤其是一些高并发的web系统，为了缩短响应时间来到达良好的用户体验，缓存都会无处不在。从DNS缓存、CDN、浏览器本地缓存、浏览器与http协议缓存、mysql的缓存、apache和nginx实现的缓存、语言层面的缓存如PHP的opcode缓存和redis等。</p>
<h4 id="DNS缓存">DNS缓存</h4><p>我们通过浏览器去访问网站时，要经过域名解析(DNS),这是为了更快地响应我们可以减少DNS的解析次数，主流的浏览器都支持DNS预取(DNS Prefetch),即将域名对应的ip存储在浏览器本地，当下次访问相同的网站时就不需要再次域名解析。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"x-dns-prefetch-control"</span> <span class="attribute">content</span>=<span class="value">"on"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>chrome查看本地DNS:chrome://net-internals/#dns</p>
<h4 id="CDN">CDN</h4><p>我们可以依据我们的常识来对理解CDN，去一个离我们近的地方去取东西往返的时间肯定相对是短的。通过把一些必要的数据存储在离用户最近的运营商服务器上，避免网络路由的跳转来达到快速响应。</p>
<h4 id="浏览器本地缓存">浏览器本地缓存</h4><p>在前端例如logo，公共的布局文件和js，在首次加载时就可以缓存在浏览器本地，不过这个需要告诉浏览器哪些需要缓存：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"Cache-Control"</span> <span class="attribute">content</span>=<span class="value">"max-age=3600"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样1h内 浏览器不会在向服务器发送请求。另外还有Html5的Application Cache来实现移动端的离线浏览。</p>
<h4 id="浏览器和http交互">浏览器和http交互</h4><p>一旦浏览器端缓存过期，需要重新发送请求。第一请求后，服务器返回的信息多了Last—Modified，Exprires和ETag。Last-Modified:最近一次修改时间，Exprires:过期时间和ETag:服务器根据请求URL生成的标识。根据ETag找到对应的文件更新时间和Last-Modified比较，未变化则返回状态码304。</p>
<h4 id="PHP_opcode缓存">PHP opcode缓存</h4><p>现在php内置zendopcache ，编译时–enable-opcache，之后配置php.ini。<br>PHP 每次执行执行都要经过词法，语法分析，编译成opcode，最后由zend引擎执行。通过缓存opcode，跳过之前的分析和编译过程，直接执行来提高性能。</p>
<p>最后，这里只是简单罗列一些内容，还有一些内存级别的redis和服务器的缓存，有时间仔细研究后在记录下来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在我们的web系统中，尤其是一些高并发的web系统，为了缩短响应时间来到达良好的用户体验，缓存都会无处不在。从DNS缓存、CDN、浏览器本地缓存、浏览器与http协议缓存、mysql的缓存、apache和nginx实现的缓存、语言层面的缓存如PHP的opcode缓存和red]]>
    </summary>
    
      <category term="web cache" scheme="http://www.flydream.org/tags/web-cache/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[js(原型-实例-原型链)]]></title>
    <link href="http://www.flydream.org/2015/10/16/js-%E5%8E%9F%E5%9E%8B-%E5%AE%9E%E4%BE%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>http://www.flydream.org/2015/10/16/js-原型-实例-原型链/</id>
    <published>2015-10-16T14:41:22.000Z</published>
    <updated>2015-10-18T23:18:26.000Z</updated>
    <content type="html"><![CDATA[<h4 id="javascript的原型对象">javascript的原型对象</h4><p>在js中每一个函数都一个原型属性(prototype),它是一个指向另一个对象指针，这个对象可以让同一个函数的所有实例共享属性和方法，这个对象就是原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">student</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line">student.prototype.name =<span class="string">"jack"</span>;</span><br><span class="line">student.prototype.class =<span class="string">"高1(2)班"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> stu1 = <span class="keyword">new</span> student();</span><br><span class="line">	<span class="built_in">console</span>.log(stu1.name); <span class="comment">//jack  </span></span><br><span class="line"><span class="keyword">var</span> stu2 = <span class="keyword">new</span> student();</span><br><span class="line">	<span class="built_in">console</span>.log(stu2.name); <span class="comment">//jack</span></span><br></pre></td></tr></table></figure>
<p>实例对象stu1和stu2 拥有同样的属性name和class，即共享了原型对象（student Prototype）的属性。</p>
<p>js中只要创建了一个函数，js就会为这个函数添加prototype属性，这个prototype属性指向函数的原型对象。而且原型对象也有一个construcor属性，指向它对应的函数。我们如果想向原型对象添加属性和方法，只能通过函数的prototype属性访问到原型对象，下面是构造函数，实例，原型对象之间的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">student.prototype ---------&gt; student Prototype</span><br><span class="line">stu1.[[Prototype]]---------&gt; student Prototype</span><br><span class="line">stu2.[[Prototype]]---------&gt; student Prototype</span><br><span class="line"></span><br><span class="line">student Prototype.constructor-------&gt;student</span><br></pre></td></tr></table></figure>
<p>构造函数stduent以及两个实例stu1和stu2 ，它们共同指向原型对象student Prototype，而实例和构造函数之间没有直接关联。同时还有原型对象的constructor指向构造函数。</p>
<h4 id="继承">继承</h4><p>js中的继承是通过原型链来实现继承。这里我就直接使用《javascript 高级程序程序设计<br>》中的例子,实现原型链的基本模式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//继承 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line">SubType.prototype = getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line"><span class="built_in">console</span>.log(instance.getSuperValue());  <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>上述来两个构造函数SuperType和SubType都一个属性和方法，实例instance可以调用SuperType的方法getSuperValue，即实现了继承；实现的方式是SubType的prototype属性值，不再指向js为它创建的默认原型对象而是指向了SuperType的实例，但是SuperType的实例是指向它自己的默认原型对象的，这样instance也就可以访问SuperType的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SubType.prototype---&gt;SubType Prototype</span><br><span class="line">instance.[[Prototype]]---&gt; SubType Prototype.[[Prototype]]---&gt;SuperType Prototype</span><br><span class="line">SuperType Prototype.constructor---&gt;SuperType</span><br><span class="line">SuperType.prototype ---&gt; SuperType Prototye</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="javascript的原型对象">javascript的原型对象</h4><p>在js中每一个函数都一个原型属性(prototype),它是一个指向另一个对象指针，这个对象可以让同一个函数的所有实例共享属性和方法，这个对象就是原型对象。</p>
<figure c]]>
    </summary>
    
      <category term="原型 原型链 继承" scheme="http://www.flydream.org/tags/%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE-%E7%BB%A7%E6%89%BF/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP内核学习 -- 数组函数 （获取首尾元素）]]></title>
    <link href="http://www.flydream.org/2015/10/16/%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0-3/"/>
    <id>http://www.flydream.org/2015/10/16/数组函数-3/</id>
    <published>2015-10-16T14:40:11.000Z</published>
    <updated>2015-10-18T12:10:20.000Z</updated>
    <content type="html"><![CDATA[<h4 id="PHP_获取数组头尾元素">PHP 获取数组头尾元素</h4><p>array_pop 和array_shift的函數原型如下,位置src/ext/standard/array.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PHP_FUNCTION(array_pop)&#123;</span><br><span class="line">	_phpi_pop(INTERNAL_FUNCTION_PARAM_PASSTHRU,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">PHP_FUNCTION(array_shift)&#123;</span><br><span class="line">	_phpi_php(INTERNAL_FUNCTION_PARAM_PASSTHRU,<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的原型可以看出，获取数组头元素的array_shift 和获取尾元素的函数array_pop在源码中都是通过_phpi_php来处理的，_phpi_php的代码如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _phpi_pop(INTERNAL_FUNCTION_PARAMETES,<span class="keyword">int</span> off_the_end)</span><br><span class="line">&#123;</span><br><span class="line">	zval *<span class="built_in">stack</span>;   <span class="comment">/* Input stack */</span></span><br><span class="line">	     **val;    <span class="comment">/* Value to be popped */</span></span><br><span class="line">	<span class="keyword">char</span> *key = <span class="literal">NULL</span>;</span><br><span class="line">	uint key_len = <span class="number">0</span>;</span><br><span class="line">	ulong index;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"a"</span>,&amp;<span class="built_in">stack</span>) == FAILURE)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;     </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(zend_hash_num_elements(Z_ARRVAL_P(<span class="built_in">stack</span>)) == <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Get the first or last value and copy it into the return value */</span></span><br><span class="line">	<span class="keyword">if</span>(off_the_end)&#123;</span><br><span class="line">		<span class="preprocessor">###HashTable（ht）中成员变量ht-&gt;pInternalPointer 指向链表的末尾即数据的最后一个元素</span></span><br><span class="line">		zend_hash_internal_pointer_end(Z_ARRVAL_P(<span class="built_in">stack</span>));</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="preprocessor">###HashTable（ht）中成员变量ht-&gt;pInternalPointer 指向链表的头即数组的第一个元素</span></span><br><span class="line">		zend_hash_internal_pointer_reset(Z_ARRVAL_P(<span class="built_in">stack</span>));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="preprocessor">###获取目标元素，并存储在val中</span></span><br><span class="line">	zend_hash_get_current_data(Z_ARRVAL_P(<span class="built_in">stack</span>),(<span class="keyword">void</span> **)&amp;val);</span><br><span class="line">	RETVAL_ZVAL_FAST(*val);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/* Delete the first or last value */</span></span><br><span class="line">	zend_hash_get_current_key_ex(Z_ARRVAL_P(<span class="built_in">stack</span>), &amp;key, &amp;key_len, &amp;index, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (<span class="function">key &amp;&amp; <span class="title">Z_ARRVAL_P</span><span class="params">(<span class="built_in">stack</span>)</span> </span>== &amp;EG(symbol_table)) &#123;</span><br><span class="line">		zend_delete_global_variable(key, key_len - <span class="number">1</span> TSRMLS_CC);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="preprocessor">###删除链表中元素 重点就在此重置hasttable中的链表</span></span><br><span class="line">	    zend_hash_del_key_or_index(Z_ARRVAL_P(<span class="built_in">stack</span>), key, key_len, index, (key) ? HASH_DEL_KEY : HASH_DEL_INDEX);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* If we did a shift... re-index like it did before */</span></span><br><span class="line">	<span class="keyword">if</span> (!off_the_end) &#123;</span><br><span class="line">		zend_hash_reindex(Z_ARRVAL_P(<span class="built_in">stack</span>), <span class="number">1</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="function">key_len &amp;&amp; <span class="title">Z_ARRVAL_P</span><span class="params">(<span class="built_in">stack</span>)</span>-&gt;nNextFreeElement &gt; 0 &amp;&amp; index &gt;</span>= Z_ARRVAL_P(<span class="built_in">stack</span>)-&gt;nNextFreeElement - <span class="number">1</span>) &#123;</span><br><span class="line">		Z_ARRVAL_P(<span class="built_in">stack</span>)-&gt;nNextFreeElement = Z_ARRVAL_P(<span class="built_in">stack</span>)-&gt;nNextFreeElement - <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">       <span class="preprocessor">### ht-&gt;pInternalPointer = ht-&gt;pListHead</span></span><br><span class="line">	zend_hash_internal_pointer_reset(Z_ARRVAL_P(<span class="built_in">stack</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在获取目标元素后，将它复制一份新的，然后返回；但在这期间还有一步很重要的就是HashTable中链表重置（两种链表），zend_hash_del_key_or_index(src/zend/zend_hash.c)函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_hash_del_key_or_index</span><span class="params">(HashTable *ht, <span class="keyword">const</span> 	<span class="keyword">char</span> *arKey, uint nKeyLength, ulong h, <span class="keyword">int</span> flag)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	uint nIndex;</span><br><span class="line">	Bucket *p;</span><br><span class="line"></span><br><span class="line">	IS_CONSISTENT(ht);</span><br><span class="line">	<span class="preprocessor">### 针对string类型的键 计算hash值</span></span><br><span class="line">	<span class="keyword">if</span> (flag == HASH_DEL_KEY) &#123;</span><br><span class="line">		h = zend_inline_hash_func(arKey, nKeyLength);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="preprocessor">### 获取目标元素在arBuckets数组中的位置（arBuckets数组存放着数组中所有元素的实际存储位置）</span></span><br><span class="line">	nIndex = h &amp; ht-&gt;nTableMask;</span><br><span class="line">	</span><br><span class="line">	p = ht-&gt;arBuckets[nIndex];</span><br><span class="line">	<span class="preprocessor">### PHP中哈希冲突是通过拉链法解决的 所以此时的p指向一个由有相同hash值的元素组成的链表的</span></span><br><span class="line">	<span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> ((p-&gt;h == h) </span><br><span class="line">		 	&amp;&amp; (p-&gt;nKeyLength == nKeyLength)</span><br><span class="line">		 	&amp;&amp; ((p-&gt;nKeyLength == <span class="number">0</span>) <span class="comment">/* Numeric index (short circuits the memcmp() check) */</span></span><br><span class="line">			 || !<span class="built_in">memcmp</span>(p-&gt;arKey, arKey, nKeyLength))) &#123; <span class="comment">/*String index */</span></span><br><span class="line">		<span class="preprocessor">### 刚才说到了相同hash组成的链表，还有一个链表就是我们遍历数组使用到的，它维护者元素之间的相对顺序；</span></span><br><span class="line">		<span class="preprocessor">### i_zend_hash_bucket_delete 重置上述两种双向链表</span></span><br><span class="line">		i_zend_hash_bucket_delete(ht, p);</span><br><span class="line">		<span class="keyword">return</span> SUCCESS;</span><br><span class="line">		&#125;</span><br><span class="line">		p = p-&gt;pNext;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> FAILURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="PHP_获取数组头尾元素">PHP 获取数组头尾元素</h4><p>array_pop 和array_shift的函數原型如下,位置src/ext/standard/array.c</p>
<figure class="highlight c"><table><t]]>
    </summary>
    
      <category term="array_pop,array_shift" scheme="http://www.flydream.org/tags/array-pop-array-shift/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP内核学习 --- 数组函数（合并和替换）]]></title>
    <link href="http://www.flydream.org/2015/10/06/%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0-2/"/>
    <id>http://www.flydream.org/2015/10/06/数组函数-2/</id>
    <published>2015-10-06T15:09:59.000Z</published>
    <updated>2015-10-09T22:40:01.000Z</updated>
    <content type="html"><![CDATA[<h4 id="PHP_数组合并和替换">PHP 数组合并和替换</h4><p>函数array_merge,array_merge_recursice,array_replace,array_replace_recursice的源代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PHP_FUNCTION(array_merge)</span><br><span class="line">&#123;</span><br><span class="line">php_array_merge_or_replace_wrapper(INTERNAL_FUNCTION_PARAM_PASSTHRU, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> 	</span><br><span class="line">PHP_FUNCTION(array_merge_recursive)</span><br><span class="line">&#123;</span><br><span class="line">php_array_merge_or_replace_wrapper(INTERNAL_FUNCTION_PARAM_PASSTHRU, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">	</span><br><span class="line">  PHP_FUNCTION(array_replace)</span><br><span class="line">  &#123;</span><br><span class="line"> php_array_merge_or_replace_wrapper(INTERNAL_FUNCTION_PARAM_PASSTHRU, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  PHP_FUNCTION(array_replace_recursive)</span><br><span class="line">  &#123;</span><br><span class="line"> php_array_merge_or_replace_wrapper(INTERNAL_FUNCTION_PARAM_PASSTHRU, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从上述源代码中可以看出处理的核心在php_array_merge_or_replace_wrapper函数中，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">php_array_merge_or_replace_wrapper</span><span class="params">(INTERNAL_FUNCTION_PARAMETERS, <span class="keyword">int</span> recursive, <span class="keyword">int</span> replace)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	zval ***args = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">int</span> argc, i, init_size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"+"</span>, &amp;args, &amp;argc) == FAILURE) &#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (Z_TYPE_PP(args[i]) != IS_ARRAY) &#123;</span><br><span class="line">			php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_WARNING, <span class="string">"Argument #%d is not an array"</span>, i + <span class="number">1</span>);</span><br><span class="line">			efree(args);</span><br><span class="line">			RETURN_NULL();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">int</span> num = zend_hash_num_elements(Z_ARRVAL_PP(args[i]));</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (num &gt; init_size) &#123;</span><br><span class="line">				init_size = num;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	array_init_size(return_value, init_size);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; argc; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!replace) &#123;</span><br><span class="line">			<span class="comment">//数组合并</span></span><br><span class="line">			php_array_merge(Z_ARRVAL_P(return_value), Z_ARRVAL_PP(args[i]), recursive TSRMLS_CC);</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (recursive &amp;&amp; i &gt; <span class="number">0</span>) &#123; <span class="comment">/* First array will be copied directly instead */</span></span><br><span class="line">			php_array_replace_recursive(Z_ARRVAL_P(return_value), Z_ARRVAL_PP(args[i]) TSRMLS_CC);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		zend_hash_merge(Z_ARRVAL_P(return_value), Z_ARRVAL_PP(args[i]), (<span class="keyword">copy_ctor_func_t</span>) zval_add_ref, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(zval *), <span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	efree(args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是php_array_merge 函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">PHPAPI <span class="keyword">int</span> <span class="title">php_array_merge</span><span class="params">(HashTable *dest, HashTable *src, <span class="keyword">int</span> recursive TSRMLS_DC)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span><br><span class="line"></span>&#123;</span><br><span class="line">zval **src_entry, **dest_entry;</span><br><span class="line"><span class="keyword">char</span> *string_key;</span><br><span class="line">uint string_key_len;</span><br><span class="line">ulong num_key;</span><br><span class="line">HashPosition pos;</span><br><span class="line">   <span class="comment">//重置hashtable src的成员变量pInternalPointer</span></span><br><span class="line">zend_hash_internal_pointer_reset_ex(src, &amp;pos);</span><br><span class="line"><span class="comment">//获取hash表中当前元素的地址：即其中某个Bucket的地址</span></span><br><span class="line"><span class="keyword">while</span> (zend_hash_get_current_data_ex(src, (<span class="keyword">void</span> **)&amp;src_entry, &amp;pos) == SUCCESS) &#123;</span><br><span class="line">	<span class="comment">/*获取对应数组中对应元素下标的类型，如果是字符串在返回HASH_KEY_IS_STRING并获取键值和其长度，</span><br><span class="line">	  或者是数字下标，返回HASH_KEY_IS_LONG和其值num_key*/</span></span><br><span class="line">	<span class="keyword">switch</span> (zend_hash_get_current_key_ex(src, &amp;string_key, &amp;string_key_len, &amp;num_key, <span class="number">0</span>, &amp;pos)) &#123;</span><br><span class="line">		<span class="keyword">case</span> HASH_KEY_IS_STRING:</span><br><span class="line">			<span class="keyword">if</span> (<span class="function">recursive &amp;&amp; <span class="title">zend_hash_find</span><span class="params">(dest, string_key, string_key_len, (<span class="keyword">void</span> **)</span>&amp;dest_entry) </span>== SUCCESS) &#123;</span><br><span class="line">				HashTable *thash = Z_TYPE_PP(dest_entry) == IS_ARRAY ? Z_ARRVAL_PP(dest_entry) : <span class="literal">NULL</span>;</span><br><span class="line">				zval *src_zval;</span><br><span class="line">				zval *tmp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> ((thash &amp;&amp; thash-&gt;nApplyCount &gt; <span class="number">1</span>) || (*src_entry == *<span class="function">dest_entry &amp;&amp; <span class="title">Z_ISREF_PP</span><span class="params">(dest_entry)</span> &amp;&amp; <span class="params">(Z_REFCOUNT_PP(dest_entry)</span> % 2))) </span>&#123;</span><br><span class="line">					php_error_docref(<span class="literal">NULL</span> TSRMLS_CC, E_WARNING, <span class="string">"recursion detected"</span>);</span><br><span class="line">					<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				SEPARATE_ZVAL(dest_entry);</span><br><span class="line">			</span><br><span class="line">				<span class="keyword">if</span> (Z_TYPE_PP(dest_entry) == IS_NULL) &#123;</span><br><span class="line">					convert_to_array_ex(dest_entry);</span><br><span class="line">					add_next_index_null(*dest_entry);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					convert_to_array_ex(dest_entry);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (Z_TYPE_PP(src_entry) == IS_OBJECT) &#123;</span><br><span class="line">					ALLOC_ZVAL(src_zval);</span><br><span class="line">					INIT_PZVAL_COPY(src_zval, *src_entry);</span><br><span class="line">					zval_copy_ctor(src_zval);</span><br><span class="line">					convert_to_array(src_zval);</span><br><span class="line">					tmp = src_zval;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					src_zval = *src_entry;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//如果是数组且递归合并 需要递归执行php_array_merge</span></span><br><span class="line">				<span class="keyword">if</span> (Z_TYPE_P(src_zval) == IS_ARRAY) &#123;</span><br><span class="line">					<span class="keyword">if</span> (thash) &#123;</span><br><span class="line">						thash-&gt;nApplyCount++;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (!php_array_merge(Z_ARRVAL_PP(dest_entry), Z_ARRVAL_P(src_zval), recursive TSRMLS_CC)) &#123;</span><br><span class="line">						<span class="keyword">if</span> (thash) &#123;</span><br><span class="line">							thash-&gt;nApplyCount--;</span><br><span class="line">						&#125;</span><br><span class="line">						<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">if</span> (thash) &#123;</span><br><span class="line">						thash-&gt;nApplyCount--;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				   <span class="comment">//不是数组类型，直接新增元素</span></span><br><span class="line">					Z_ADDREF_PP(src_entry);</span><br><span class="line">					zend_hash_next_index_insert(Z_ARRVAL_PP(dest_entry), &amp;src_zval, <span class="keyword">sizeof</span>(zval *), <span class="literal">NULL</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (tmp) &#123;</span><br><span class="line">					zval_ptr_dtor(&amp;tmp);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//不执行递归后者没有发现存在相同元素 则直接更新</span></span><br><span class="line">				Z_ADDREF_PP(src_entry);</span><br><span class="line">				zend_hash_update(dest, string_key, string_key_len, src_entry, <span class="keyword">sizeof</span>(zval *), <span class="literal">NULL</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> HASH_KEY_IS_LONG:</span><br><span class="line">			<span class="comment">//如果是数字下标就不考虑 是否递归的问题，直接hashtable新写入一个元素（即Bucket）</span></span><br><span class="line">			Z_ADDREF_PP(src_entry);</span><br><span class="line">			zend_hash_next_index_insert(dest, src_entry, <span class="keyword">sizeof</span>(zval *), <span class="literal">NULL</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	zend_hash_move_forward_ex(src, &amp;pos);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次，替换功能实现，有两个函数完成: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">PHPAPI <span class="keyword">int</span> <span class="title">php_array_replace_recursive</span><span class="params">(HashTable *dest, HashTable *src TSRMLS_DC)</span> <span class="comment">/* &#123;&#123;&#123; */</span></span><br><span class="line"></span>&#123;</span><br><span class="line">zval **src_entry, **dest_entry;</span><br><span class="line"><span class="keyword">char</span> *string_key;</span><br><span class="line">uint string_key_len;</span><br><span class="line">ulong num_key;</span><br><span class="line">HashPosition pos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (zend_hash_internal_pointer_reset_ex(src, &amp;pos);</span><br><span class="line">     zend_hash_get_current_data_ex(src, (<span class="keyword">void</span> **)&amp;src_entry, &amp;pos) == SUCCESS;</span><br><span class="line">     zend_hash_move_forward_ex(src, &amp;pos)) &#123;</span><br><span class="line">	<span class="keyword">switch</span> (zend_hash_get_current_key_ex(src, &amp;string_key, &amp;string_key_len, &amp;num_key, <span class="number">0</span>, &amp;pos)) &#123;</span><br><span class="line">		<span class="keyword">case</span> HASH_KEY_IS_STRING:</span><br><span class="line">			<span class="keyword">if</span> (Z_TYPE_PP(src_entry) != IS_ARRAY ||</span><br><span class="line">				zend_hash_find(dest, string_key, string_key_len, (<span class="keyword">void</span> **)&amp;dest_entry) == FAILURE ||</span><br><span class="line">				Z_TYPE_PP(dest_entry) != IS_ARRAY) &#123;</span><br><span class="line"></span><br><span class="line">				Z_ADDREF_PP(src_entry);</span><br><span class="line">				zend_hash_update(dest, string_key, string_key_len, src_entry, <span class="keyword">sizeof</span>(zval *), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">case</span> HASH_KEY_IS_LONG:</span><br><span class="line">			<span class="keyword">if</span> (Z_TYPE_PP(src_entry) != IS_ARRAY ||</span><br><span class="line">				zend_hash_index_find(dest, num_key, (<span class="keyword">void</span> **)&amp;dest_entry) == FAILURE ||</span><br><span class="line">				Z_TYPE_PP(dest_entry) != IS_ARRAY) &#123;</span><br><span class="line"></span><br><span class="line">				Z_ADDREF_PP(src_entry);</span><br><span class="line">				zend_hash_index_update(dest, num_key, src_entry, <span class="keyword">sizeof</span>(zval *), <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      ..........</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我列出了这个函数的关键部分，待合并的元素是键值是数字还是字符串，不同的键值类型处理方式不同，键值：调用zend_hash_update,数字下标：zend_hash_index_update</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="PHP_数组合并和替换">PHP 数组合并和替换</h4><p>函数array_merge,array_merge_recursice,array_replace,array_replace_recursice的源代码如下：</p>
<figure class="]]>
    </summary>
    
      <category term="array_merge,array_merge_recursice,array_replace_recursice,array_replace" scheme="http://www.flydream.org/tags/array-merge-array-merge-recursice-array-replace-recursice-array-replace/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP内核学习 --- 数组函数 （值排序和键排序）]]></title>
    <link href="http://www.flydream.org/2015/10/06/%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0-1/"/>
    <id>http://www.flydream.org/2015/10/06/数组函数-1/</id>
    <published>2015-10-06T07:34:23.000Z</published>
    <updated>2015-10-07T04:03:31.000Z</updated>
    <content type="html"><![CDATA[<h4 id="PHP_数组排序">PHP 数组排序</h4><p>PHP中数组arsort的源代码：src/ext/standard/array.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">PHP_FUNCTION(arsort)&#123;</span><br><span class="line">	zval *<span class="built_in">array</span>;</span><br><span class="line">	<span class="keyword">long</span> sort_type = PHP_SORT_REGULAR;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC,<span class="string">"a|l"</span>,$<span class="built_in">array</span>,&amp;sort_type) == FAILURE)&#123;</span><br><span class="line">		RETURN_FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	php_set_compare_func(sort_type TSRMLS_CC);</span><br><span class="line">	<span class="comment">//数组排序的zend实现</span></span><br><span class="line">	<span class="keyword">if</span> (zend_hash_sort(Z_ARRVAL_P(<span class="built_in">array</span>), zend_qsort, php_array_reverse_data_compare, <span class="number">0</span> TSRMLS_CC) == FAILURE) &#123;</span><br><span class="line">		RETURN_FALSE;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	RETURN_TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>除了之外的三个函数：asort，ksort，krsort 的源代码与上述代码类似；它们实现的核心都在第11行的zend_hash_sort函数中。下面是zend_hash_sort的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">				</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">int</span> <span class="title">zend_hash_sort</span><span class="params">(HashTable *ht, sort_func_t sort_func,compare_func_t compar, </span><br><span class="line"><span class="keyword">int</span> renumber TSRMLS_DC)</span></span>&#123;</span><br><span class="line">	Bucket **arTmp;  <span class="comment">// 新的Bucket数组 数组元素为Bucket类型指针</span></span><br><span class="line">	Bucket *p;</span><br><span class="line">	<span class="keyword">int</span> i, j;</span><br><span class="line"></span><br><span class="line">	IS_CONSISTENT(ht);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!(ht-&gt;nNumOfElements&gt;<span class="number">1</span>) &amp;&amp; !(renumber &amp;&amp; ht-&gt;nNumOfElements&gt;<span class="number">0</span>)) &#123; <span class="comment">/* Doesn't require sorting */</span></span><br><span class="line">		<span class="keyword">return</span> SUCCESS;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*</span><br><span class="line">	 * 保存哈希表中每个Bucket对应指针到数组arTmp中</span><br><span class="line">	 */</span></span><br><span class="line">	arTmp = (Bucket **) pemalloc(ht-&gt;<span class="function">nNumOfElements * <span class="title">sizeof</span><span class="params">(Bucket *)</span>, ht-&gt;persistent)</span>;</span><br><span class="line">	p = ht-&gt;pListHead;</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (p) &#123;</span><br><span class="line">		arTmp[i] = p;</span><br><span class="line">		p = p-&gt;pListNext;</span><br><span class="line">		i++;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//zend实现的快速排序 ,对Bucket重新排序，</span></span><br><span class="line">	(*sort_func)((<span class="keyword">void</span> *) arTmp, i, <span class="keyword">sizeof</span>(Bucket *), compar TSRMLS_CC);</span><br><span class="line"></span><br><span class="line">	HANDLE_BLOCK_INTERRUPTIONS();</span><br><span class="line">	</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//34 - 50行</span></span><br><span class="line">    <span class="comment">//重置hash表中双向链表的节点（即Bucket）顺序</span></span><br><span class="line">	ht-&gt;pListHead = arTmp[<span class="number">0</span>];           </span><br><span class="line">	ht-&gt;pListTail = <span class="literal">NULL</span>;</span><br><span class="line">	ht-&gt;pInternalPointer = ht-&gt;pListHead;    <span class="comment">//ht-&gt;pInternalPointe:遍历数组元素</span></span><br><span class="line"></span><br><span class="line">	arTmp[<span class="number">0</span>]-&gt;pListLast = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (i &gt; <span class="number">1</span>) &#123;</span><br><span class="line">		arTmp[<span class="number">0</span>]-&gt;pListNext = arTmp[<span class="number">1</span>];</span><br><span class="line">		<span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; i-<span class="number">1</span>; j++) &#123;</span><br><span class="line">			arTmp[j]-&gt;pListLast = arTmp[j-<span class="number">1</span>];</span><br><span class="line">			arTmp[j]-&gt;pListNext = arTmp[j+<span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">		arTmp[j]-&gt;pListLast = arTmp[j-<span class="number">1</span>];</span><br><span class="line">		arTmp[j]-&gt;pListNext = <span class="literal">NULL</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		arTmp[<span class="number">0</span>]-&gt;pListNext = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	ht-&gt;pListTail = arTmp[i-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	pefree(arTmp, ht-&gt;persistent);</span><br><span class="line">	HANDLE_UNBLOCK_INTERRUPTIONS();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (renumber) &#123;</span><br><span class="line">		zend_hash_reindex(ht, <span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PHP中hashtable 中两种双向链表，第一种：所有数组元素（Bucket）组成的双向链表，默认下各个元素之间的顺序是创建时的顺序，它们之间是通过结构体HashTable中的pListHead和pListTail 以及 结构体Bucket中的pListNext、pListLast来组成的双向链表的；第二种：就是同一个key下对应相同的hash值，即有些Bucket的成员变量h值相同，它们之间组成第二种双向链表。 以上四种数组排序就是按照Bucket中的某个成员变量快速排序之后，重置第一种链表中节点的相对顺序。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="PHP_数组排序">PHP 数组排序</h4><p>PHP中数组arsort的源代码：src/ext/standard/array.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><p]]>
    </summary>
    
      <category term="数组值value:arsort asort;数组key排序:krsort ksort" scheme="http://www.flydream.org/tags/%E6%95%B0%E7%BB%84%E5%80%BCvalue-arsort-asort-%E6%95%B0%E7%BB%84key%E6%8E%92%E5%BA%8F-krsort-ksort/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP内核学习 --- 字符串函数 strstr,stristr,strpos,substr]]></title>
    <link href="http://www.flydream.org/2015/10/06/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%87%BD%E6%95%B0-1/"/>
    <id>http://www.flydream.org/2015/10/06/字符串函数-1/</id>
    <published>2015-10-06T03:26:15.000Z</published>
    <updated>2015-10-06T04:55:41.000Z</updated>
    <content type="html"><![CDATA[<h3 id="PHP_字符串函数（strstr,stristr,strpos,substr）">PHP 字符串函数（strstr,stristr,strpos,substr）</h3><h4 id="1-_strstr,stristr,strpos,">1. strstr,stristr,strpos,</h4><p>strstr - 查找字符串的首次出现，stristr功能一样但区分大小写；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="built_in">string</span> $haystack,mixed $needle,<span class="keyword">bool</span> $before_needle = <span class="literal">false</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>还有就是如果想仅仅确定needle是否存在于haystack中，更好地选择是strpos函数。<br>内置字符串函数的代码位置：源码文件/ext/standard/string.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PHP_FUNCTION(<span class="built_in">strstr</span>)&#123;</span><br><span class="line">	zval *needle;</span><br><span class="line">	<span class="keyword">char</span> *haystack;</span><br><span class="line">	<span class="keyword">int</span> haystack_len;</span><br><span class="line">	<span class="keyword">char</span> *found = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">char</span> needle_char[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">long</span> found_offset;</span><br><span class="line">	zend_bool part = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	.....</span><br><span class="line">		found = php_memnstr(haystack, Z_STRVAL_P(needle), Z_STRLEN_P(needle), haystack + haystack_len);</span><br><span class="line">	.....</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中核心的函数就是php_memnstr(),参数说明主字符串的指针，子串也就是被查字符串的指针，子字符串的长度，主字符串的末尾指针； 特别说明一点：php_memnstr只不过是定义的一个宏：#define php_memnstr zend_memnstr,<br>真正的函数实现：源码目录/Zend/zend_operators.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">char</span> * <span class="title">zend_memnstr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *haystack, <span class="keyword">const</span> <span class="keyword">char</span> *needle, <span class="keyword">int</span> needle_len, <span class="keyword">char</span> *end)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *p = haystack;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> ne = needle[needle_len-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (needle_len == <span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">char</span> *)<span class="built_in">memchr</span>(p, *needle, (end-p));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (needle_len &gt; end-haystack) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 最差情况下，不需要遍历到主字符串的末尾，end-=needl_len,就是遍历的终点 </span></span><br><span class="line">	end -= needle_len;  </span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (p &lt;= end) &#123;</span><br><span class="line">	   <span class="comment">//先比较头尾是否一致，达到排除掉只有末尾字符不相符的情况，减少比较的次数</span></span><br><span class="line">		<span class="keyword">if</span> ((p = (<span class="keyword">char</span> *)<span class="built_in">memchr</span>(p, *needle, (end-p+<span class="number">1</span>))) &amp;&amp; ne == p[needle_len-<span class="number">1</span>]) &#123; 				<span class="keyword">if</span> (!<span class="built_in">memcmp</span>(needle, p, needle_len-<span class="number">1</span>)) &#123;</span><br><span class="line">				<span class="keyword">return</span> p;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		p++;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数有其实就是字符串的简单匹配，没用使用KMP算法，但也做了一些改进，如注释。<br>以上注释中的两处是暴力字符匹配中源码的两处改进的地方。<br>strstr和stristr的区别就是 后者会把字符串转成统一的小写,代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">PHPAPI <span class="keyword">char</span> *<span class="title">php_stristr</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">char</span> *t, size_t s_len, size_t t_len)</span></span>&#123;</span><br><span class="line">	php_strtolower(s,s_len);</span><br><span class="line">	php_strtolower(t,t_len);</span><br><span class="line">	<span class="keyword">return</span> php_memnstr(s,t,t_len,s+s_len);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-substr">2.substr</h4><p>substr 函数在php 5.2中在将截取之后原字符串也会发生变化，这应该是个bug，在php 5.6.13中没有出现这个问题。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="PHP_字符串函数（strstr,stristr,strpos,substr）">PHP 字符串函数（strstr,stristr,strpos,substr）</h3><h4 id="1-_strstr,stristr,strpos,">1. strstr,st]]>
    </summary>
    
      <category term="PHP strstr,stristr,substr" scheme="http://www.flydream.org/tags/php-strstr-stristr-substr/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP 内核学习 --- 扩展结构]]></title>
    <link href="http://www.flydream.org/2015/08/25/ext-struct/"/>
    <id>http://www.flydream.org/2015/08/25/ext-struct/</id>
    <published>2015-08-24T22:43:57.000Z</published>
    <updated>2015-08-25T23:39:14.000Z</updated>
    <content type="html"><![CDATA[<h3 id="PHP的扩展结构">PHP的扩展结构</h3><p>通过php下源码目录下的ext_skel 工具创建一个自己的扩展 “./configure –extname=wwbext”, 下面来了解一下一个扩展的框架结构：</p>
<p>一个扩展通常有6部分组成：<br> 1.引入头文件<br> 2.声明导出函数<br> 3.声明Zend函数块<br> 4.声明Zend模块<br> 5.实现get_module()函数<br> 6.实现导出函数</p>
<h4 id="1-头文件">1.头文件</h4><p>在php扩展中，必须要引入一个php.h的头文件（main目录下）。它包含扩展所需要的宏和API定义。</p>
<h4 id="2-导出函数声明">2.导出函数声明</h4><p>通过声明和实现导出函数，php脚本才能访问到我们所编写的扩展中的函数和类。<br>导出函数的声明形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">zif_wwbext</span><span class="params">(</span><br><span class="line">	<span class="keyword">int</span> ht,</span><br><span class="line">	zval *return_value,</span><br><span class="line">	zval *this_ptr,</span><br><span class="line">	<span class="keyword">int</span> return_value_used,</span><br><span class="line">	zend_executor_globals *executor_globals</span><br><span class="line">)</span></span>;</span><br></pre></td></tr></table></figure>
<p>其中导出函数5个参数的作用：<br>ht：保存扩展函数参数的个数，通过ZEND_NUM_ARGS()宏访问<br>return_value:保存扩展函数的返回值<br>this_ptr:获得扩展函数所属的对象<br>return_value_used:标识函数的返回值是否为脚本所使用，1：是 ，0：否<br>executor_globals：指向Zend引擎的全局设置,通过TSRMLS_FETCH()引用这个值</p>
<h4 id="3-Zend函数块">3.Zend函数块</h4><p>虽然声明的导出函数，但是Zend引擎不会自动引入导出函数，这个时候我们需要zend_function_entry结构体</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _zend_function_entry&#123;</span><br><span class="line">	<span class="keyword">char</span> *fname;</span><br><span class="line">	<span class="keyword">void</span> (*handler) (INTERNAL_FUNCTION_PARAMETERS);</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> * func_arg_types;</span><br><span class="line">&#125;zend_function_entry;</span><br></pre></td></tr></table></figure>
<p>成员变量的含义：<br>fname:PHP脚本里调用的函数名<br>handler：C函数句柄，在这里就是导出函数的句柄<br>func_arg_types:一个参数是否强制按引用方式传递，一般为NULL<br>Zend引擎通过zend_function_entry结构数组把导出函数引入内部</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> zend_function_entry wwbext_functions[]=&#123;</span><br><span class="line">	PHP_FE(confirm_wwbext_complied,<span class="literal">NULL</span>)</span><br><span class="line">	PHP_FE_END</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>导入大致过程：循环zend_function_entry数组，依次将函数载入内核函数表</p>
<h4 id="4-声明Zend模块">4.声明Zend模块</h4><p>PHP的扩展信息都保存在zend_module_entry结构中，这个结构包含zend引擎需要知道的模块信息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">tpyedef <span class="keyword">struct</span> _zend_module_entry zend_module_entry;</span><br><span class="line"><span class="keyword">struct</span> _zend_module_entry&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> size;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> zend_api;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> zend_api;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> zts;</span><br><span class="line">	<span class="keyword">char</span> *name;</span><br><span class="line">	zend_function_entry *functions;</span><br><span class="line">	<span class="keyword">int</span> (*module_startup_func)(INT_FUNC_ARGS);</span><br><span class="line">	<span class="keyword">int</span> (*module_shutdown_func) (SHUTDOWM_FUNC_ARGS);</span><br><span class="line">	<span class="keyword">int</span> (*request_startup_func) (INT_FUNC_ARGS);</span><br><span class="line">	<span class="keyword">int</span> (*request_shutdown_func) (SHUTDOWN_FUNC_AGGS);</span><br><span class="line">	<span class="keyword">void</span> (*info_func) (ZEND_MODULE_INFO_FUNC_ARGS);</span><br><span class="line">	<span class="keyword">char</span> *version;</span><br><span class="line">	.............</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前四个成员通过STANDARD_MOUDLE_HEADER宏来填充；name:模块名； functions:第三部分的Zend的函数块指针；module_startup_func:模块初始化函数，可以通过宏ZEND_MINIT来启动；module_end_func:模块结束函数，对应的宏ZEND_MSHUTDOWN;request_startup_func:请求启动函数，宏ZEND_RMINIT；request_end_func:请求关闭函数，对应的宏ZEND_RSHUTDOWN，最后的versiion代表版本信息。<br>具体到我们的新扩展wwbext，结构如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">zend_moudle_entry wwbext_module_entry = &#123;</span><br><span class="line">	STANDARD_MOUDLE_HEADER,</span><br><span class="line">	<span class="string">"wwbext"</span>,</span><br><span class="line">	wwbext_functions,</span><br><span class="line">	PHP_MINIT(wwbext),</span><br><span class="line">	PHP_MSHUTDOWN(wwbext),</span><br><span class="line">	PHP_RINIT(wwext),</span><br><span class="line">	PHP_RSHUTDOWN(wwbext)</span><br><span class="line">	PHP_WWBEXT_VERSION,</span><br><span class="line">	STANDARD_MOUDLE_PROPERTIES</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-get_module()函数">5.get_module()函数</h4><p>当wwbext这个扩展被动态加载时回去调用get_module函数，实现过程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">ifdef</span> COMPILE_DL_WWBEXT</span></span><br><span class="line">ZEND_GET_MODULE(wwbext)</span><br><span class="line"><span class="preprocessor">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>ZEND_GET_MODULE宏的张开如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> ZEND_GET_MOUDLE(name) \</span><br><span class="line">	ZEND_DLEXPORT zend_module_entry *get_module(void)&#123;\</span><br><span class="line">		return &amp;name##_module_entry;\</span><br><span class="line">	&#125;</span></span><br></pre></td></tr></table></figure>
<p>通过get_module函数的zend模块指针就是第四部分的模块指针，所以PHP内核和扩展是通过get_module来通信的。</p>
<h4 id="6-导出函数">6.导出函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">PHP_FUNCTION(confirm_wwbext_compiledd)&#123;</span><br><span class="line">	<span class="keyword">char</span> *arg = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">size_t</span> arg_len,len;</span><br><span class="line">	zend_string *<span class="built_in">string</span>;</span><br><span class="line">	<span class="keyword">if</span>(zend_parse_parameters(ZEND_NUM_ARGS(),<span class="string">"s"</span>,$arg,$arg_len) == FAILURE)&#123;</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	strg = strpprintf(<span class="number">0</span>, <span class="string">"Congratulations! You have successfully modified ext/%.78s/config.m4. Module %.78s is now compiled into PHP."</span>, <span class="string">"wwbext"</span>, arg);</span><br><span class="line">RETURN_STR(strg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到此扩展的最后一步实现导函数，通过总结发现PHP内核和扩展通信是通过get_moduleh获取模块，而模块又是通过导出函数获取扩展内的自定义函数放入zend_function_entry数组，来完成我们的扩展函数可以在脚本中调用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="PHP的扩展结构">PHP的扩展结构</h3><p>通过php下源码目录下的ext_skel 工具创建一个自己的扩展 “./configure –extname=wwbext”, 下面来了解一下一个扩展的框架结构：</p>
<p>一个扩展通常有6部分组成：<br>]]>
    </summary>
    
      <category term="php扩展结构" scheme="http://www.flydream.org/tags/php%E6%89%A9%E5%B1%95%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP内核学习 -- new hashtable in php 7]]></title>
    <link href="http://www.flydream.org/2015/08/11/hashtable/"/>
    <id>http://www.flydream.org/2015/08/11/hashtable/</id>
    <published>2015-08-10T22:21:38.000Z</published>
    <updated>2016-02-21T13:49:35.000Z</updated>
    <content type="html"><![CDATA[<h3 id="PHP7_HashTable"><strong>PHP7</strong> <strong>HashTable</strong></h3><p>【原文链接】（<a href="http://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html" target="_blank" rel="external">http://nikic.github.io/2014/12/22/PHPs-new-hashtable-implementation.html</a> ）<br>本文将概述hashtable在php7的实现，和为什么新的hashtable会更加高效。</p>
<p>本质上讲，PHP的数组就是一个有序的词典，一个有序的键/值对列表，而这种key/value的映射关系是通过hashtable来实现的。</p>
<p>hashtable的概念是简单地来讲：字符串键值通过哈希函数得到一个数字，而这个数字是一个常规数组的下标。但是两个不同的键值可能经过哈希函数后得到两个相同的值，所以hashtable的实现还要解决哈希冲突。</p>
<p>哈希冲突的基本解决办法有两种：一种是开放地址，另一种是链式法；PHP中使用了第二种，下面直接描述PHP中的hashtable是如何实现的，新一代PHP引擎的hashtable有什么不同，为什么更高效？</p>
<h4 id="hashtable在PHP中5的实现">hashtable在PHP中5的实现</h4><p>下图是php5中hashtable实现的简述：<br><img src="http://wangwenbo.github.io/image/hashtabl1.png" alt="Hashtable png"><br>如上图，a,b,c这些键值所对应的值存在“bucket”结构中，每一个bucket都是独立分配空间的，而buckets组成互相之间独立的链表来解决哈希冲突。<br>另外除此之外，还有一个链表来保存元素的顺序（如：数组中的元素顺序是它的插入顺序），数组键值“a”,“b”，“c”，它对应的链表就应该是下面这个样子：<br><img src="http://wangwenbo.github.io/image/hashtable2.png" alt="Hashtable2 png"><br>这中hashtable实现在内存使用和执行低效的原因有以下几个原因：</p>
<ol>
<li>bucket 要独立分配。每次分配都要额外占用内存。同时独立分配就意味着bucket的地址相对分散，影响缓存效率。</li>
<li>zvals 也要单独分配而且 每一个bucket要保存同一个zval的指针。<h4 id="zval在PHP7中的实现">zval在PHP7中的实现</h4>在介绍新的hahstable之前，先来看一下新的zval结构：</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">   <span class="keyword">struct</span> _zval_struct &#123;    </span><br><span class="line">	zend_value value;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span> &#123;</span><br><span class="line">			ZEND_ENDIAN_LOHI_4(</span><br><span class="line">				zend_uchar type,</span><br><span class="line">				zend_uchar type_flags,</span><br><span class="line">				zend_uchar const_flags,</span><br><span class="line">				zend_uchar reserved)</span><br><span class="line">			&#125; v;</span><br><span class="line">		<span class="keyword">uint32_t</span> type_info;</span><br><span class="line">	&#125; u1;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">uint32_t</span> var_flags;</span><br><span class="line">		<span class="keyword">uint32_t</span> next;       <span class="comment">/* hash collision chain */</span></span><br><span class="line">		<span class="keyword">uint32_t</span> cache_slot; <span class="comment">/* literal cache slot */</span></span><br><span class="line">		<span class="keyword">uint32_t</span> lineno;     <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line">	&#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个zval结构有三部分组成，第一部分zend_value 负责存储实际的变量值；第二部分的type_info 代表变量的类型，从而决定第一部分的实际存储的值；第三部分不得经常使用到。在特殊的上下文下 存储一些特别的信息，比如：抽象语法树用它来存储行号，VM constants 用它来存储缓存索引，以及hashtable中存储哈希碰撞是之下链表的下一个元素。</p>
<p>新旧zval之间的明显区别就是新的zval实现中不再有引用字段。原因就是zvals不再独立申请分配。而是嵌入到了存储它的结构中，比如hashtable。</p>
<p>虽然    zval自身不再包含引用字段，但是像string，array，object和resouce等类型的值依然在使用引用字段。这样做的优势：<br>   1.Zvals storing simple values (like booleans, integers or floats) no longer require any allocations. So this saves the allocation header overhead and improves performance by avoiding unnecessary allocs and frees and improving cache locality.</p>
<p>   2.Zvals storing simple values don’t need to store a refcount and GC root buffer.   </p>
<p>   3.We avoid double refcounting. E.g. previously objects both used the zval refcount and an additional object refcount, which was    necessary to support by-object passing semantics.</p>
<p>   4.As all complex values now embed a refcount, they can be shared independently of the zval mechanism. In particular it is now also possible to share strings. This is important to the hashtable implementation, as it no longer needs to copy non-interned string keys.</p>
<h4 id="hashtable_in_PHP7">hashtable in PHP7</h4><p>php中的哈希边有两部组成：HashTable和Bucket</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _Bucket&#123;</span><br><span class="line">	zend_ulong h;</span><br><span class="line">	zend_string *key;</span><br><span class="line">	zval  val;</span><br><span class="line">&#125; Bucket;</span><br></pre></td></tr></table></figure>
<p>Buckets是哈希表中重要的组成。在Buckets包含hash h，键值key和zval的值。同时zval嵌入到Bucket中，就和Bucket一起分配资源减少单独操作的开销。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _HashTable&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> nTableSize;  <span class="comment">//哈希表大小</span></span><br><span class="line">	<span class="keyword">uint32_t</span> nTableMask;</span><br><span class="line">	<span class="keyword">uint32_t</span> nNumUsed;</span><br><span class="line">	<span class="keyword">uint32_t</span> nNumOfElements;</span><br><span class="line">	zend_long nNextFreeElement;</span><br><span class="line">	Bucket    *arData;	</span><br><span class="line">	<span class="keyword">uint32_t</span>  *arHash;</span><br><span class="line">	<span class="keyword">dtor_func_t</span> pDestructor;</span><br><span class="line">	<span class="keyword">uint32_t</span> nInternalPointer;</span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="keyword">struct</span>&#123;</span><br><span class="line">			ZEND_ENDIAN_LOHI_3(</span><br><span class="line">				zend_uchar flags,</span><br><span class="line">				zend_uchar nApplyCount,</span><br><span class="line">				<span class="keyword">uint16_t</span> reserve)</span><br><span class="line">		&#125; v;</span><br><span class="line">		<span class="keyword">uint32_t</span> flags;</span><br><span class="line">	&#125; u;</span><br><span class="line">&#125; HashTable;</span><br></pre></td></tr></table></figure>
<p>arData数组中直接存储Bucket内容，而不是每个Bucket的指针，这样减少了独立分配每个Bucket和释放的开销。</p>
<h4 id="HashTbale中的元素顺序">HashTbale中的元素顺序</h4><p>数组arData的元素顺序是由写入顺序决定的，与key之无关。nNumUsed代表arData中已经分配的大小，nNumOfElements代表arData中实际元素的多少。两个字段看似代表的是同一个意思，那为什么还要设置两个变量？</p>
<pre><code>&lt;?php
    <span class="variable">$array</span> = [<span class="string">'foo'</span>=&gt;<span class="number">0</span>,<span class="string">'bar'</span>=&gt;<span class="number">1</span>,<span class="number">0</span>=&gt;<span class="number">2</span>,<span class="string">'xyz'</span>=&gt;<span class="number">3</span>,<span class="number">2</span>=&gt;<span class="number">4</span>];
    unset(<span class="variable">$array</span>[<span class="number">0</span>]);
    unset(<span class="variable">$array</span>[<span class="string">'xyz'</span>]);
?&gt;
</code></pre><p>此时的arData：nTableSize = 8 ；nNumOfElements = 3 ；nNumUsed = 5<br>[0]: key=”foo”, val=int(0)<br>[1]: key=”bar”, val=int(1)<br>“<a href="val=UNDEF">2</a>: val=UNDEF“<br>“<a href="val=UNDEF">3</a>: val=UNDEF“<br>[4]: h=2, val=int(4)<br>[5]: NOT INITIALIZED<br>[6]: NOT INITIALIZED<br>[7]: NOT INITIALIZED</p>
<p>那我们上面的数组遍历时，我们却到不到 下标为2和3的值，数组的遍历过程如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uint32_t</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt; ht-&gt;nUumhashbiaoUsed;++i)&#123;</span><br><span class="line">	Bucket *b = &amp;ht-&gt;arData[i];</span><br><span class="line">	<span class="keyword">if</span>(Z_ISUNDEF(b-&gt;val)) <span class="keyword">continue</span>;</span><br><span class="line">	<span class="comment">//处理Bucket</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="PHP7_HashTable"><strong>PHP7</strong> <strong>HashTable</strong></h3><p>【原文链接】（<a href="http://nikic.github.io/2014/12/22/PHPs-new-h]]>
    </summary>
    
      <category term="php7 hashtable" scheme="http://www.flydream.org/tags/php7-hashtable/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[php7_1]]></title>
    <link href="http://www.flydream.org/2015/08/09/php7-1/"/>
    <id>http://www.flydream.org/2015/08/09/php7-1/</id>
    <published>2015-08-09T13:03:49.000Z</published>
    <updated>2016-02-21T13:45:04.000Z</updated>
    <content type="html"><![CDATA[<h3 id="PHP7_变量的内核实现_-Part_1">PHP7 变量的内核实现 -Part 1</h3><p>【原文链接】（<a href="http://nikic.github.io/2015/05/05/Internal-value-representation-in-PHP-7-part-1.html" target="_blank" rel="external">http://nikic.github.io/2015/05/05/Internal-value-representation-in-PHP-7-part-1.html</a> ）<br>我的上一篇文章描述了在PHP7中hashtable实现的改进。接下来我们来看一下PHP中变量新的实现形式。<br>因为这部分内容涉及较多的内容，所以它被分成两部分：第一部分来描述PHP5和PHP7在zval（Zend value）实现上的不同之处，同时也会涉及引用的实现。第二部分将会详细地探究一些类型的变量的实现，如string，object等变。</p>
<h3 id="Zvals_in_PHP5">Zvals in PHP5</h3><p>PHP5中zval的结构体定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _zval_struct&#123;</span><br><span class="line">	zvalue_value value;</span><br><span class="line">	zend_uint refcount_gc;</span><br><span class="line">	zend_uchar type;</span><br><span class="line">	zend_uchar is_ref_gc;</span><br><span class="line">&#125; zval;</span><br></pre></td></tr></table></figure>
<p>正如你已经看到的，一个zval结构体由 value，type还有_gc成员组成。其中value是一个联合体，它用来存储不同的变量值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> _zvalue_value&#123;</span><br><span class="line">	<span class="keyword">long</span> lval;            <span class="comment">//存储布尔值，整型和资源类型</span></span><br><span class="line">	<span class="keyword">double</span> dval;          <span class="comment">//浮点数</span></span><br><span class="line">	<span class="keyword">struct</span>&#123;</span><br><span class="line">		<span class="keyword">char</span> *val;</span><br><span class="line">		<span class="keyword">int</span> len;</span><br><span class="line">	&#125; str;                 <span class="comment">//字符串</span></span><br><span class="line">	HashTable *ht;         <span class="comment">//数组</span></span><br><span class="line">	zend_object_value obj; <span class="comment">//对象</span></span><br><span class="line">	zend_ast * ast;		    <span class="comment">//for constant expressions</span></span><br><span class="line">&#125; zvalue_value;</span><br></pre></td></tr></table></figure>
<p>一个C联合体结构一次只能一个成员变量被使用，它的大小有联合体中最大的成员变量决定。联合体中的所有成员变量共享同一块内存，通过你调用不同成员联合体被解释为不同的类型。假如你读取联合体中的lval,那么它的值就是一个有符号的整数。又假如你读取它的dval成员，它的值就是一个双精度浮点数。</p>
<p>zval的属性type存储变量的类型（一个数字），通过type去指定联合体中哪个成员被使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_NULL <span class="number">0</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_LONG <span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_DOUBLE <span class="number">2</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_BOOL <span class="number">3</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_ARRAY <span class="number">4</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_OBJECT <span class="number">5</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_STRING <span class="number">6</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_RESOURCE <span class="number">7</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Special types used for late-binding of constants */</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_CONSTANT <span class="number">8</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_CONSTANT_AST <span class="number">9</span></span></span><br></pre></td></tr></table></figure>
<h3 id="PHP5的引用计数">PHP5的引用计数</h3><p>PHP 5的Zvals是被分配到堆上而且PHP 需要追踪zvals是否当前还在使用或者哪个应该释放。为了上述目的，引用计数被引入：zval的refcount_gc 记录一个zval被“refrenced”的次数。比如 $a = $b =42 ,42（存储在zval中）被两个变量引用，所以它的引用计数42。如果引用计数等于0，那就表示这个zval没有被使用，可以释放。</p>
<p>需要特别注意的是这里提到的引用计数不同于PHP reference（using &amp;）。接下来通过“reference” 和 “PHP reference”在概念上做区分。接下来我们先忽略后者。</p>
<p>一个和引用计数紧密相关的就是“写时复制”：多个变量可以共享以zval，只要它们的值是一样的。如果要修改zval则需要重新复制一个新的zval并在新的zval上更改。</p>
<p>我们来一下探究写时复制：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$a = <span class="number">42</span>; <span class="comment">//$a       -&gt;zval_1(type=IS_LONG,value=42,refcount=1)</span></span><br><span class="line">$b = $a; <span class="comment">//$a,$b    -&gt;zval_1(type=IS_LONG,value=42,refcount=2)</span></span><br><span class="line">$c = $b; <span class="comment">//$a,$b.$c -&gt;zval_1(type=IS_LONG,value=42,refcount=3)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//The following line causes a zval separation</span></span><br><span class="line">$a += <span class="number">1</span>;  <span class="comment">//$b,$c   -&gt;zval_1（type=IS_LONG，value=42，refcount=2）</span></span><br><span class="line">          <span class="comment">//$a      -&gt;zval_2(type=IS_LONG,value=43，refcount=1)</span></span><br><span class="line">          </span><br><span class="line">unset($b); <span class="comment">//$c     -&gt;zval_1(type=IS_LONG,value=42,refcount =1) </span></span><br><span class="line">           <span class="comment">//$a     -&gt;zval_2(type=IS_LONG,value=43,refcount =1)</span></span><br><span class="line">unset($c); <span class="comment">//zval_1 is destoryed, because refcount=0</span></span><br><span class="line">		   <span class="comment">//$a    -&gt;zval_2(type=IS_LONG,value=43,refcount=1)</span></span><br></pre></td></tr></table></figure>
<h3 id="Motivation_for_change">Motivation for change</h3><p>我们一起讨论一下内存占用（64位系统）：首先，zvalue_value联合体中str和obj成员最大为16字节，所以zvalue_value大小是16字节。zval结构体整体大小24字节，zval_gc_info是32字节。在堆上分配zval还需要额外的16字节，因此一个zval总共需要48字节。</p>
<p>从这些方面去考虑zval实现上一些低效的方式。一个仅仅存储整型类型的zval，仅仅需要8个字节。zval的类型标示type只需要一个1字节，却需要填充额外的8个字节。</p>
<p>对于我们真正需要的16个字节，我们还需要16个字节的引用计数和cycle collection以及额外16字节的分配头信息。即使不考虑我们真正需要执行的16个字节的内存分配和释放，其他的操作的内存开销代价也很大。</p>
<p>基于以上内容，提出以下几个问题：简单地整型真的需要存储引用计数，循环收集，堆分配吗？答案是否定的。</p>
<p>关于PHP 5zval实现方式的一些问题总结：</p>
 <ul><br>  <li>Zvals总是要求堆分配</li><br>  <li>即使当zval的值是一个整型并且不可能形成循环嵌套使用时，Zvals依然要引用计数和循环采集信息</li><br>  <li>一些情况下需要相当次数的间接寻址。例如，一个变量的值为对象，这就需要4次指针解引用(4个节点的指针链)。</li><br>  <li>由于直接的引用计数zval，变量值无法在zvals之间共享。比如，一个字符串无法由zval和hashtable 的key共享（hashtable的key与zval的存储方式不同）</li><br> </ul>


<h3 id="PHP7的Zvals">PHP7的Zvals</h3><p>PHP 7中的zval的根本变化是它不再独立堆分配和不再存储引用计数。取而代之的是一些复杂数据类型(strings,arrays,objects)自己存储引用计数。这样做的优势是：</p>
<ul><br>    <li>基本变量类型不再需要堆分配和引用计数</li><br>    <li>不再有双计数。以object为例，只是使用object自己存储的引用计数</li><br>    <li>因为引用计数现在有value自身保存，所以value可以在独立于zval实现共享。一个字符串既可以在zval和hashtable键值之间共享</li><br>    <li>较少的间接寻址，也就说找到所需要的值需要指针跳转的次数减少</li><br></ul>

<p>新zval的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _zval_struct&#123;</span><br><span class="line">	zend_value value;</span><br><span class="line">	<span class="keyword">union</span>&#123;</span><br><span class="line">		<span class="keyword">struct</span>&#123;</span><br><span class="line">			ZEND_ENDIAN_LOHI4&#123;</span><br><span class="line">				zend_uchar type,</span><br><span class="line">				zend_uchar type_flags,</span><br><span class="line">				zend_uchar const_flags,</span><br><span class="line">				zend_uchar reserved</span><br><span class="line">			&#125; v;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">uint32_t</span> type_info;</span><br><span class="line">	&#125; u1;</span><br><span class="line">	<span class="keyword">union</span>&#123;</span><br><span class="line">		<span class="keyword">uint32_t</span> var_flags;</span><br><span class="line">		<span class="keyword">uint32_t</span> next;                <span class="comment">//hash collision chain</span></span><br><span class="line">		<span class="keyword">uint32_t</span> cache_slot;          <span class="comment">//literal cache solt</span></span><br><span class="line">		<span class="keyword">uint32_t</span> lineno;              <span class="comment">//line number(for ast nodes)</span></span><br><span class="line">		<span class="keyword">uint32_t</span> num_args;            <span class="comment">//arguments number for EX(This)</span></span><br><span class="line">		<span class="keyword">uint32_t</span> fe_pos;             <span class="comment">//foreach position</span></span><br><span class="line">		<span class="keyword">uint32_t</span> fe_iter_idx;        <span class="comment">//foreach iterator index</span></span><br><span class="line">	&#125; u2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个成员value依然是一个联合体。第二个成员是整数，保存类型信息（其中 宏ZEND_ENDIAN_LOHI4只是为了跨平台时保持布局一致，因此可以先忽略它）。这个子结构体中重要的是type（与之前zval的type类似）和type_flags, 这两部分详细的解释很快就会涉及。</p>
<p>截止到目前来看，这个结构存在一个小问题；成员value是8字节，由于结构体字节填充最终zval的大小为16字节。然而我们不需要用8个字节去保存一个type。因此zval中又包含了一个u2联合体，u2默认情况下不使用，一旦使用可以用来存储4个字节的数据。其中不同的成员变量对应不同的数据用途。</p>
<p>PHP 7的value成员内部定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> _zend_value&#123;</span><br><span class="line">	zend_long lval;</span><br><span class="line">	<span class="keyword">double</span> dval;</span><br><span class="line">	zend_refcounted *counted;</span><br><span class="line">	zend_string *str;</span><br><span class="line">	zend_array  *arr;</span><br><span class="line">	zend_object *obj;</span><br><span class="line">	zend_resource *res;</span><br><span class="line">	zend_reference *ref;</span><br><span class="line">	zend_ast_ref *ast;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//Ingore these for now , they ara special</span></span><br><span class="line">	zval *zv;</span><br><span class="line">	<span class="keyword">void</span> *ptr;</span><br><span class="line">	zend_class_entry *ce;</span><br><span class="line">	zend_function *func;</span><br><span class="line">	<span class="keyword">struct</span> &#123;</span><br><span class="line">		ZEND_ENDIAN_LOHT(</span><br><span class="line">			<span class="keyword">unint32_t</span> w1,</span><br><span class="line">			<span class="keyword">unint32_t</span> w2</span><br><span class="line">		)</span><br><span class="line">	&#125; ww;</span><br><span class="line">&#125; zend_value;</span><br></pre></td></tr></table></figure>
<p>首先，联合体value是8字节而不再是16字节。它直接保存保存整型（lval）和浮点数（dval），其它类型的变量则存储指针。除了被标记为特殊的成员变量之外，其它类型的指针都使用引用计数和拥有一个共同的header，这个header有zend_refcounted定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _zend_refcounted&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> refcount;</span><br><span class="line">	<span class="keyword">union</span>&#123;</span><br><span class="line">		<span class="keyword">struct</span>&#123;</span><br><span class="line">			ZEND_ENDIAN_LOHI_3(</span><br><span class="line">				zend_uchar type,</span><br><span class="line">				zend_uchar flags,</span><br><span class="line">				<span class="keyword">uint16_t</span>   gc_info)</span><br><span class="line">		&#125;V;</span><br><span class="line">		<span class="keyword">uint32_t</span> type_info;</span><br><span class="line">	&#125; u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>zend_refcounted结构体包含refcount。此外，它还包含type，falgs，gc_info。type是zval的type的复制，GC通过它来区分不同zend_refcounted结构体。falgs对不同的变量类型有不同的用途，这个部分将在第二部分针对不同类型具体解释。</p>
<p>gc_info 相当于旧zval的缓存实体。只不过有原来的一个执行“root buffer“的指针变成一个数字索引。因为这“root buffer”是固定大小（10000elements），可以通过16bit数字来代替64bit指针。gc_info 也可以被encode 进node的color属性中，color被用来在collection是标记node。</p>
<h3 id="Zval_内存管理">Zval 内存管理</h3><p>我已经提到zvals不再单独进行堆分配。但是zvals依然需要被存储在某处，那么这个过程是怎样的哪？zvals依然是堆分配的主要部分，但是它们直接切入到其中。例如，一个哈希bucket 将会直接被嵌入一个zval本身而不再是一个zval的指针。这样一个函数的变量表或者一个对象的属性表将会是一个被分配在统一在内存块中的zval数组，而不是被分在不同的内存块。这样一来，这样的存储实现就减少了间接寻址的次数。</p>
<p>按照先前的zval设计，一旦zval被引用就需要复制一份zval指针和增加引用计数。而现在则要复制一份zval的值，以及如果value需要使用引用计数的话，将引用计数增加。</p>
<p>PHP 怎么判断当前的zval中的value需要被计数？这个不仅仅依靠type来决定，因为一些类型如strings，arrays并不总是需要计数的。我们通过zval的type_info来决定是否需要计算引用。There are a number of other bits encoding properties of the type:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_TYPE_CONSTANT     (<span class="number">1</span>&lt;&lt;<span class="number">0</span>)  <span class="comment">/*special*/</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_TYPE_IMMUTABLE    (<span class="number">1</span>&lt;&lt;<span class="number">1</span>)  <span class="comment">/*special*/</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_TYPE_REFCOUNTED   (<span class="number">1</span>&lt;&lt;<span class="number">2</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_TYPE_COLLECTABLE  (<span class="number">1</span>&lt;&lt;<span class="number">3</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_TYPE_COPYABLE     (<span class="number">1</span>&lt;&lt;<span class="number">4</span>)</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_TYPE_SYMBOLTABLE  (<span class="number">1</span>&lt;&lt;<span class="number">5</span>)   <span class="comment">/*special*/</span></span></span><br></pre></td></tr></table></figure>
<p>变量的类型有三种基本属性，它们分别是“refcounted”,”collectable”和“copyable”。我们已经知道“refcounted（引用计数）”。Collectable 意味着这个 zval可以进行. 例如 字符串这种类型可以有refcounted属性，但是不会出现循环引用自己。</p>
<p>当“duplication”执行时，Copyability 决定value是否需要被复制。一个“duplication”是硬复制，如果复制一个指向array的zval，这不仅仅是增加此array的引用计数。而是新建一个独立的新的zval来指向复制的array。但是objects和resources这种类型，它们的复制操作不是想上面一样，只不过是增加了引用计数。这相当于传递对对象和资源类型的语义。</p>
<p>接下来的表格展示不同变量类型和它们分别对应的falgs。像整型和布尔等基本数据类型不使用指针指向另一个结构体。其中表格中还有一列“immutable” ，它用来标记不可更改的数组，这部分将在第二部分讨论。</p>
<table>
<thead>
<tr>
<th></th>
<th style="text-align:center">refcounted</th>
<th style="text-align:center">collectable</th>
<th style="text-align:center">copyable</th>
<th style="text-align:center">immutable</th>
</tr>
</thead>
<tbody>
<tr>
<td>simple types</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>string</td>
<td style="text-align:center">x</td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>interned string</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>array</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>immutable array</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td>object</td>
<td style="text-align:center">x</td>
<td style="text-align:center">x</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>resource</td>
<td style="text-align:center">x</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>reference</td>
<td style="text-align:center">x</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>基于上面的介绍，我们通过两个例子来看一下新的zval内存管理是怎样的。<br>首先，一个简单地整数类型的例子，不同于前文中PHP5的实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$a = <span class="number">42</span>;    <span class="comment">// $a = zval_1(type = IS_LONG,value=42)</span></span><br><span class="line">$b = $a;    <span class="comment">// $a = zval_1(type=IS_LONG, value=42)</span></span><br><span class="line">               <span class="comment">// $b = zval_2(type=IS_LONG, value=42)</span></span><br><span class="line"></span><br><span class="line">   $a += <span class="number">1</span>;    <span class="comment">// $a = zval_1(type=IS_LONG, value=43)</span></span><br><span class="line">               <span class="comment">// $b = zval_2(type=IS_LONG, value=42)</span></span><br><span class="line"></span><br><span class="line">   unset($a);  <span class="comment">// $a = zval_1(type=IS_UNDEF)</span></span><br><span class="line">               <span class="comment">// $b = zval_2(type=IS_LONG, value=42)</span></span><br></pre></td></tr></table></figure>
<p>整数值不再被多个变量共享，每个变量都有自己对应的zval。这里我用了value = 而不是-&gt;就是要标明值被嵌入在了zval中而没有被重新分配内存。unset一个变量，它的zval变成IS_UNDEF。下面我们看一个更有趣和复杂的例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$a = [ ];   <span class="comment">// $a = zval_1(type=IS_ARRAY) -&gt; zend_array_1(refcount=1, value=[])</span></span><br><span class="line">   $b = $a;    <span class="comment">// $a = zval_1(type=IS_ARRAY) -&gt; zend_array_1(refcount=2, value=[])</span></span><br><span class="line">               <span class="comment">// $b = zval_2(type=IS_ARRAY) ---^</span></span><br><span class="line">   <span class="comment">// Zval separation occurs here</span></span><br><span class="line">   $a[] = <span class="number">1</span>       <span class="comment">// $a = zval_1(type=IS_ARRAY) -&gt; zend_array_2(refcount=1,    value=[1])</span></span><br><span class="line">                  <span class="comment">// $b = zval_2(type=IS_ARRAY) -&gt; zend_array_1(refcount=1, value=[])</span></span><br><span class="line">   unset($a);     <span class="comment">// $a = zval_1(type=IS_UNDEF) and zend_array_2 is destroyed</span></span><br><span class="line">                  <span class="comment">// $b = zval_2(type=IS_ARRAY) -&gt; zend_array_1(refcount=1, value=[])</span></span><br></pre></td></tr></table></figure>
<p>在第二个例子中，不同的变量依然对应一个不同的zval，但是所有的zvals执行同一个zend_array结构体。一旦变量改变就需要重新复制一份新的。这个过程和php 5的工作机制很相似。</p>
<h3 id="Types">Types</h3><p>PHP 7 支持的类型列表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// regular data types</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_UNDEF                    <span class="number">0</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_NULL                     <span class="number">1</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_FALSE                    <span class="number">2</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_TRUE                     <span class="number">3</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_LONG                     <span class="number">4</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_DOUBLE                   <span class="number">5</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_STRING                   <span class="number">6</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_ARRAY                    <span class="number">7</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_OBJECT                   <span class="number">8</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_RESOURCE                 <span class="number">9</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_REFERENCE                <span class="number">10</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// constant expressions</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_CONSTANT                 <span class="number">11</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_CONSTANT_AST             <span class="number">12</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// internal types</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_INDIRECT                 <span class="number">15</span></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> IS_PTR                      <span class="number">17</span></span></span><br></pre></td></tr></table></figure>
<p>这个列表和PHP 5中的很相似，但是还有一些不同：</p>
<p> 1.the IS_UNDEF type is used in places where previously a NULL zval pointer (not to be confused with an IS_NULL zval) was used. For example, in the refcounting examples above the IS_UNDEF type is set for variables that have been unset.<br> 2.The IS_BOOL type has been split into IS_FALSE and IS_TRUE. As such the value of the boolean is now encoded in the type, which allows the optimization of a number of type-based checks. This change is transparent to userland, where this is still a single “boolean” type.<br> 3.PHP references no longer use an is_ref flag on the zval and use a new IS_REFERENCE type instead. How this works will be described in the next section.<br> 4.The IS_INDIRECT and IS_PTR types are special internal types.</p>
<p> The IS_LONG type now uses a zend_long value instead of an ordinary C long. The reason behind this is that on 64-bit Windows (LLP64) a long is only 32-bit wide, so PHP 5 ended up always using 32-bit numbers on Windows. PHP 7 will allow you to use 64-bit numbers if you’re on an 64-bit operating system, even if that operating system is Windows.</p>
<p>Details of the individual zend_refcounted types will be discussed in the next part. For now we’ll only look at the implementation of PHP references.</p>
<h3 id="References">References</h3><p>PHP 7使用了和PHP 5完全不同的方式去处理PHP &amp;引用（这也是PHP7的一个源码级别的bug）。 下面是PHP5中PHP references如何工作的？</p>
<p>通常情况下，写时复制的原理就是在要修改一个变量之前，先将这些变量共享的zval分离，这么做的目的是防止这次更改影响其它变量共享原来的zval。这个相当于语法上的值传递。</p>
<p>对于PHP reference（&amp;），上面的处理方式并不适用。假如一个value是PHP reference，你就是想将改变作用于共享同一个zval的变量。作为PHP 5zvals的一部分is_ref决定一个value是否是PHP reference，也决定了在修改之前是否需要分离zval。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$a = [];  	<span class="comment">// $a     -&gt; zval_1(type=IS_ARRAY, refcount=1, is_ref=0) -&gt; HashTable_1(value=[])</span></span><br><span class="line">$b =&amp; $a; 	<span class="comment">// $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_1(value=[])</span></span><br><span class="line"></span><br><span class="line">$b[] = <span class="number">1</span>; 	<span class="comment">// $a = $b = zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_1(value=[1])</span></span><br><span class="line">         		<span class="comment">// Due to the is_ref=1 PHP will *not* separate the zval</span></span><br></pre></td></tr></table></figure>
<p>这种设计的一个明显的问题就是在引用复制的变量和否引用变量之间无法共享value。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$a = [];  <span class="comment">// $a         -&gt; zval_1(type=IS_ARRAY, refcount=1, is_ref=0) -&gt; HashTable_1(value=[])</span></span><br><span class="line">   $b = $a;  <span class="comment">// $a, $b     -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=0) -&gt; HashTable_1(value=[])</span></span><br><span class="line">   $c = $b   <span class="comment">// $a, $b, $c -&gt; zval_1(type=IS_ARRAY, refcount=3, is_ref=0) -&gt; HashTable_1(value=[])</span></span><br><span class="line"></span><br><span class="line">   $d =&amp; $c; <span class="comment">// $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=0) -&gt; HashTable_1(value=[])</span></span><br><span class="line">             <span class="comment">// $c, $d -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_2(value=[])</span></span><br><span class="line">             <span class="comment">// $d is a reference of $c, but *not* of $a and $b, so the zval needs to be copied</span></span><br><span class="line">             <span class="comment">// here. Now we have the same zval once with is_ref=0 and once with is_ref=1.</span></span><br><span class="line"></span><br><span class="line">   $d[] = <span class="number">1</span>; <span class="comment">// $a, $b -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=0) -&gt; HashTable_1(value=[])</span></span><br><span class="line">             <span class="comment">// $c, $d -&gt; zval_1(type=IS_ARRAY, refcount=2, is_ref=1) -&gt; HashTable_2(value=[1])</span></span><br><span class="line">             <span class="comment">// Because there are two separate zvals $d[] = 1 does not modify $a and $b.</span></span><br></pre></td></tr></table></figure>
<p>PHP5中这种引用行为是php的变量引用比正常使用值慢的其中一个原因。再给出另一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$<span class="built_in">array</span> = range(<span class="number">0</span>, <span class="number">1000000</span>);</span><br><span class="line">$ref =&amp; $<span class="built_in">array</span>;</span><br><span class="line">var_dump(count($<span class="built_in">array</span>)); <span class="comment">// &lt;-- separation occurs here</span></span><br></pre></td></tr></table></figure>
<p>因为count函数接收的是值传递，但是$array是一个PHP reference，因此在执行count函数前先复制一份$array.如果$array不是引用，value就可以共享。</p>
<p>现在，我们转向PHP 7中PHP references的实现。因为zvals不在单独分配，所以不可能使用PHP5的实现方式。<br>PHP7增加了一个新的类型IS_REFERENCE,zend_references结构体来作为它的值：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _zend_reference&#123;</span><br><span class="line">	zend_refcounted gc;</span><br><span class="line">	zval            val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>本质上来讲，一个zend_reference是a refcounted zval。在引用集合里的所用变量都是保存着一个zval，而这个zval的type是IS_REFERENCE,IS_REFERENCE指向相同的zend_reference结构体。<br>让我们站在PHP7的语法角度，重新思考一下上面的代码。为了简洁，下面的代码省略了变量们对应的独立zvals。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$a = [];  <span class="comment">// $a                                     -&gt; zend_array_1(refcount=1, value=[])</span></span><br><span class="line">$b =&amp; $a; <span class="comment">// $a, $b -&gt; zend_reference_1(refcount=2) -&gt; zend_array_1(refcount=1, value=[])</span></span><br><span class="line"></span><br><span class="line">$b[] = <span class="number">1</span>; <span class="comment">// $a, $b -&gt; zend_reference_1(refcount=2) -&gt; zend_array_1(refcount=1, value=[1])</span></span><br></pre></td></tr></table></figure>
<p>通过引用创建了一个zend_reference。zend_reference的refcount=2是因为引用集合有两个变量，value自身的refcount=1是因为只有一个zend_reference指向它。先我们来看一下引用和非引用的混合使用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$a = [];  <span class="comment">// $a         -&gt; zend_array_1(refcount=1, value=[])</span></span><br><span class="line">$b = $a;  <span class="comment">// $a, $b,    -&gt; zend_array_1(refcount=2, value=[])</span></span><br><span class="line">$c = $b   <span class="comment">// $a, $b, $c -&gt; zend_array_1(refcount=3, value=[])</span></span><br><span class="line"></span><br><span class="line">$d =&amp; $c; <span class="comment">// $a, $b                                 -&gt; zend_array_1(refcount=3, value=[])</span></span><br><span class="line">             <span class="comment">// $c, $d -&gt; zend_reference_1(refcount=2) ---^</span></span><br><span class="line">             <span class="comment">// Note that all variables share the same zend_array, even though some are</span></span><br><span class="line">             <span class="comment">// PHP references and some aren't.</span></span><br><span class="line"></span><br><span class="line">$d[] = <span class="number">1</span>;   <span class="comment">// $a, $b                                 -&gt; zend_array_1(refcount=2, value=[])</span></span><br><span class="line">         		<span class="comment">// $c, $d -&gt; zend_reference_1(refcount=2) -&gt; zend_array_2(refcount=1, value=[1])</span></span><br><span class="line">         		<span class="comment">// Only at this point, once an assignment occurs, the zend_array is duplicated.</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，所有的变量共享同一个数组（即使一些是通过引用赋值的），这一点是和PHP 5有很大的不同。在PHP 7中将一个大的，被引用的数组传递给count依然是安全的，它不会被复制。引用通常比正常值要小，因为它们一个zend_reference结构体而且通常不在引擎代码的fast-path中处理。</p>
<h3 id="Wrapping_up">Wrapping up</h3><p>总的来说，PHP 7中最基本的变化就是zval不再在堆上独立分配和将引用存储在自身结构之中。取而代之，复杂的数据类型如字符串、数组和对象会拥有引用计数。这样做的结果就是较少的内存分配，较少的间接寻址和内存占用。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="PHP7_变量的内核实现_-Part_1">PHP7 变量的内核实现 -Part 1</h3><p>【原文链接】（<a href="http://nikic.github.io/2015/05/05/Internal-value-representation-in]]>
    </summary>
    
      <category term="PHP7 ZVAL" scheme="http://www.flydream.org/tags/php7-zval/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[PHP 内核学习 -- 变量的作用域和生命周期]]></title>
    <link href="http://www.flydream.org/2015/08/08/varlifttime/"/>
    <id>http://www.flydream.org/2015/08/08/varlifttime/</id>
    <published>2015-08-08T08:44:32.000Z</published>
    <updated>2016-02-21T13:43:55.000Z</updated>
    <content type="html"><![CDATA[<h3 id="作用域_生命周期"><strong>作用域</strong> <strong>生命周期</strong></h3><p>变量的作用域本质是一块代码区域，在这个区域内可以访问某个具体的变量，超出这个区域后，变量就无法被访问到。</p>
<h4 id="全局变量和局部变量">全局变量和局部变量</h4><p>全局变量是在整个程序中任何地方随意调用的变量， 在PHP中，除了声明在函数体内的普通变量均为全局变量，在函数体内则可以通过global语句来声明。 相对于全局变量，局部变量的作用域是程序中的部分代码（如函数中），而不是程序的全部。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scope</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="variable">$liftcycle</span> = <span class="string">"wang"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>变量的生命周期和作用域有一定的联系，如函数中的局部变量$filecycle，它的生命开始于函数scope的执行，结束于函数执行完毕。</p>
<p>PHP变量的作用域是如何实现 ？全局变量和局部变量的的作用域实现有什么区别？</p>
<p>zend引擎有一个_zend_executor_globals结构，全局变量就保存在symbol_table这个全局符号表中；active_symbol_table中保存局部变量，这些局部变量可能是来自用户自定的函数或者对象的属性等；而且每个独立的函数运行时都有自己的active_symbol_table来保证作用域互相独立。</p>
<p>下面来看一下，_zend_execute_data (zend/zend_complie.h)的结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">		</span><br><span class="line">   <span class="keyword">typedef</span> <span class="keyword">struct</span> _zend_execute_data &#123;    </span><br><span class="line">	<span class="keyword">struct</span> _zend_op *opline;</span><br><span class="line">	zend_function_state function_state;</span><br><span class="line">	zend_op_array *op_array;</span><br><span class="line">	zval *object;</span><br><span class="line">	HashTable *symbol_table;</span><br><span class="line">	<span class="keyword">struct</span> _zend_execute_data *prev_execute_data;</span><br><span class="line">	zval *old_error_reporting;</span><br><span class="line">	zend_bool nested;</span><br><span class="line">	zval **original_return_value;</span><br><span class="line">	zend_class_entry *current_scope;</span><br><span class="line">	zend_class_entry *current_called_scope;</span><br><span class="line">	zval *current_this;</span><br><span class="line">	<span class="keyword">struct</span> _zend_op *fast_ret; <span class="comment">/* used by FAST_CALL/FAST_RET (finally keyword) */</span></span><br><span class="line">	zval *delayed_exception;</span><br><span class="line">	call_slot *call_slots;</span><br><span class="line">	call_slot *call;</span><br><span class="line">&#125; zend_execute_data;</span><br></pre></td></tr></table></figure>
<p>函数中的局部变量就存储在_zend_execute_data的symbol_table中，在执行当前函数的op_array时， 全局zend_executor_globals中的<em>active_symbol_table会指向当前_zend_execute_data中的</em>symbol_table。 因为每个函数调用开始时都会重新初始化EG(active_symbol_table)为NULL， 在这个函数的所有opcode的执行过程中这个全局变量会一直存在，并且所有的局部变量修改都是在它上面操作完成的，如前面的赋值操作等。 而此时，其他函数中的symbol_table会存放在栈中，将当前函数执行完并返回时，程序会将之前保存的zend_execute_data恢复， 从而其他函数中的变量也就不会被找到，局部变量的作用域就是以这种方式来实现的。 相关操作在 Zend/zend_vm_execute.h 文件中定义的execute函数中一目了然，如下所示代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">zend_vm_enter:</span><br><span class="line"><span class="comment">/* Initialize execute_data */</span></span><br><span class="line">execute_data = (zend_execute_data *)zend_vm_stack_alloc(</span><br><span class="line">    <span class="keyword">sizeof</span>(zend_execute_data) +</span><br><span class="line">    <span class="keyword">sizeof</span>(zval**) * op_array-&gt;last_var *(EG(active_symbol_table) ? <span class="number">1</span> : <span class="number">2</span>) +</span><br><span class="line">    <span class="keyword">sizeof</span>(temp_variable) * op_array-&gt;T TSRMLS_CC);</span><br><span class="line"> </span><br><span class="line">EX(symbol_table) = EG(active_symbol_table);</span><br><span class="line">EX(prev_execute_data) = EG(current_execute_data);</span><br><span class="line">EG(current_execute_data) = execute_data;</span><br></pre></td></tr></table></figure>
<p>EX宏的作用是获取结构体zend_execute_data的字段值。它的实现是:#define EX(element) execute_data-&gt;element</p>
<h4 id="全局宏">全局宏</h4><ul>
<li>EG(Executor Globals)：zend引擎内部用来追踪当前请求的处理状态，这些信息包括系统符号表，函数和类表，常量和资源类型。</li>
<li>CG(Core Globals)：zend引擎在脚本执行和各种深入内核的执行时使用。自定义的扩展很少会使用到它。</li>
<li>PG(PHP Globals)：php的配置 如PG(register_globals),PG(safe_mode)和PG(memory_limit)</li>
<li>FG(FILE Globals)：大多数的文件I/或者和流处理相关的全局变量都被塞进了这个宏里。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h3 id="作用域_生命周期"><strong>作用域</strong> <strong>生命周期</strong></h3><p>变量的作用域本质是一块代码区域，在这个区域内可以访问某个具体的变量，超出这个区域后，变量就无法被访问到。</p>
<h4 id="全局变量和局部]]>
    </summary>
    
      <category term="PHP内核 变量 作用域 生命周期" scheme="http://www.flydream.org/tags/php%E5%86%85%E6%A0%B8-%E5%8F%98%E9%87%8F-%E4%BD%9C%E7%94%A8%E5%9F%9F-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
</feed>
